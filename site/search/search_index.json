{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Skycoin Wiki! Here you can find all you have to know about the projects and products of Skycoin. If you have further questions, you are always welcomed on Telegram and Reddit . Workshops Here we will list and or link all upcoming workshops regarding Skycoin's projects. Meetups Join the Skycoin Meetups Telegram Group for more information. Thursday, 2019 Oct 17 th 6-8pm at the New York City Blockchain Center Saturday, 2019 Oct 19 th 4pm at the Cryptospace Los Angeles Thursday, 2019 Dec 5 th 6-8pm at the New York City Blockchain Center Saturday, 2019 Dec 7 th 4pm at the Cryptospace Los Angeles Friday, 2020 May 8 th 7-9pm at Meetup.com (FR) News TODO: keep up to date Skycoin Blog Media Bitcoin Is a Digital Asset Says Intermediate People\u2019s Court in China Total Vindication for Skycoin Founder in \u2018Kidnapping\u2019 Case Skycoin lawsuit affirms Bitcoin is legitimate property in China Partnerships LBank - Genesis Community Node NYC Blockchain Center - Growth Level member Jiangxi University of Software Professional Technology","title":"Home"},{"location":"#welcome-to-the-skycoin-wiki","text":"Here you can find all you have to know about the projects and products of Skycoin. If you have further questions, you are always welcomed on Telegram and Reddit .","title":"Welcome to the Skycoin Wiki!"},{"location":"#workshops","text":"Here we will list and or link all upcoming workshops regarding Skycoin's projects.","title":"Workshops"},{"location":"#meetups","text":"Join the Skycoin Meetups Telegram Group for more information. Thursday, 2019 Oct 17 th 6-8pm at the New York City Blockchain Center Saturday, 2019 Oct 19 th 4pm at the Cryptospace Los Angeles Thursday, 2019 Dec 5 th 6-8pm at the New York City Blockchain Center Saturday, 2019 Dec 7 th 4pm at the Cryptospace Los Angeles Friday, 2020 May 8 th 7-9pm at Meetup.com (FR)","title":"Meetups"},{"location":"#news","text":"TODO: keep up to date Skycoin Blog","title":"News"},{"location":"#media","text":"Bitcoin Is a Digital Asset Says Intermediate People\u2019s Court in China Total Vindication for Skycoin Founder in \u2018Kidnapping\u2019 Case Skycoin lawsuit affirms Bitcoin is legitimate property in China","title":"Media"},{"location":"#partnerships","text":"LBank - Genesis Community Node NYC Blockchain Center - Growth Level member Jiangxi University of Software Professional Technology","title":"Partnerships"},{"location":"brand/","text":"Welcome to the Brand-Site! Here you will find everything that you will need to make merchandise products, stickers or wallpapers. Official Brand Guidelines https://downloads.skycoin.com/branding/Skycoin-Brand_Guidelines-v1.6.pdf Skycoin Font https://downloads.skycoin.com/branding/Skycoin-Sans.zip Official Logos https://downloads.skycoin.com/branding/Skycoin-Logos.zip Icon & Cloud Skyfleet Here you have got a small collection of beautiful things members of skyfleet came up with. Sticker preview pixel vector .png - .png - .png - .png - .png - Wallpaper Desktop Mobile","title":"Brand"},{"location":"brand/#welcome-to-the-brand-site","text":"Here you will find everything that you will need to make merchandise products, stickers or wallpapers.","title":"Welcome to the Brand-Site!"},{"location":"brand/#official","text":"","title":"Official"},{"location":"brand/#brand-guidelines","text":"https://downloads.skycoin.com/branding/Skycoin-Brand_Guidelines-v1.6.pdf","title":"Brand Guidelines"},{"location":"brand/#skycoin-font","text":"https://downloads.skycoin.com/branding/Skycoin-Sans.zip","title":"Skycoin Font"},{"location":"brand/#official-logos","text":"https://downloads.skycoin.com/branding/Skycoin-Logos.zip","title":"Official Logos"},{"location":"brand/#icon-cloud","text":"","title":"Icon &amp; Cloud"},{"location":"brand/#skyfleet","text":"Here you have got a small collection of beautiful things members of skyfleet came up with.","title":"Skyfleet"},{"location":"brand/#sticker","text":"preview pixel vector .png - .png - .png - .png - .png -","title":"Sticker"},{"location":"brand/#wallpaper","text":"","title":"Wallpaper"},{"location":"brand/#desktop","text":"","title":"Desktop"},{"location":"brand/#mobile","text":"","title":"Mobile"},{"location":"buywithsky/","text":"Buy with SKY or SCH Site Information SKY SCH 6dollarshirts.com T-Shirt with the skycoin logo hostwithsky.com Host your Website by \"staking\" SKY","title":"Use SKY/SCH"},{"location":"buywithsky/#buy-with-sky-or-sch","text":"Site Information SKY SCH 6dollarshirts.com T-Shirt with the skycoin logo hostwithsky.com Host your Website by \"staking\" SKY","title":"Buy with SKY or SCH"},{"location":"contribute/","text":"Contribute If you want to help to make this wiki great you have got different options. Either you install all dependencies or you open an issue. DIY (git & mkdocs) Make a Github Account Clone this repository Install mkdocs Pull-Request your changes Change News Header You can change the information of the header in the file overrides/main.html Open an issue If you find a typo or want text to be added you also can open an issue and either write what the typo is or post the text and the position where you want it to be added. Just open an issue here","title":"Contribute"},{"location":"contribute/#contribute","text":"If you want to help to make this wiki great you have got different options. Either you install all dependencies or you open an issue. DIY (git & mkdocs) Make a Github Account Clone this repository Install mkdocs Pull-Request your changes Change News Header You can change the information of the header in the file overrides/main.html Open an issue If you find a typo or want text to be added you also can open an issue and either write what the typo is or post the text and the position where you want it to be added. Just open an issue here","title":"Contribute"},{"location":"exchanges/","text":"Centralized Exchanges Name SKY-Pairs SCH-Pairs Binance BTC, BNB - Bitbns USDT, INR - ExMarkets USDT - FINEXBOX BTC - HotBit USDT - LATOKEN BTC, ETH, USDT - LBank BTC,LBCN - P2PB2B USDT - Resfinex GRT, USDT - WhiteBIT USDT - Decentralized Exchanges Name SKY-Pairs SCH-Pairs XBTS DEX any any Coin Swaps Name SKY-Pairs SCH-Pairs Coinsuper any - Coinswitch any - Exolis any - InstaSwap any - SimpleSwap any - StealthEX any - Swaplab any - SwapSpace any - Fiat Name SKY-Pairs SCH-Pairs bitladon EUR - skycoin USD, EUR -","title":"Exchanges"},{"location":"exchanges/#centralized-exchanges","text":"Name SKY-Pairs SCH-Pairs Binance BTC, BNB - Bitbns USDT, INR - ExMarkets USDT - FINEXBOX BTC - HotBit USDT - LATOKEN BTC, ETH, USDT - LBank BTC,LBCN - P2PB2B USDT - Resfinex GRT, USDT - WhiteBIT USDT -","title":"Centralized Exchanges"},{"location":"exchanges/#decentralized-exchanges","text":"Name SKY-Pairs SCH-Pairs XBTS DEX any any","title":"Decentralized Exchanges"},{"location":"exchanges/#coin-swaps","text":"Name SKY-Pairs SCH-Pairs Coinsuper any - Coinswitch any - Exolis any - InstaSwap any - SimpleSwap any - StealthEX any - Swaplab any - SwapSpace any -","title":"Coin Swaps"},{"location":"exchanges/#fiat","text":"Name SKY-Pairs SCH-Pairs bitladon EUR - skycoin USD, EUR -","title":"Fiat"},{"location":"videos/","text":"Videos Official Channel Skycoin Skyfleet Channels Pure Skyfleet Fray Interviewers CryptoRich Adam Stokes Interviews & More 2020 05-14: (Adam Stokes) Skycoin update - Latest interview with Synth 2020 1 05-04: (CryptoRich) SYNTH SPEAKS! - Bitcoin Halving, Skycoin Secrets, Covid ... 1 2 3 4 5 6 01-06: (Adam Stokes) Skycoin update - Synth and Stokesy 1 2 07-31: (CryptoRich) SYNTH SPEAKS! - The State of the World Today 1 2 3 08-10: (Adam Stokes) LATEST from Skycoin (SKY) - An August 2020 Interview with Synth 1 10-15: (CryptoRich) SYNTH SPEAKS! - Oct 2020 Update 1 2 Roadmap Talks Synth Talks - Skycoin Roadmap 1 2 3 4","title":"Videos"},{"location":"videos/#videos","text":"","title":"Videos"},{"location":"videos/#official-channel","text":"Skycoin","title":"Official Channel"},{"location":"videos/#skyfleet-channels","text":"","title":"Skyfleet Channels"},{"location":"videos/#pure-skyfleet","text":"Fray","title":"Pure Skyfleet"},{"location":"videos/#interviewers","text":"CryptoRich Adam Stokes","title":"Interviewers"},{"location":"videos/#interviews-more","text":"","title":"Interviews &amp; More"},{"location":"videos/#2020","text":"05-14: (Adam Stokes) Skycoin update - Latest interview with Synth 2020 1 05-04: (CryptoRich) SYNTH SPEAKS! - Bitcoin Halving, Skycoin Secrets, Covid ... 1 2 3 4 5 6 01-06: (Adam Stokes) Skycoin update - Synth and Stokesy 1 2 07-31: (CryptoRich) SYNTH SPEAKS! - The State of the World Today 1 2 3 08-10: (Adam Stokes) LATEST from Skycoin (SKY) - An August 2020 Interview with Synth 1 10-15: (CryptoRich) SYNTH SPEAKS! - Oct 2020 Update 1 2","title":"2020"},{"location":"videos/#roadmap-talks","text":"Synth Talks - Skycoin Roadmap 1 2 3 4","title":"Roadmap Talks"},{"location":"hardware/","text":"Hardware Overview Skywallet Skywallet DK Skyminer","title":"Overview"},{"location":"hardware/#hardware-overview","text":"Skywallet Skywallet DK Skyminer","title":"Hardware Overview"},{"location":"hardware/skyminer/","text":"Skyminer TODO: copy from skywire wiki and write new content","title":"Skyminer"},{"location":"hardware/skyminer/#skyminer","text":"TODO: copy from skywire wiki and write new content","title":"Skyminer"},{"location":"hardware/skywallet/","text":"Skywallet The Hardware Wallet of the Skycoin Project is able to hold your private keys for you so your lovely coins can't get stolen. At the moment the wallet only supports Skycoin and CoinHours, but in the future you will be able to store a lot of other coins or even use your Wallet for authentification and more. Youtube: \"Skywallet - Coming to a Sky-store near you!\" Manual 1. Checking the genuineness 2. Initializing the wallet 3. Personalizing the wallet 4. Firmware Update 5. Testing your Seed 6. Restoring Backup 7. Optimizing the Security 8. Sending and Receiving Coins 9. Miscellaneous Operations 10. Troubleshooting Supported Coins Name Symbol Info Skycoin SKY also SCH Bitcoin BTC \u2190 soon Ethereum ETH \u2190 soon ETH-Tokens ERC-20 \u2190 soon Support Telegram Support Page Email Support Store store.skycoin.com","title":"Overview"},{"location":"hardware/skywallet/#skywallet","text":"The Hardware Wallet of the Skycoin Project is able to hold your private keys for you so your lovely coins can't get stolen. At the moment the wallet only supports Skycoin and CoinHours, but in the future you will be able to store a lot of other coins or even use your Wallet for authentification and more. Youtube: \"Skywallet - Coming to a Sky-store near you!\"","title":"Skywallet"},{"location":"hardware/skywallet/#manual","text":"1. Checking the genuineness 2. Initializing the wallet 3. Personalizing the wallet 4. Firmware Update 5. Testing your Seed 6. Restoring Backup 7. Optimizing the Security 8. Sending and Receiving Coins 9. Miscellaneous Operations 10. Troubleshooting","title":"Manual"},{"location":"hardware/skywallet/#supported-coins","text":"Name Symbol Info Skycoin SKY also SCH Bitcoin BTC \u2190 soon Ethereum ETH \u2190 soon ETH-Tokens ERC-20 \u2190 soon","title":"Supported Coins"},{"location":"hardware/skywallet/#support","text":"Telegram Support Page Email Support","title":"Support"},{"location":"hardware/skywallet/#store","text":"store.skycoin.com","title":"Store"},{"location":"hardware/skywallet/manual-1-checking-the-genuineness/","text":"Checking the Genuineness of your Skywallet Checking your Skywallet Package for Tampering Once you receive the Skywallet shipment, please check for any physical tampering or damage to the package of any sort. Tampering or damage can be anything from a small tear on the package to a package that is torn open. Danger Do not accept a shipment which seems to be damaged in any such way Front Back Sticker Note Please ensure that the holographic sticker with the Skycoin logo on the Skywallet box is not broken. Checking the Firmware The Skywallet is built to provide maximum security to the user. However, it is vital to check that your Skywallet is not compromised before using it. Step 1 - Connecting Your Skywallet First, connect the Skywallet to your USB port. Step 2 - Checking the message on your Skywallet's Display The display on your Skywallet shows one of the following three messages when connected via USB port, marking the authenticity of your Skywallet. Scenario 1 If the Skywallet is a genuine one and is being used for the first time, then the screen will display the following message: Welcome! Please visit skycoin.com Along with the Skycoin Logo. A Skywallet that is being used for the first time will not have a firmware installed. The firmware is the software interface which helps the hardware to interact with both the user as well as a computer. Thus without a firmware, your Skywallet will not work correctly. Any message apart from this welcome message implies that your Skywallet has been tampered with by a third party. Thus if you get any message apart from the welcome message, proceed to disconnect the device and contact support immediately. Scenario 2 A previously used Skywallet may have a firmware initialized, and if it has, then it might mean that it has been manipulated. Such a Skywallet will display the following message on its display screen: Needs Seed! Along with the Skycoin Logo. If you get a \"Needs Seed!\" message on your first use, it means that your Skywallet is not a new one and has a firmware already initialized. Warning If you do get a Needs Seed! message on your first use of the Skywallet, refrain from using the device. For further assistance, Please contact the support team immediately. You can use the following link to contact support: Support Page Alternatively, you can detail your concerns and send an email to support@skycoin.com Scenario 3 The third and final message that might be displayed is a warning: Unofficial Firmware Detected such a message denote that the Skywallet is running on a firmware that is not approved by Skycoin. Danger Do not use a Skywallet displaying that warning as the software version on your Skywallet might be corrupted, and it is unsafe to use the Skywallet, as using the said Skywallet could potentially make you lose your coins. Note If you get an Unofficial Firmware Detected message on your Skywallet then immediately disconnect the device and contact the Skycoin support. You can use the following link to the Support page . Alternatively, you can detail your concerns and send an email to support@skycoin.com .","title":"Checking the genuineness"},{"location":"hardware/skywallet/manual-1-checking-the-genuineness/#checking-the-genuineness-of-your-skywallet","text":"","title":"Checking the Genuineness of your Skywallet"},{"location":"hardware/skywallet/manual-1-checking-the-genuineness/#checking-your-skywallet-package-for-tampering","text":"Once you receive the Skywallet shipment, please check for any physical tampering or damage to the package of any sort. Tampering or damage can be anything from a small tear on the package to a package that is torn open. Danger Do not accept a shipment which seems to be damaged in any such way Front Back Sticker Note Please ensure that the holographic sticker with the Skycoin logo on the Skywallet box is not broken.","title":"Checking your Skywallet Package for Tampering"},{"location":"hardware/skywallet/manual-1-checking-the-genuineness/#checking-the-firmware","text":"The Skywallet is built to provide maximum security to the user. However, it is vital to check that your Skywallet is not compromised before using it. Step 1 - Connecting Your Skywallet First, connect the Skywallet to your USB port. Step 2 - Checking the message on your Skywallet's Display The display on your Skywallet shows one of the following three messages when connected via USB port, marking the authenticity of your Skywallet. Scenario 1 If the Skywallet is a genuine one and is being used for the first time, then the screen will display the following message: Welcome! Please visit skycoin.com Along with the Skycoin Logo. A Skywallet that is being used for the first time will not have a firmware installed. The firmware is the software interface which helps the hardware to interact with both the user as well as a computer. Thus without a firmware, your Skywallet will not work correctly. Any message apart from this welcome message implies that your Skywallet has been tampered with by a third party. Thus if you get any message apart from the welcome message, proceed to disconnect the device and contact support immediately. Scenario 2 A previously used Skywallet may have a firmware initialized, and if it has, then it might mean that it has been manipulated. Such a Skywallet will display the following message on its display screen: Needs Seed! Along with the Skycoin Logo. If you get a \"Needs Seed!\" message on your first use, it means that your Skywallet is not a new one and has a firmware already initialized. Warning If you do get a Needs Seed! message on your first use of the Skywallet, refrain from using the device. For further assistance, Please contact the support team immediately. You can use the following link to contact support: Support Page Alternatively, you can detail your concerns and send an email to support@skycoin.com Scenario 3 The third and final message that might be displayed is a warning: Unofficial Firmware Detected such a message denote that the Skywallet is running on a firmware that is not approved by Skycoin. Danger Do not use a Skywallet displaying that warning as the software version on your Skywallet might be corrupted, and it is unsafe to use the Skywallet, as using the said Skywallet could potentially make you lose your coins. Note If you get an Unofficial Firmware Detected message on your Skywallet then immediately disconnect the device and contact the Skycoin support. You can use the following link to the Support page . Alternatively, you can detail your concerns and send an email to support@skycoin.com .","title":"Checking the Firmware"},{"location":"hardware/skywallet/manual-10-troubleshooting/","text":"Troubleshooting Here are some of the most common issues you might encounter when using a Skywallet and the best possible resolutions for troubleshooting these issues. If you do not find a resolution for your issue, make sure you contact the support team via - store.skycoin.com/pages/support . You can also send an email at support@skycoin.com . 1. Lost/Stolen Skywallet If your Skywallet is lost or stolen, the recommended solution is to get a new one as soon as possible. Once you got the new Skywallet, restore the coins using the Seed of your old Skywallet. Even though not a recommended method, as an immediate solution, you can also create a new Desktop Wallet to restore the lost Skywallet. This method is not recommended and should only be used if you cannot get a new Skywallet, as entering the Seed of your Skywallet into any electronic device could potentially compromise the security of the Seed of your Skywallet and hence putting your coins at risk. Note If you are opting for this solution, note that this is a temporary solution, and it is always recommended that you transfer your coins (not restore the backup of the old Skywallet) to a new Skywallet as soon as you obtain one. Also, it is vital that you configure your new Skywallet as a new one with a new Seed and not restore the backup of your old Skywallet if the Seed has already been entered in your Desktop Wallet. 2. Lost the PIN code of Your Skywallet If you have forgotten or lost the PIN code to your Skywallet then the only way to retrieve your funds is using your Seed . You can use the Seed of your Skywallet to Wipe the Device and then restore the device using the same Seed. The wiped device will not have a PIN code set, and it is recommended that you immediately set a PIN code that is easy to remember but at the same time not easy to guess. You can visit the following chapter to know more about setting a PIN and the security recommendations for your Skywallet - Optimize account security . 3. Too Many Transactions Issue Bug When you try to send coins to a Wallet and if the particular transaction has too many inputs or outputs, then an error message will be displayed upon pressing the \"Preview\" button or the \"Send\" button. To still transfer your funds, you can split up your transaction into multiple transactions and then send the coins. Note This issue will be fixed in a future update.","title":"Troubleshooting"},{"location":"hardware/skywallet/manual-10-troubleshooting/#troubleshooting","text":"Here are some of the most common issues you might encounter when using a Skywallet and the best possible resolutions for troubleshooting these issues. If you do not find a resolution for your issue, make sure you contact the support team via - store.skycoin.com/pages/support . You can also send an email at support@skycoin.com .","title":"Troubleshooting"},{"location":"hardware/skywallet/manual-10-troubleshooting/#1-loststolen-skywallet","text":"If your Skywallet is lost or stolen, the recommended solution is to get a new one as soon as possible. Once you got the new Skywallet, restore the coins using the Seed of your old Skywallet. Even though not a recommended method, as an immediate solution, you can also create a new Desktop Wallet to restore the lost Skywallet. This method is not recommended and should only be used if you cannot get a new Skywallet, as entering the Seed of your Skywallet into any electronic device could potentially compromise the security of the Seed of your Skywallet and hence putting your coins at risk. Note If you are opting for this solution, note that this is a temporary solution, and it is always recommended that you transfer your coins (not restore the backup of the old Skywallet) to a new Skywallet as soon as you obtain one. Also, it is vital that you configure your new Skywallet as a new one with a new Seed and not restore the backup of your old Skywallet if the Seed has already been entered in your Desktop Wallet.","title":"1. Lost/Stolen Skywallet"},{"location":"hardware/skywallet/manual-10-troubleshooting/#2-lost-the-pin-code-of-your-skywallet","text":"If you have forgotten or lost the PIN code to your Skywallet then the only way to retrieve your funds is using your Seed . You can use the Seed of your Skywallet to Wipe the Device and then restore the device using the same Seed. The wiped device will not have a PIN code set, and it is recommended that you immediately set a PIN code that is easy to remember but at the same time not easy to guess. You can visit the following chapter to know more about setting a PIN and the security recommendations for your Skywallet - Optimize account security .","title":"2. Lost the PIN code of Your Skywallet"},{"location":"hardware/skywallet/manual-10-troubleshooting/#3-too-many-transactions-issue","text":"Bug When you try to send coins to a Wallet and if the particular transaction has too many inputs or outputs, then an error message will be displayed upon pressing the \"Preview\" button or the \"Send\" button. To still transfer your funds, you can split up your transaction into multiple transactions and then send the coins. Note This issue will be fixed in a future update.","title":"3. Too Many Transactions Issue"},{"location":"hardware/skywallet/manual-2-initializing-the-wallet/","text":"Initializing your Skywallet After successfully checking that your Skywallet is genuine, you can begin with the initialization of your Skywallet. Step 1: Install Desktop Wallet The first step in initializing your Skywallet is to install the Skycoin Desktop Wallet. Please make sure to download the latest compatible version from the Skycoin Downloads Page. If you already have the latest Desktop Wallet installed and configured, then you can skip this step. Step 2: Install deamon The next step is to download and install the daemon. Following are the steps to install the daemon in different operating systems: Windows Download the daemon from the following link - You have to run the daemon every time you want to use the Skywallet. macOS Download the .pkg file from the following link - Double Click on the downloaded file and follow the instructions in the installer. Once completed, the daemon runs in the background, so you do not have to start it manually. Linux Open terminal on your Linux machine. Execute the following command using the terminal: wget -O /tmp/skyhwd.deb https://downloads.skycoin.net/skywallet-daemon/skyhwd_0.1.0_amd64.deb* After the process is complete execute the following command: dpkg -i /tmp/skyhwd.deb Once completed, the daemon will run in the background. Step 3: Connect Connect your Skywallet to the USB port. Step 4: Open Desktop Wallet Once you have connected the Skywallet to the USB port, open the Skycoin Desktop Wallet. If it is the first time you are using your Skywallet, please make sure to go through the following section of the user manual, Checking the Genuineness of your Skywallet , to ensure that you are using a genuine Skywallet. The instructions for a Desktop Wallet which is used for the first time and an already configured Desktop Wallet are different. Step 4.1: First Time Use of a Desktop Wallet If you are using the Desktop Wallet for the first time, you will see the following screen : To configure your Skywallet, proceed to click on \u201cUsing a hardware wallet?\u201d button. Upon pressing the \u201cUsing a hardware wallet?\u201d button, the display screen on your Skywallet will show a welcome message: To configure your Skywallet for the first time, you have to install the firmware for the Skywallet, as explained in Step 5. Step 4.2: Previously Configured Desktop Wallet If you are not using your Desktop Wallet for the first time, then on connecting the Skywallet via USB, the following window will be displayed. The window will display a list of all the Wallets that are already configured in your Desktop Wallet. Note This may include both Hardware and Software Wallets To configure your Skywallet click on the \u201cHardware Wallet\u201d button. On pressing \u201cHardware Wallet\u201d button, the display screen on the Skywallet will show a welcome message: Once the welcome message is displayed on the Skywallet screen, you can proceed to install the firmware. Step 5: Installing the Firmware To indicate the beginning of the firmware installation, the Desktop Wallet will show the following window: You can click on continue to start installing the firmware for your Skywallet. The installation process will take a few seconds to complete. Once the installation is complete, you can proceed to configure the Skywallet. Note If the installation process gets abruptly terminated for any reasons, you can disconnect the Skywallet, close the Desktop Wallet and then restart the whole process from the start. Step 6: Skywallet Configuration Once the firmware installation is complete, the \u201cNEEDS SEED!\u201d message is displayed by the Skywallet. Simultaneously, the following window will be displayed by the Desktop Wallet. In this window, you can select two options : \u201cConfigure automatically\u201d \"Restore backup\" Step 6.1: Configure automatically If you are using a Skywallet for the first time, then you can proceed with the option of \u201cConfigure Automatically\u201d. \u201cConfigure automatically\u201d button will configure your Skywallet as a new one. Once the configuration is complete, the following window will be displayed. You can use this window to change the name of your Skywallet. After which you can click on the \u201cClose\u201d button to close the window. Step 6.2: Restore backup If you have already made a backup of a previously used Skywallet and need to restore it on the new Skywallet, then you can opt for the Restore Backup option. The restoration process is explained in detail in this section - Restore Configuration If the Skywallet is not connected or not detected by your computer, then the following error message will be displayed:","title":"Initializing the wallet"},{"location":"hardware/skywallet/manual-2-initializing-the-wallet/#initializing-your-skywallet","text":"After successfully checking that your Skywallet is genuine, you can begin with the initialization of your Skywallet. Step 1: Install Desktop Wallet The first step in initializing your Skywallet is to install the Skycoin Desktop Wallet. Please make sure to download the latest compatible version from the Skycoin Downloads Page. If you already have the latest Desktop Wallet installed and configured, then you can skip this step. Step 2: Install deamon The next step is to download and install the daemon. Following are the steps to install the daemon in different operating systems: Windows Download the daemon from the following link - You have to run the daemon every time you want to use the Skywallet. macOS Download the .pkg file from the following link - Double Click on the downloaded file and follow the instructions in the installer. Once completed, the daemon runs in the background, so you do not have to start it manually. Linux Open terminal on your Linux machine. Execute the following command using the terminal: wget -O /tmp/skyhwd.deb https://downloads.skycoin.net/skywallet-daemon/skyhwd_0.1.0_amd64.deb* After the process is complete execute the following command: dpkg -i /tmp/skyhwd.deb Once completed, the daemon will run in the background. Step 3: Connect Connect your Skywallet to the USB port. Step 4: Open Desktop Wallet Once you have connected the Skywallet to the USB port, open the Skycoin Desktop Wallet. If it is the first time you are using your Skywallet, please make sure to go through the following section of the user manual, Checking the Genuineness of your Skywallet , to ensure that you are using a genuine Skywallet. The instructions for a Desktop Wallet which is used for the first time and an already configured Desktop Wallet are different. Step 4.1: First Time Use of a Desktop Wallet If you are using the Desktop Wallet for the first time, you will see the following screen : To configure your Skywallet, proceed to click on \u201cUsing a hardware wallet?\u201d button. Upon pressing the \u201cUsing a hardware wallet?\u201d button, the display screen on your Skywallet will show a welcome message: To configure your Skywallet for the first time, you have to install the firmware for the Skywallet, as explained in Step 5. Step 4.2: Previously Configured Desktop Wallet If you are not using your Desktop Wallet for the first time, then on connecting the Skywallet via USB, the following window will be displayed. The window will display a list of all the Wallets that are already configured in your Desktop Wallet. Note This may include both Hardware and Software Wallets To configure your Skywallet click on the \u201cHardware Wallet\u201d button. On pressing \u201cHardware Wallet\u201d button, the display screen on the Skywallet will show a welcome message: Once the welcome message is displayed on the Skywallet screen, you can proceed to install the firmware. Step 5: Installing the Firmware To indicate the beginning of the firmware installation, the Desktop Wallet will show the following window: You can click on continue to start installing the firmware for your Skywallet. The installation process will take a few seconds to complete. Once the installation is complete, you can proceed to configure the Skywallet. Note If the installation process gets abruptly terminated for any reasons, you can disconnect the Skywallet, close the Desktop Wallet and then restart the whole process from the start. Step 6: Skywallet Configuration Once the firmware installation is complete, the \u201cNEEDS SEED!\u201d message is displayed by the Skywallet. Simultaneously, the following window will be displayed by the Desktop Wallet. In this window, you can select two options : \u201cConfigure automatically\u201d \"Restore backup\" Step 6.1: Configure automatically If you are using a Skywallet for the first time, then you can proceed with the option of \u201cConfigure Automatically\u201d. \u201cConfigure automatically\u201d button will configure your Skywallet as a new one. Once the configuration is complete, the following window will be displayed. You can use this window to change the name of your Skywallet. After which you can click on the \u201cClose\u201d button to close the window. Step 6.2: Restore backup If you have already made a backup of a previously used Skywallet and need to restore it on the new Skywallet, then you can opt for the Restore Backup option. The restoration process is explained in detail in this section - Restore Configuration If the Skywallet is not connected or not detected by your computer, then the following error message will be displayed:","title":"Initializing your Skywallet"},{"location":"hardware/skywallet/manual-3-personalizing-the-wallet/","text":"Personalizing your Skywallet After completing the initialization of your Skywallet, you can start to personalize your Skywallet using the Desktop Wallet. Upon configuring your Skywallet, it will be listed in the Wallet list. The list can be viewed when you open your Desktop Wallet. To personalize your Skywallet, connect your Skywallet via USB to your computer and then open the Desktop Wallet. Once the Desktop Wallet is opened, click on the Hardware Wallet button in the Desktop Wallet window. Once you click on the \"Hardware Wallet\" button, the following window will appear: When you use the Skywallet for the first time, you will find two warnings associated with Creating a Backup and Setting a Pin , displayed in the Desktop Wallet window. Both of these warnings are to be dealt with seriously, or it may compromise the security of your Skywallet. To complete these two tasks, you can use the options in the Hardware Wallet window. Following are the options available in this window: Create a backup The Seed of your Skywallet is a key component. A Seed is the only way to access the coins stored in your Skywallet. Once the initialization is complete, it is essential to backup this Seed and store it in a secure location. To backup the Seed of your Skywallet, click on the button \"Create a backup\" . Once you click the \"Create a backup\" button, a warning message will be displayed. After accepting this warning message, the Skywallet will start to display the words in your Seed one by one. You need to note down each of these words and store it in a secure location. You would have obtained a Seed card along with your Skywallet, we recommend you to use this Seed card to note down your Seed. Note - Make sure that it is retrievable because if anything happens to your device, it will be impossible to retrieve your coins without the Seed. After completing the display of the words in the Seed, the screen displays all the words in the Seed again , so that you can verify your entries. Note - After completing the Backup process, you cannot repeat the same. Hence it is essential to note the Seed down during this process. Once you have completed the backup process, the \"Create a backup\" button will be replaced by \"Confirm Seed\" button. To ensure optimal security, please make sure to go through this section of the user manual - Optimize account security Create PIN code Creating a PIN code for your Skywallet enhances its security, as only a person with the PIN can access the device. To create a PIN for your Skywallet for the first time, click on the button - Create PIN code Once you click on the button \"Create PIN code\" the following window will appear on the Desktop Wallet: Simultaneously a number Matrix will be displayed on your Skywallet display screen. To set the PIN, you have to use both the matrix as well as the Desktop Wallet window. Each position of the number in the matrix corresponds to its position in the keypad shown by the Desktop Wallet window. Alternatively, you can utilize the number keypad on your computer for entering the PIN. However, if you are using the number pad then note that the position of the number in the matrix is what decides which number you are entering. Note While setting up your PIN you have to enter it twice. After setting up your PIN, you can manage the PIN by changing or deleting the same. Change the PIN code Once you have created a PIN code, you can make modifications to your PIN code using the Hardware Wallet window. You can use the Change PIN Code option to change your current PIN code to a new one. Upon clicking the \"Change PIN Code\" button, the Hardware Wallet window will show you a keypad similar to the one you used to create the PIN code. You can enter the PIN code by utilizing the number matrix displayed by the Skywallet in the same way you used it for creating the PIN code. To change the PIN code, you have to enter the current PIN code first and then the new PIN code twice. Delete the PIN code Ideally, a Skywallet should always have a PIN code, and it is a recommended precaution to improve the security of your Skywallet. However, you can choose to delete the PIN code of your Skywallet using the Hardware Wallet window. To delete the PIN code of your Skywallet, you can click on the Delete PIN Code button. After accepting the confirmation message, you will be asked to enter the PIN code of your Skywallet. Once entered and comfirmed, the PIN code of your Skywallet will be deleted. To ensure optimal security, please make sure to go through this section of the user manual - Optimize account security Wipe the device Wipe the device button helps you to delete the data on your Skywallet. Once you click on the \"Wipe the device\" button, you will be asked to confirm the operation on both the Skywallet as well as Desktop Wallet. While confirming, note that there is an option to remove your Skywallet from the Wallet list in Desktop Wallet. By default, this option will be checked, and if not unchecked, your Skywallet will be removed from the Wallet list. Warning After confirming the warning message to wipe the device, all the data in your Skywallet will be erased except for the firmware updates. The firmware updates of your Skywallet cannot be deleted and will remain the same as before even after the deletion process. You can also restore all your coins by using the Seed of a previously configured Skywallet, details on how to restore your Skywallet are available on this section Restore Backup .","title":"Personalizing the wallet"},{"location":"hardware/skywallet/manual-3-personalizing-the-wallet/#personalizing-your-skywallet","text":"After completing the initialization of your Skywallet, you can start to personalize your Skywallet using the Desktop Wallet. Upon configuring your Skywallet, it will be listed in the Wallet list. The list can be viewed when you open your Desktop Wallet. To personalize your Skywallet, connect your Skywallet via USB to your computer and then open the Desktop Wallet. Once the Desktop Wallet is opened, click on the Hardware Wallet button in the Desktop Wallet window. Once you click on the \"Hardware Wallet\" button, the following window will appear: When you use the Skywallet for the first time, you will find two warnings associated with Creating a Backup and Setting a Pin , displayed in the Desktop Wallet window. Both of these warnings are to be dealt with seriously, or it may compromise the security of your Skywallet. To complete these two tasks, you can use the options in the Hardware Wallet window. Following are the options available in this window: Create a backup The Seed of your Skywallet is a key component. A Seed is the only way to access the coins stored in your Skywallet. Once the initialization is complete, it is essential to backup this Seed and store it in a secure location. To backup the Seed of your Skywallet, click on the button \"Create a backup\" . Once you click the \"Create a backup\" button, a warning message will be displayed. After accepting this warning message, the Skywallet will start to display the words in your Seed one by one. You need to note down each of these words and store it in a secure location. You would have obtained a Seed card along with your Skywallet, we recommend you to use this Seed card to note down your Seed. Note - Make sure that it is retrievable because if anything happens to your device, it will be impossible to retrieve your coins without the Seed. After completing the display of the words in the Seed, the screen displays all the words in the Seed again , so that you can verify your entries. Note - After completing the Backup process, you cannot repeat the same. Hence it is essential to note the Seed down during this process. Once you have completed the backup process, the \"Create a backup\" button will be replaced by \"Confirm Seed\" button. To ensure optimal security, please make sure to go through this section of the user manual - Optimize account security Create PIN code Creating a PIN code for your Skywallet enhances its security, as only a person with the PIN can access the device. To create a PIN for your Skywallet for the first time, click on the button - Create PIN code Once you click on the button \"Create PIN code\" the following window will appear on the Desktop Wallet: Simultaneously a number Matrix will be displayed on your Skywallet display screen. To set the PIN, you have to use both the matrix as well as the Desktop Wallet window. Each position of the number in the matrix corresponds to its position in the keypad shown by the Desktop Wallet window. Alternatively, you can utilize the number keypad on your computer for entering the PIN. However, if you are using the number pad then note that the position of the number in the matrix is what decides which number you are entering. Note While setting up your PIN you have to enter it twice. After setting up your PIN, you can manage the PIN by changing or deleting the same. Change the PIN code Once you have created a PIN code, you can make modifications to your PIN code using the Hardware Wallet window. You can use the Change PIN Code option to change your current PIN code to a new one. Upon clicking the \"Change PIN Code\" button, the Hardware Wallet window will show you a keypad similar to the one you used to create the PIN code. You can enter the PIN code by utilizing the number matrix displayed by the Skywallet in the same way you used it for creating the PIN code. To change the PIN code, you have to enter the current PIN code first and then the new PIN code twice. Delete the PIN code Ideally, a Skywallet should always have a PIN code, and it is a recommended precaution to improve the security of your Skywallet. However, you can choose to delete the PIN code of your Skywallet using the Hardware Wallet window. To delete the PIN code of your Skywallet, you can click on the Delete PIN Code button. After accepting the confirmation message, you will be asked to enter the PIN code of your Skywallet. Once entered and comfirmed, the PIN code of your Skywallet will be deleted. To ensure optimal security, please make sure to go through this section of the user manual - Optimize account security Wipe the device Wipe the device button helps you to delete the data on your Skywallet. Once you click on the \"Wipe the device\" button, you will be asked to confirm the operation on both the Skywallet as well as Desktop Wallet. While confirming, note that there is an option to remove your Skywallet from the Wallet list in Desktop Wallet. By default, this option will be checked, and if not unchecked, your Skywallet will be removed from the Wallet list. Warning After confirming the warning message to wipe the device, all the data in your Skywallet will be erased except for the firmware updates. The firmware updates of your Skywallet cannot be deleted and will remain the same as before even after the deletion process. You can also restore all your coins by using the Seed of a previously configured Skywallet, details on how to restore your Skywallet are available on this section Restore Backup .","title":"Personalizing your Skywallet"},{"location":"hardware/skywallet/manual-4-firmware-update/","text":"Updating the Firmware of your Skywallet The firmware of your Skywallet is its user interface. A brand new Skywallet will not have a firmware installed. Hence the first thing you have to do when you receive your Skywallet is to install the firmware. Once installed, the firmware of your Skywallet also needs periodic updates. It is essential you do these updates; otherwise, you would not benefit from the latest security features and upgrades, ultimately putting your coins under risk of security threats. Also, at times, the firmware updates are made to improve the functionality of your Skywallet. Knowing when to Update: The Skywallet is designed to store your coins on a long term basis. However, it is essential to connect your Skywallet periodically to check for an available firmware update. To check this, you can connect your Skywallet to your computer and open the Hardware Wallet window from the Desktop Wallet. If your firmware is an outdated version then the following warning message will be displayed: Note If you ignore this dialogue box, the warning message will continue to be displayed in the next window. Updating your Firmware: Warning Before you start updating your firmware, ensure that you have backed up the Seed of your Skywallet. It is vital that you have the backup of the Seed because once the update is complete, you will need the Seed to restore your coins. Help If you need assistance on how to backup the Seed, go to Personalization of your Skywallet . Once you have completed the backup of your Seed, you can proceed to update the firmware. You can begin by clicking on the Update button from the dialogue box which appears right after you connect your Skywallet to the computer. If you have ignored this message and are in the Hardware Wallet option window, you can click on the Update Firmware button. Once you have clicked on either the \"Update\" button or \"Update Firmware\" button, a dialogue box with the warning message to Backup your Seed will appear on your computer: The warning message will also ask you to connect your Skywallet in bootloader mode. To connect your Skywallet in bootloader mode, you have to follow these steps: Step 1 - Disconnect your Skywallet from the computer. Step 2 - Reconnect the Skywallet while simultaneously pressing both the physical buttons on the Skywallet. When connected in the bootloader mode, the display screen on your Skywallet shows the following: After which the display will show the Welcome message. To continue the update you have to accept the operation on your computer. The update process will be completed within a few seconds. Note If the update process gets abruptly terminated for any reasons, you can disconnect the Skywallet, close the Desktop Wallet and then restart the whole process from the start.","title":"Firmware update"},{"location":"hardware/skywallet/manual-4-firmware-update/#updating-the-firmware-of-your-skywallet","text":"The firmware of your Skywallet is its user interface. A brand new Skywallet will not have a firmware installed. Hence the first thing you have to do when you receive your Skywallet is to install the firmware. Once installed, the firmware of your Skywallet also needs periodic updates. It is essential you do these updates; otherwise, you would not benefit from the latest security features and upgrades, ultimately putting your coins under risk of security threats. Also, at times, the firmware updates are made to improve the functionality of your Skywallet.","title":"Updating the Firmware of your Skywallet"},{"location":"hardware/skywallet/manual-4-firmware-update/#knowing-when-to-update","text":"The Skywallet is designed to store your coins on a long term basis. However, it is essential to connect your Skywallet periodically to check for an available firmware update. To check this, you can connect your Skywallet to your computer and open the Hardware Wallet window from the Desktop Wallet. If your firmware is an outdated version then the following warning message will be displayed: Note If you ignore this dialogue box, the warning message will continue to be displayed in the next window.","title":"Knowing when to Update:"},{"location":"hardware/skywallet/manual-4-firmware-update/#updating-your-firmware","text":"Warning Before you start updating your firmware, ensure that you have backed up the Seed of your Skywallet. It is vital that you have the backup of the Seed because once the update is complete, you will need the Seed to restore your coins. Help If you need assistance on how to backup the Seed, go to Personalization of your Skywallet . Once you have completed the backup of your Seed, you can proceed to update the firmware. You can begin by clicking on the Update button from the dialogue box which appears right after you connect your Skywallet to the computer. If you have ignored this message and are in the Hardware Wallet option window, you can click on the Update Firmware button. Once you have clicked on either the \"Update\" button or \"Update Firmware\" button, a dialogue box with the warning message to Backup your Seed will appear on your computer: The warning message will also ask you to connect your Skywallet in bootloader mode. To connect your Skywallet in bootloader mode, you have to follow these steps: Step 1 - Disconnect your Skywallet from the computer. Step 2 - Reconnect the Skywallet while simultaneously pressing both the physical buttons on the Skywallet. When connected in the bootloader mode, the display screen on your Skywallet shows the following: After which the display will show the Welcome message. To continue the update you have to accept the operation on your computer. The update process will be completed within a few seconds. Note If the update process gets abruptly terminated for any reasons, you can disconnect the Skywallet, close the Desktop Wallet and then restart the whole process from the start.","title":"Updating your Firmware:"},{"location":"hardware/skywallet/manual-5-testing-your-seed/","text":"Testing Your Seed Once you have made the backup of a Seed, this Seed can be used to access your Skywallet. If you want to check, whether a Seed you have written down belongs to a given Skywallet, you can use the Confirm Seed button. This is a security procedure to check whether the backup has been successful. The \"Confirm Seed\" button will not be available when you are using your Skywallet for the first time. Instead, you will see the button Create Backup . Once you have clicked on the Create Backup button on the Hardware Wallet window and completed the process of the Seed backup, the \"Confirm Seed\" button will replace the \"Create Backup\" button. Hardware Wallet window, Before Seed backup: Hardware Wallet window, after Seed backup: To check whether a Seed belongs to a particular Skywallet, you have to connect your Skywallet first. Warning If you are connecting the Skywallet for the first time, please read the following manuals: * Initialization of your Skywallet * Personalization of your Skywallet to understand how to initialize and personalize your Skywallet for its first time use. If you see the \"Confirm Seed\" button on your Hardware Wallet window, then it means that you have already taken the backup of the Seed. After clicking on the \"Confirm Seed\" button, the Skywallet will ask you to enter the different words in your Seed. However, the sequence of these word positions will be in random order. Along with asking you to enter the words of the Seed at a particular position, the Skywallet may ask you to enter random words which are not part of the Seed. Info Both the random words and the random sequence are a security measure to ensure that a potential attacker who might have access to your computer does get neither the full Seed nor the right sequence. Once this process is complete, the Desktop Wallet will confirm whether the Seed you have entered is the correct Seed for the connected Skywallet.","title":"Testing your seed"},{"location":"hardware/skywallet/manual-5-testing-your-seed/#testing-your-seed","text":"Once you have made the backup of a Seed, this Seed can be used to access your Skywallet. If you want to check, whether a Seed you have written down belongs to a given Skywallet, you can use the Confirm Seed button. This is a security procedure to check whether the backup has been successful. The \"Confirm Seed\" button will not be available when you are using your Skywallet for the first time. Instead, you will see the button Create Backup . Once you have clicked on the Create Backup button on the Hardware Wallet window and completed the process of the Seed backup, the \"Confirm Seed\" button will replace the \"Create Backup\" button. Hardware Wallet window, Before Seed backup: Hardware Wallet window, after Seed backup: To check whether a Seed belongs to a particular Skywallet, you have to connect your Skywallet first. Warning If you are connecting the Skywallet for the first time, please read the following manuals: * Initialization of your Skywallet * Personalization of your Skywallet to understand how to initialize and personalize your Skywallet for its first time use. If you see the \"Confirm Seed\" button on your Hardware Wallet window, then it means that you have already taken the backup of the Seed. After clicking on the \"Confirm Seed\" button, the Skywallet will ask you to enter the different words in your Seed. However, the sequence of these word positions will be in random order. Along with asking you to enter the words of the Seed at a particular position, the Skywallet may ask you to enter random words which are not part of the Seed. Info Both the random words and the random sequence are a security measure to ensure that a potential attacker who might have access to your computer does get neither the full Seed nor the right sequence. Once this process is complete, the Desktop Wallet will confirm whether the Seed you have entered is the correct Seed for the connected Skywallet.","title":"Testing Your Seed"},{"location":"hardware/skywallet/manual-6-restoring-backup/","text":"Restoring Backup with an Existing Seed If you have bought a brand new Skywallet and wish to restore the backup of another Skywallet, then you can utilize the \"Restore Backup\" option during the initialization of your Skywallet. To restore your coins, you only need the Seed of the other Skywallet. Info A Seed is a combination of 12 or 24 words which serves as the key to access your Skywallet. Note You can use the Seed of a Skywallet on another Skywallet, but it is not recommended to use the same Seed for a Desktop Wallet, as this could comprise the security of your Skywallet. To begin the restoration process follow these steps: Step 1 Connect the new Skywallet to your computer. Step 2 Once the Skywallet is connected, you will see a welcome message on its display, which also denotes the genuineness of your Skywallet. Info If you want to know more how to check the genuineness of your Skywallet go to Checking the Genuineness of your Skywallet Step 3 After connecting the Skywallet to your computer, you can proceed to open your Desktop Wallet. If you do not have the latest version of the Desktop Wallet, then please download the same from the Downloads page. If it is your first-time use of the Desktop Wallet, then the following window will be displayed: Proceed to click on the Using a hardware wallet? button. If it is not your first-time use of the Desktop Wallet, then all the Wallets configured using your Desktop Wallet will appear in a list. In this case, proceed to click on the Hardware Wallet button, at the bottom. Step 4 Once you have clicked either \"Using a hardware wallet?\" button or \"Hardware Wallet\" button, the following window will be displayed by your Desktop Wallet. Proceed to click on the Restore backup button. Upon clicking \"Restore backup\" button, the Skywallet will start asking you to enter each words of your Seed by their position. Info The sequence of these positions will be random, i.e., the first word asked to be entered might be the word at position #6, but the next word might be the word at position #11 and so on. Info The Skywallet might also ask you to enter random words that are not part of your Seed as well. Info The random sequence of words and the random words are a security precaution and because of this security measures it can be ensured that a potential hacker/malware, who has access to your computer does get neither the full Seed nor right sequence of the Seed. If you have successfully entered both the random words and the words in your Seed according to their position, the Desktop Wallet will display a confirmation window that your new Skywallet was added to the Wallet list. You can also rename your Skywallet using this window. However, if you fail to enter either the random words correctly, or incorrectly enter the words of your Seed, the process will fail, and you will have to restart the procedure from the beginning.","title":"Restoring backup"},{"location":"hardware/skywallet/manual-6-restoring-backup/#restoring-backup-with-an-existing-seed","text":"If you have bought a brand new Skywallet and wish to restore the backup of another Skywallet, then you can utilize the \"Restore Backup\" option during the initialization of your Skywallet. To restore your coins, you only need the Seed of the other Skywallet. Info A Seed is a combination of 12 or 24 words which serves as the key to access your Skywallet. Note You can use the Seed of a Skywallet on another Skywallet, but it is not recommended to use the same Seed for a Desktop Wallet, as this could comprise the security of your Skywallet. To begin the restoration process follow these steps: Step 1 Connect the new Skywallet to your computer. Step 2 Once the Skywallet is connected, you will see a welcome message on its display, which also denotes the genuineness of your Skywallet. Info If you want to know more how to check the genuineness of your Skywallet go to Checking the Genuineness of your Skywallet Step 3 After connecting the Skywallet to your computer, you can proceed to open your Desktop Wallet. If you do not have the latest version of the Desktop Wallet, then please download the same from the Downloads page. If it is your first-time use of the Desktop Wallet, then the following window will be displayed: Proceed to click on the Using a hardware wallet? button. If it is not your first-time use of the Desktop Wallet, then all the Wallets configured using your Desktop Wallet will appear in a list. In this case, proceed to click on the Hardware Wallet button, at the bottom. Step 4 Once you have clicked either \"Using a hardware wallet?\" button or \"Hardware Wallet\" button, the following window will be displayed by your Desktop Wallet. Proceed to click on the Restore backup button. Upon clicking \"Restore backup\" button, the Skywallet will start asking you to enter each words of your Seed by their position. Info The sequence of these positions will be random, i.e., the first word asked to be entered might be the word at position #6, but the next word might be the word at position #11 and so on. Info The Skywallet might also ask you to enter random words that are not part of your Seed as well. Info The random sequence of words and the random words are a security precaution and because of this security measures it can be ensured that a potential hacker/malware, who has access to your computer does get neither the full Seed nor right sequence of the Seed. If you have successfully entered both the random words and the words in your Seed according to their position, the Desktop Wallet will display a confirmation window that your new Skywallet was added to the Wallet list. You can also rename your Skywallet using this window. However, if you fail to enter either the random words correctly, or incorrectly enter the words of your Seed, the process will fail, and you will have to restart the procedure from the beginning.","title":"Restoring Backup with an Existing Seed"},{"location":"hardware/skywallet/manual-7-optimizing-the-security/","text":"Optimizing the Security of your Skywallet Even though a Skywallet provides greater security when compared to a Desktop Wallet, it is essential to follow these security optimizations to get maximum security benefit from your Skywallet. One of two things is necessary for a third party to access your Skywallet, which is either your Skywallet along with your PIN code of the Skywallet or the Seed of your Skywallet. So when it comes to security optimizations, these are the two vital components to be considered. PIN Code Your PIN code is a four-digit combination, and a brand new Skywallet which you receive via shipment will not have a PIN code. Hence, it is essential first to set a PIN code right after you receive your Skywallet. If you want to know more about how to set the PIN code and personalize your Skywallet, please visit the user manual Personalization of your Skywallet . Although the PIN code is only a combination of four digits, it is improbable for an attacker to guess a secure PIN. Because after each failed attempt, one has to wait for a specific time before attempting the next combination and with each failed attempt the waiting time increases exponentially thus making it highly unlikely for an attacker/hacker to obtain access to your Skywallet. However, such a security precaution is ineffective if you create an insecure PIN. Examples of an insecure PIN include, but are not limited to, important dates, or sequences (like 1234) or repeating digits(1111). Hence a secure PIN code is something easy to remember and at the same time not easy to guess for a third party. Seed A Seed of the Skywallet is even more critical than a PIN code, as a hacker/malware without access to your Skywallet physically, can remotely access or steal your fund just using the Seed. As the Seed is not created by you and is generated on the device, you need not worry about the strength of the Seed as such. However, it is imperative to keep the backup of the Seed in a safe and accessible place, as it is the only way to access your funds if anything happens to your Skywallet. Following are some recommendations to backup and store your Seed safely: Do not Store the Seed in an electronic device. Because saving a Seed in an electronic device effectively nullifies the security it ensures, as the electronic device can potentially be hacked by an attacker, thereby giving access to your Seed. Hence it is recommended to store the Seed in a paper or a notebook which can then be stored in a safe place that is inaccessible to any unauthorized person at the same time not prone to any accidents. The only instance when the Seed is entered into a computer is when you are restoring the backup of your Skywallet , in that case, the Skywallet and Desktop Wallet process the Seed in a secure way which ensures that a third party will not gain access to your Seed. The process is explained in detail in the section Restore Backup . Create multiple copies of the Seed and store it in separate locations. Make sure to inform of at least one location of the Seed to your immediate family member(s) as a precaution in case of an emergency. You can also go for splitting up the Seed in parts to store it in different locations or to have a cipher code for the words in the Seed. However, both these methods have a risk factor and are not recommended approaches unless you are ready to take the risk.","title":"Optimizing the security"},{"location":"hardware/skywallet/manual-7-optimizing-the-security/#optimizing-the-security-of-your-skywallet","text":"Even though a Skywallet provides greater security when compared to a Desktop Wallet, it is essential to follow these security optimizations to get maximum security benefit from your Skywallet. One of two things is necessary for a third party to access your Skywallet, which is either your Skywallet along with your PIN code of the Skywallet or the Seed of your Skywallet. So when it comes to security optimizations, these are the two vital components to be considered.","title":"Optimizing the Security of your Skywallet"},{"location":"hardware/skywallet/manual-7-optimizing-the-security/#pin-code","text":"Your PIN code is a four-digit combination, and a brand new Skywallet which you receive via shipment will not have a PIN code. Hence, it is essential first to set a PIN code right after you receive your Skywallet. If you want to know more about how to set the PIN code and personalize your Skywallet, please visit the user manual Personalization of your Skywallet . Although the PIN code is only a combination of four digits, it is improbable for an attacker to guess a secure PIN. Because after each failed attempt, one has to wait for a specific time before attempting the next combination and with each failed attempt the waiting time increases exponentially thus making it highly unlikely for an attacker/hacker to obtain access to your Skywallet. However, such a security precaution is ineffective if you create an insecure PIN. Examples of an insecure PIN include, but are not limited to, important dates, or sequences (like 1234) or repeating digits(1111). Hence a secure PIN code is something easy to remember and at the same time not easy to guess for a third party.","title":"PIN Code"},{"location":"hardware/skywallet/manual-7-optimizing-the-security/#seed","text":"A Seed of the Skywallet is even more critical than a PIN code, as a hacker/malware without access to your Skywallet physically, can remotely access or steal your fund just using the Seed. As the Seed is not created by you and is generated on the device, you need not worry about the strength of the Seed as such. However, it is imperative to keep the backup of the Seed in a safe and accessible place, as it is the only way to access your funds if anything happens to your Skywallet. Following are some recommendations to backup and store your Seed safely: Do not Store the Seed in an electronic device. Because saving a Seed in an electronic device effectively nullifies the security it ensures, as the electronic device can potentially be hacked by an attacker, thereby giving access to your Seed. Hence it is recommended to store the Seed in a paper or a notebook which can then be stored in a safe place that is inaccessible to any unauthorized person at the same time not prone to any accidents. The only instance when the Seed is entered into a computer is when you are restoring the backup of your Skywallet , in that case, the Skywallet and Desktop Wallet process the Seed in a secure way which ensures that a third party will not gain access to your Seed. The process is explained in detail in the section Restore Backup . Create multiple copies of the Seed and store it in separate locations. Make sure to inform of at least one location of the Seed to your immediate family member(s) as a precaution in case of an emergency. You can also go for splitting up the Seed in parts to store it in different locations or to have a cipher code for the words in the Seed. However, both these methods have a risk factor and are not recommended approaches unless you are ready to take the risk.","title":"Seed"},{"location":"hardware/skywallet/manual-8-sending-and-receiving-coins/","text":"Sending and Receiving Coins using your Skywallet Info To send or receive coins using your Skywallet, you have to initialize and personalize your Skywallet first. Details on how to initialize and personalize your Skywallet can be found in the following chapters: Initialization of your Skywallet Personalization of your Skywallet Once you have completed the initialization and personalization of your Skywallet, you can see your Skywallet in the list of Wallets configured using your Desktop Wallet. Receive Coins To receive coins to your Skywallet, you need the address of your Skywallet. To get the address of the Skywallet, follow these steps : Step 1 Connect your Skywallet to your computer via USB. Step 2 Open the Desktop Wallet from your computer. Step 3 The window will display the list of all the Wallets configured using your Desktop Wallet. From this list, you can click on your Skywallet name to get the address of your Skywallet. However, only the partial address will be visible for you. Step 4 Click on the Press to Show button. Once you have clicked on the \"Press to Show\" button, the address of the Skywallet will be displayed both by the Desktop Wallet as well as your Skywallet. Warning Please check whether both these addresses are the same. If they are not the same, then cancel the operation and stop using the Skywallet. Immediately contact Support by visiting this link - store.skycoin.com/pages/support . Alternatively, you can also send an email detailing the issue to support@skycoin.com . It is imperative you do this as showing different addresses means your SkyWallet might have been compromised and using the same would lead you to the loss of your coins. Step 5 After confirming both the addresses are the same. You can use this address to receive coins to your Skywallet. Once the transaction is confirmed in the blockchain, your coins will appear in the balance. Info Unlike the Desktop Wallet, which supports multiple addresses, the Skywallet only supports one address. Sending Coins Simple Send To send coins from your Skywallet using the Simple Send option, you only need the complete address of the receiving Wallet. Step 1 Connect your Skywallet to your computer via the USB. Step 2 Open the Desktop Wallet from your computer. Step 3 Click on the Send tab. Note When you click on the Send tab, by default, the Simple Send option is selected. Step 4 Click on the drop-down arrow in the first box - Send from , to select your Skywallet from the list. Step 5 Enter the full address of the receiving Wallet in the second box - Send to . Warning Thoroughly verify the address of the receiving Wallet, as entering a wrong address could result in loss of your coins. Step 6 Enter the amount of Skycoins you want to send in the third box - Amount . Step 7 Click on the Preview button to get a preview of your transaction, you can once again verify all the data entered. Step 8 After verifying the entered data, click on the Send button to proceed with your transaction. Step 9 Once you click on the \"Send\" button, a confirmation message will be displayed on your Skywallet. Warning Please make sure that the receiving Wallet address entered by you and the one displayed by the Skywallet in the confirmation message is the same. If it is not the same, abort the whole process and stop using the Skywallet and immediately contact Support by visiting this link - store.skycoin.com/pages/support . Alternatively, you can also send an email detailing the issue to support@skycoin.com . It is imperative you do this as showing different addresses means your SkyWallet might have been compromised and using the same would lead you to the loss of your coins. Step 10 After you verify both the address you have entered in the Desktop Wallet and the one displayed by the Skywallet in its confirmation message is the same, you can confirm the operation on your Skywallet to send the coins. Advanced Send As the name suggests, \"Advanced Send\" option is to be used in case if you need to access advanced settings when Sending Skycoins. Sending coins using the Simple Send option is relatively easy as you only need to enter the correct address for the receiving Wallet and the exact amount of Skycoins. However, if you need to customize your transaction using advanced options, then you can go for the \"Advanced Send\" option. Follow the steps below to send coins using the \"Advanced Send\" option. === \"Step 1** Connect your Skywallet to your computer via the USB. === \"Step 2** Open the Desktop Wallet from your computer. === \"Step 3 Click on the Send** tab. === \"Step 4 When you click on the Send tab, by default, the Simple Send option is selected, to select Advanced Send option click on the Advanced Send** button next to the \"Simple Send\" button. ![Advanced Send tab](img/manual/Sending%20and%20Receiving%20-%205.PNG?raw=true) === \"Step 5 Click on the drop-down arrow in the first box - Select Wallet**, to select your Skywallet from the list. === \"Step 6 Enter the full address of the receiving Wallet in the second box named Destinations**. !! note You can add multiple addresses when using the Advanced Send option, to add additional address click on the green plus symbol to the extreme right of your screen. === \"Step 7** Once you entered the receiving Wallet addresses, you can enter the number of coins you want to send to each of these addresses. !!! note You can toggle between entering the number of Skycoins you want to Send or the equivalent amount of United States Dollars. The Toggle button is available on top of the Destinations box. === \"Step 8 Next option is the Coin Hours, by default, the Coin Hours for each transaction will be automatically allocated. However, you can change this by unchecking the box Automatic coin hours allocation** at the bottom of your screen. === \"Step 9** Once you have unchecked the \"Automatic coin hours allocation\" box, an additional box will appear next to the box where you enter the number of coins. === \"Step 10** After entering all the destination Wallet addresses, the number of coins and the coin hours, please verify all the data entered is correct. !!! warning Thoroughly verify the addresses of the receiving Wallets, as entering wrong addresses could result in loss of your coins. === \"Step 11** After verifying the entered data, you can proceed to enter the change address. If you wish to use a Wallet from the Wallet list for the change address, you can click on the \"Select\" drop-down. === \"Step 12** In the final box named \"Personal Notes\", you can add a message which will appear as a remark once the transaction is completed and it appears in the transaction history. === \"Step 13 Once all these data are entered or selected, you can reverify this by clicking on the Preview** button, which shows a preview of your transaction with all the details. ![Preview Transaction](img/manual/Sending%20and%20Receiving%20-%206.PNG?raw=true) === \"Step 14** After reviewing and verifying all the data, you can click on the \"Send\" button. Once you click on the \"Send\" button, a confirmation message will be displayed on your Skywallet. ![Skywallet_Send_Cnfrm](img/manual/Skywallet%20Screen%20Mockup%20Edit_Skywallet%20Black_11-2.png?raw=true) ![Skywallet_Send_Cnfrm](img/manual/Skywallet%20Screen%20Mockup%20Edit_Skywallet%20Black_11-1.png?raw=true) !!! note Please make sure that the receiving Wallet addresses entered by you and those displayed by the Skywallet in the confirmation message are the same. If they are not the same, abort the whole process and stop using the Skywallet and immediately contact Support by visiting this link - [store.skycoin.com/pages/support](store.skycoin.com/pages/support). Alternatively, you can also send an email detailing the issue to support@skycoin.com. It is imperative you do this as showing different addresses means your SkyWallet might have been compromised and using the same would lead you to the loss of your coins.","title":"Sending and Receiving coins"},{"location":"hardware/skywallet/manual-8-sending-and-receiving-coins/#sending-and-receiving-coins-using-your-skywallet","text":"Info To send or receive coins using your Skywallet, you have to initialize and personalize your Skywallet first. Details on how to initialize and personalize your Skywallet can be found in the following chapters: Initialization of your Skywallet Personalization of your Skywallet Once you have completed the initialization and personalization of your Skywallet, you can see your Skywallet in the list of Wallets configured using your Desktop Wallet. Receive Coins To receive coins to your Skywallet, you need the address of your Skywallet. To get the address of the Skywallet, follow these steps : Step 1 Connect your Skywallet to your computer via USB. Step 2 Open the Desktop Wallet from your computer. Step 3 The window will display the list of all the Wallets configured using your Desktop Wallet. From this list, you can click on your Skywallet name to get the address of your Skywallet. However, only the partial address will be visible for you. Step 4 Click on the Press to Show button. Once you have clicked on the \"Press to Show\" button, the address of the Skywallet will be displayed both by the Desktop Wallet as well as your Skywallet. Warning Please check whether both these addresses are the same. If they are not the same, then cancel the operation and stop using the Skywallet. Immediately contact Support by visiting this link - store.skycoin.com/pages/support . Alternatively, you can also send an email detailing the issue to support@skycoin.com . It is imperative you do this as showing different addresses means your SkyWallet might have been compromised and using the same would lead you to the loss of your coins. Step 5 After confirming both the addresses are the same. You can use this address to receive coins to your Skywallet. Once the transaction is confirmed in the blockchain, your coins will appear in the balance. Info Unlike the Desktop Wallet, which supports multiple addresses, the Skywallet only supports one address. Sending Coins Simple Send To send coins from your Skywallet using the Simple Send option, you only need the complete address of the receiving Wallet. Step 1 Connect your Skywallet to your computer via the USB. Step 2 Open the Desktop Wallet from your computer. Step 3 Click on the Send tab. Note When you click on the Send tab, by default, the Simple Send option is selected. Step 4 Click on the drop-down arrow in the first box - Send from , to select your Skywallet from the list. Step 5 Enter the full address of the receiving Wallet in the second box - Send to . Warning Thoroughly verify the address of the receiving Wallet, as entering a wrong address could result in loss of your coins. Step 6 Enter the amount of Skycoins you want to send in the third box - Amount . Step 7 Click on the Preview button to get a preview of your transaction, you can once again verify all the data entered. Step 8 After verifying the entered data, click on the Send button to proceed with your transaction. Step 9 Once you click on the \"Send\" button, a confirmation message will be displayed on your Skywallet. Warning Please make sure that the receiving Wallet address entered by you and the one displayed by the Skywallet in the confirmation message is the same. If it is not the same, abort the whole process and stop using the Skywallet and immediately contact Support by visiting this link - store.skycoin.com/pages/support . Alternatively, you can also send an email detailing the issue to support@skycoin.com . It is imperative you do this as showing different addresses means your SkyWallet might have been compromised and using the same would lead you to the loss of your coins. Step 10 After you verify both the address you have entered in the Desktop Wallet and the one displayed by the Skywallet in its confirmation message is the same, you can confirm the operation on your Skywallet to send the coins. Advanced Send As the name suggests, \"Advanced Send\" option is to be used in case if you need to access advanced settings when Sending Skycoins. Sending coins using the Simple Send option is relatively easy as you only need to enter the correct address for the receiving Wallet and the exact amount of Skycoins. However, if you need to customize your transaction using advanced options, then you can go for the \"Advanced Send\" option. Follow the steps below to send coins using the \"Advanced Send\" option. === \"Step 1** Connect your Skywallet to your computer via the USB. === \"Step 2** Open the Desktop Wallet from your computer. === \"Step 3 Click on the Send** tab. === \"Step 4 When you click on the Send tab, by default, the Simple Send option is selected, to select Advanced Send option click on the Advanced Send** button next to the \"Simple Send\" button. ![Advanced Send tab](img/manual/Sending%20and%20Receiving%20-%205.PNG?raw=true) === \"Step 5 Click on the drop-down arrow in the first box - Select Wallet**, to select your Skywallet from the list. === \"Step 6 Enter the full address of the receiving Wallet in the second box named Destinations**. !! note You can add multiple addresses when using the Advanced Send option, to add additional address click on the green plus symbol to the extreme right of your screen. === \"Step 7** Once you entered the receiving Wallet addresses, you can enter the number of coins you want to send to each of these addresses. !!! note You can toggle between entering the number of Skycoins you want to Send or the equivalent amount of United States Dollars. The Toggle button is available on top of the Destinations box. === \"Step 8 Next option is the Coin Hours, by default, the Coin Hours for each transaction will be automatically allocated. However, you can change this by unchecking the box Automatic coin hours allocation** at the bottom of your screen. === \"Step 9** Once you have unchecked the \"Automatic coin hours allocation\" box, an additional box will appear next to the box where you enter the number of coins. === \"Step 10** After entering all the destination Wallet addresses, the number of coins and the coin hours, please verify all the data entered is correct. !!! warning Thoroughly verify the addresses of the receiving Wallets, as entering wrong addresses could result in loss of your coins. === \"Step 11** After verifying the entered data, you can proceed to enter the change address. If you wish to use a Wallet from the Wallet list for the change address, you can click on the \"Select\" drop-down. === \"Step 12** In the final box named \"Personal Notes\", you can add a message which will appear as a remark once the transaction is completed and it appears in the transaction history. === \"Step 13 Once all these data are entered or selected, you can reverify this by clicking on the Preview** button, which shows a preview of your transaction with all the details. ![Preview Transaction](img/manual/Sending%20and%20Receiving%20-%206.PNG?raw=true) === \"Step 14** After reviewing and verifying all the data, you can click on the \"Send\" button. Once you click on the \"Send\" button, a confirmation message will be displayed on your Skywallet. ![Skywallet_Send_Cnfrm](img/manual/Skywallet%20Screen%20Mockup%20Edit_Skywallet%20Black_11-2.png?raw=true) ![Skywallet_Send_Cnfrm](img/manual/Skywallet%20Screen%20Mockup%20Edit_Skywallet%20Black_11-1.png?raw=true) !!! note Please make sure that the receiving Wallet addresses entered by you and those displayed by the Skywallet in the confirmation message are the same. If they are not the same, abort the whole process and stop using the Skywallet and immediately contact Support by visiting this link - [store.skycoin.com/pages/support](store.skycoin.com/pages/support). Alternatively, you can also send an email detailing the issue to support@skycoin.com. It is imperative you do this as showing different addresses means your SkyWallet might have been compromised and using the same would lead you to the loss of your coins.","title":"Sending and Receiving Coins using your Skywallet"},{"location":"hardware/skywallet/manual-9-miscellaneous-operations/","text":"Miscellaneous Operations on Your Skywallet The basic initialization and personalization operations are mentioned in the chapters: Initialization of your Skywallet Personalization of your Skywallet However, you can also perform some additional operations on your Skywallet like: Renaming your Skywallet. Removing your Skywallet from the Wallet list. Checking the firmware version of your Skywallet. Renaming Your Skywallet Step 1 - Connect your Skywallet to your computer via USB. Step 2 - Open your Desktop Wallet from your computer. Step 3 - A window will show the list of all the Wallets configured using your Desktop Wallet. Step 4 - Select the particular Skywallet which you wish to rename. Step 5 - Click on the Edit Wallet button. Step 6 - Once you click on the \"Edit Wallet\" button a window to edit the name of your Skywallet will appear. Step 7 - Enter a name for your Skywallet and click on the Rename button to confirm. You can check your Skywallet in the Wallet list to see the changed name. Removing a Skywallet from the Wallet List Step 1 - Open your Desktop Wallet from your computer. Step 2 - Select the Skywallet you want to remove from the Wallet list. Step 3 - Click on the Delete Wallet button from the window. Step 4 - Confirm the operation by ticking the box Yeah, I want to delete the Wallet and clicking on the Yes button. NOTE 1 - To remove a Skywallet from the Wallet list you don't need to connect it to your computer necessarily. NOTE 2 - This whole operation only removes the Skywallet from the Wallet list and does not wipe the device . To know more about how to wipe your Skywallet to remove any personalizations, visit the following chapter - Personalization of your Skywallet . Also if you want to add the device back to the Wallet list, you can follow the same steps in the chapter - Initialization of your Skywallet . Checking the Firmware Version of Your Skywallet The firmware is essential for your Skywallet to work properly. You can check the following chapter to know more about firmware and how to update it periodically - Update Firmware . To check the current firmware version of your Skywallet, you can follow these steps: Step 1 - Connect your Skywallet to your computer via USB. Step 2 - Open the Desktop Wallet from your computer. Step 3 - A window will show you the list of all the Wallets configured using your Desktop Wallet. Step 4 - Select your Skywallet from the Wallet list. Step 5 - You can check for the firmware version in the following window, which appears when you select the Skywallet from the Wallet list.","title":"Miscellaneous operations"},{"location":"hardware/skywallet/manual-9-miscellaneous-operations/#miscellaneous-operations-on-your-skywallet","text":"The basic initialization and personalization operations are mentioned in the chapters: Initialization of your Skywallet Personalization of your Skywallet However, you can also perform some additional operations on your Skywallet like: Renaming your Skywallet. Removing your Skywallet from the Wallet list. Checking the firmware version of your Skywallet.","title":"Miscellaneous Operations on Your Skywallet"},{"location":"hardware/skywallet/manual-9-miscellaneous-operations/#renaming-your-skywallet","text":"Step 1 - Connect your Skywallet to your computer via USB. Step 2 - Open your Desktop Wallet from your computer. Step 3 - A window will show the list of all the Wallets configured using your Desktop Wallet. Step 4 - Select the particular Skywallet which you wish to rename. Step 5 - Click on the Edit Wallet button. Step 6 - Once you click on the \"Edit Wallet\" button a window to edit the name of your Skywallet will appear. Step 7 - Enter a name for your Skywallet and click on the Rename button to confirm. You can check your Skywallet in the Wallet list to see the changed name.","title":"Renaming Your Skywallet"},{"location":"hardware/skywallet/manual-9-miscellaneous-operations/#removing-a-skywallet-from-the-wallet-list","text":"Step 1 - Open your Desktop Wallet from your computer. Step 2 - Select the Skywallet you want to remove from the Wallet list. Step 3 - Click on the Delete Wallet button from the window. Step 4 - Confirm the operation by ticking the box Yeah, I want to delete the Wallet and clicking on the Yes button. NOTE 1 - To remove a Skywallet from the Wallet list you don't need to connect it to your computer necessarily. NOTE 2 - This whole operation only removes the Skywallet from the Wallet list and does not wipe the device . To know more about how to wipe your Skywallet to remove any personalizations, visit the following chapter - Personalization of your Skywallet . Also if you want to add the device back to the Wallet list, you can follow the same steps in the chapter - Initialization of your Skywallet .","title":"Removing a Skywallet from the Wallet List"},{"location":"hardware/skywallet/manual-9-miscellaneous-operations/#checking-the-firmware-version-of-your-skywallet","text":"The firmware is essential for your Skywallet to work properly. You can check the following chapter to know more about firmware and how to update it periodically - Update Firmware . To check the current firmware version of your Skywallet, you can follow these steps: Step 1 - Connect your Skywallet to your computer via USB. Step 2 - Open the Desktop Wallet from your computer. Step 3 - A window will show you the list of all the Wallets configured using your Desktop Wallet. Step 4 - Select your Skywallet from the Wallet list. Step 5 - You can check for the firmware version in the following window, which appears when you select the Skywallet from the Wallet list.","title":"Checking the Firmware Version of Your Skywallet"},{"location":"hardware/skywalletdk/","text":"Skywallet DK Manual TODO Support Telegram Support Page Email Support Store store.skycoin.com","title":"Skywallet DK"},{"location":"hardware/skywalletdk/#skywallet-dk","text":"","title":"Skywallet DK"},{"location":"hardware/skywalletdk/#manual","text":"TODO","title":"Manual"},{"location":"hardware/skywalletdk/#support","text":"Telegram Support Page Email Support","title":"Support"},{"location":"hardware/skywalletdk/#store","text":"store.skycoin.com","title":"Store"},{"location":"skyfleet/captain-sky-comics/","text":"Captain SKY - Comics Here you can find a collection of all the Captain SKY - Comics. Isidore M'Buma aka Buma aka Yo started these and hopefully will continue. Check out his Twitter #1 Captain SKY #2 The Skywallet #3 Captain SKY vs. Captain BIT #4 The Skywire Network #5 Coin Hours #6 Skywire vs. ISPs #7 Doomsday #8 Doctor Ether #9 Doctor Ether is back! #10 The birth of Captain SKY #11 The Evil BodgaBrothers","title":"Captain Sky"},{"location":"skyfleet/captain-sky-comics/#captain-sky-comics","text":"Here you can find a collection of all the Captain SKY - Comics. Isidore M'Buma aka Buma aka Yo started these and hopefully will continue. Check out his Twitter","title":"Captain SKY - Comics"},{"location":"skyfleet/captain-sky-comics/#1-captain-sky","text":"","title":"#1 Captain SKY"},{"location":"skyfleet/captain-sky-comics/#2-the-skywallet","text":"","title":"#2 The Skywallet"},{"location":"skyfleet/captain-sky-comics/#3-captain-sky-vs-captain-bit","text":"","title":"#3 Captain SKY vs. Captain BIT"},{"location":"skyfleet/captain-sky-comics/#4-the-skywire-network","text":"","title":"#4 The Skywire Network"},{"location":"skyfleet/captain-sky-comics/#5-coin-hours","text":"","title":"#5 Coin Hours"},{"location":"skyfleet/captain-sky-comics/#6-skywire-vs-isps","text":"","title":"#6 Skywire vs. ISPs"},{"location":"skyfleet/captain-sky-comics/#7-doomsday","text":"","title":"#7 Doomsday"},{"location":"skyfleet/captain-sky-comics/#8-doctor-ether","text":"","title":"#8 Doctor Ether"},{"location":"skyfleet/captain-sky-comics/#9-doctor-ether-is-back","text":"","title":"#9 Doctor Ether is back!"},{"location":"skyfleet/captain-sky-comics/#10-the-birth-of-captain-sky","text":"","title":"#10 The birth of Captain SKY"},{"location":"skyfleet/captain-sky-comics/#11-the-evil-bodgabrothers","text":"","title":"#11 The Evil BodgaBrothers"},{"location":"skyfleet/overview/","text":"Skyfleet Skyfleet is the term for all community members contributing to the ecosystem of skycoin. Here is an overview about all things that have been made by them: Art Captain SKY - Comics Companies developing on Skycoin Skywire Launch ISP","title":"Overview"},{"location":"skyfleet/overview/#skyfleet","text":"Skyfleet is the term for all community members contributing to the ecosystem of skycoin. Here is an overview about all things that have been made by them:","title":"Skyfleet"},{"location":"skyfleet/overview/#art","text":"Captain SKY - Comics","title":"Art"},{"location":"skyfleet/overview/#companies-developing-on-skycoin","text":"","title":"Companies developing on Skycoin"},{"location":"skyfleet/overview/#skywire","text":"Launch ISP","title":"Skywire"},{"location":"software/","text":"Software Overview Skycoin Fiber Skywire CX CXO CXFX","title":"Overview"},{"location":"software/#software-overview","text":"Skycoin Fiber Skywire CX CXO CXFX","title":"Software Overview"},{"location":"software/cx/","text":"CX CX is Skycoin's original programming language. CX is a general purpose programming language that focuses on the design of distributed, blockchain-based applications. CX provides developers with high-level meta-programming features, such as affordances , runtime stepping and a REPL capable of modifying running programs at a low granularity level. CX is: deterministic integrates with blockchains works with immutable data structures incorporates our new paradigm of affordances is compiled and interpreted uses garbage collection has a strict typing system has other valuable tools built in CX has multiple powerful libraries including CXO for immutable objects sharing, CXFX for its graphics engine, and more being developed. CX is written with Go's syntax to ensure professionals can quickly switch over and newcomers can easily learn it. CX will eventually be written entirely in CX. Here you find a collection of all the knowledge you need to start with CX. If you have further questions, you are always welcomed on Telegram and Reddit . Roadmap for the Development of CX Getting Started Windows macOS Linux Basics & Documentation Basics Syntax Runtime Native Functions Running CX REPL Documentation CX Documentation & Book Native Packages Package Purpose more Info time time measuring & code pausing os operating system gl graphics opengl.org glfw windows handling glfw.org gltext font rendering github.com/go-gl/gltext Libraries Library Purpose Website Telegram Github More CXFX 3D Graphics/Gaming Engine Telegram Github Twitter CXChains Blockchain Apps PumpCX User Interface Github Compatible Products Products Purpose Website Telegram Github More CXO Immutable Objects System dmsg Distributed messaging system Programming Tools TODO: Tutorials Intro to Skycoin's CX for complete beginners: 1 [VOD] A closer look at \"Hello, world!\" in CX Open-Source-Projects Apps Name Description ... CxStratus Twitter Clone Unknown 4chan Clone source: Youtube Unknown Telegram clone source: Youtube Unknown Trello clone source: Youtube Games Name Description ... Slot-Machine CrappyBall Flappy-Bird Clone Pac Man CX Pacman 2D Clone Pacman 3D Pacman 3D Clone Snake by Lunier Snake Clone SynthCat Brick Breaker Whacky Stack Tetris Clone Ridge Blaster Dig-N-Rig Clone Space Invaders Space Invaders Clone using CX-Chains CX Asteroids Asteroids Clone Documentation in wiki Skylight Goldeneye Clone uses CXFX Social Networks Here are all available groups for the cx programming language Telegram CX:Blockchain Programming Language CX-Labs Code Bootcamp Reddit CX_Language","title":"Introduction"},{"location":"software/cx/#cx","text":"CX is Skycoin's original programming language. CX is a general purpose programming language that focuses on the design of distributed, blockchain-based applications. CX provides developers with high-level meta-programming features, such as affordances , runtime stepping and a REPL capable of modifying running programs at a low granularity level. CX is: deterministic integrates with blockchains works with immutable data structures incorporates our new paradigm of affordances is compiled and interpreted uses garbage collection has a strict typing system has other valuable tools built in CX has multiple powerful libraries including CXO for immutable objects sharing, CXFX for its graphics engine, and more being developed. CX is written with Go's syntax to ensure professionals can quickly switch over and newcomers can easily learn it. CX will eventually be written entirely in CX. Here you find a collection of all the knowledge you need to start with CX. If you have further questions, you are always welcomed on Telegram and Reddit . Roadmap for the Development of CX","title":"CX"},{"location":"software/cx/#getting-started","text":"Windows macOS Linux","title":"Getting Started"},{"location":"software/cx/#basics-documentation","text":"Basics Syntax Runtime Native Functions Running CX REPL Documentation CX Documentation & Book","title":"Basics &amp; Documentation"},{"location":"software/cx/#native-packages","text":"Package Purpose more Info time time measuring & code pausing os operating system gl graphics opengl.org glfw windows handling glfw.org gltext font rendering github.com/go-gl/gltext","title":"Native Packages"},{"location":"software/cx/#libraries","text":"Library Purpose Website Telegram Github More CXFX 3D Graphics/Gaming Engine Telegram Github Twitter CXChains Blockchain Apps PumpCX User Interface Github","title":"Libraries"},{"location":"software/cx/#compatible-products","text":"Products Purpose Website Telegram Github More CXO Immutable Objects System dmsg Distributed messaging system","title":"Compatible Products"},{"location":"software/cx/#programming-tools","text":"TODO:","title":"Programming Tools"},{"location":"software/cx/#tutorials","text":"Intro to Skycoin's CX for complete beginners: 1 [VOD] A closer look at \"Hello, world!\" in CX","title":"Tutorials"},{"location":"software/cx/#open-source-projects","text":"","title":"Open-Source-Projects"},{"location":"software/cx/#apps","text":"Name Description ... CxStratus Twitter Clone Unknown 4chan Clone source: Youtube Unknown Telegram clone source: Youtube Unknown Trello clone source: Youtube","title":"Apps"},{"location":"software/cx/#games","text":"Name Description ... Slot-Machine CrappyBall Flappy-Bird Clone Pac Man CX Pacman 2D Clone Pacman 3D Pacman 3D Clone Snake by Lunier Snake Clone SynthCat Brick Breaker Whacky Stack Tetris Clone Ridge Blaster Dig-N-Rig Clone Space Invaders Space Invaders Clone using CX-Chains CX Asteroids Asteroids Clone Documentation in wiki Skylight Goldeneye Clone uses CXFX","title":"Games"},{"location":"software/cx/#social-networks","text":"Here are all available groups for the cx programming language","title":"Social Networks"},{"location":"software/cx/#telegram","text":"CX:Blockchain Programming Language CX-Labs Code Bootcamp","title":"Telegram"},{"location":"software/cx/#reddit","text":"CX_Language","title":"Reddit"},{"location":"software/cx/basics-native-functions/","text":"Native Functions Type-inferenced Functions CX has a small set of functions that are not associated to a single type signature. For example, instead of using i32.add to add two 32-bit integers, you can use the generalized add function. Furthermore, whenever you use arithmetic operators, such as + , - or % , these are translated to their corresponding \"type-inferenced\" function, e.g. num = 5 + 5 is translated to num = i32.add(5, 5) . These native functions still follow CX's philosophy of having a strict typing system, as the types of the arguments sent to these native functions must be the same. Note that after listing a group of similar \"type-inferenced\" functions below, we list the compatible types for the corresponding functions. eq uneq Note: the preceding functions only work with arguments of type bool , byte , str , i32 , i64 , f32 or f64 . Example package main func main () { bool . print ( eq ( 5 , 5 )) bool . print ( 5 == 5 ) // alternative bool . print ( uneq ( \"hihi\" , \"byebye\" )) bool . print ( \"hihi\" != \"byebye\" ) // alternative } lt gt lteq gteq Note: the preceding function only works with arguments of type byte , bool , str , i32 , i64 , f32 or f64 . Example package main func main () { bool . print ( lt ( 3 B , 4 B )) bool . print ( 3 B < 4 B ) // alternative bool . print ( gt ( \"hello\" , \"hi!\" )) bool . print ( \"hello\" > \"hi!\" ) // alternative bool . print ( lteq ( 5.3 D , 5.3 D )) bool . print ( 5.3 D <= 5.3 D ) // alternative bool . print ( gteq ( 10 L , 3 L )) bool . print ( 10 L >= 3 L ) // alternative } bitand bitor bitxor bitclear bitshl bitshr Note: the preceding functions only work with arguments of type i32 or i64 . Example package main func main () { i32 . print ( bitand ( 5 , 1 )) i32 . print ( 5 & 1 ) // alternative i64 . print ( bitor ( 3 L , 2 L )) i64 . print ( 3 L | 2 L ) // alternative i32 . print ( bitxor ( 10 , 2 )) i32 . print ( 10 ^ 2 ) // alternative i64 . print ( bitclear ( 5 L , 2 L )) i64 . print ( 5 L &^ 2 L ) // alternative i32 . print ( bitshl ( 2 , 3 )) i32 . print ( 2 << 3 ) // alternative i32 . print ( bitshr ( 16 , 3 )) i32 . print ( 16 >> 3 ) // alternative } add sub mul div Note: the preceding functions only work with arguments of type byte , i32 , i64 , f32 or f64 . Example package main func main () { byte . print ( add ( 5 B , 10 B )) byte . print ( 5 B + 10 B ) // alternative i32 . print ( sub ( 3 , 7 )) i32 . print ( 3 - 7 ) // alternative i64 . print ( mul ( 4 L , 5 L )) i64 . print ( 4 L * 5 L ) // alternative f32 . print ( div ( 4.3 , 2.1 )) f32 . print ( 4.3 / 2.1 ) // alternative } mod Note: the preceding function only works with arguments of type byte , i32 or i64 . Example package main func main () { byte . print ( mod ( 5 B , 3 B )) byte . print ( 5 B % 3 B ) // alternative } len Note: the preceding function only works with arguments of type str , arrays or slices . Example package main func main () { var string str var array [ 5 ] i32 var slice [] i32 string = \"this should print 20\" array = [ 5 ] i32 { 1 , 2 , 3 , 4 , 5 } slice = [] i32 { 10 , 20 , 30 } i32 . print ( len ( string )) // prints 20 i32 . print ( len ( array )) // prints 5 i32 . print ( len ( slice )) // prints 3 } printf Note: the preceding function requires a format str as its first argument, followed by any number of arguments of type str , i32 , i64 , f32 or f64 . The format string recognizes the following directives: %s for strings, %d for integers and %f for floating point numbers. Example package main func main () { var name str var age i32 var wrongPI f32 var error f64 name = \"Richard\" age = 14 wrongPI = 3.16 error = 0.0000000000000001 D printf ( \"Hello, %s. My name is %s. I see that you calculated the value of PI wrong (%f). I think this is not so bad, considering your young age of %d. When I was %d years old, I remember I miscalculated it, too (I got %f as a result, using a numerical method). If you are using a numerical method, please consider reaching an error lower than %f to get an acceptable result, and not a ridiculous value such as %f. \\n\\nBest regards!\\n\" , name , \"Edward\" , wrongPI , age , 25 , 3.1417 , error , 0.1 ) } sprintf Note: the preceding function requires a format str as its first argument, followed by any number of arguments of type str , i32 , i64 , f32 or f64 . The format string recognizes the following directives: %s for strings, %d for integers and %f for floating point numbers. package main func main () { var reply str var name str var title str name = \"Edward\" title = \"Richard 8 PI\" reply = sprintf ( \"Thank you for contacting our technical support, %s. We see that you are having trouble with our video game titled '%s', targetted to kids under age %d. If you provide us with your parents e-mail address, we'll be glad to help you!\" , name , title , 14 ) str . print ( reply ) } Slice Functions append Example package main func main () { var slc1 [] i32 slc1 = append ( slc1 , 1 ) slc1 = append ( slc1 , 2 ) var slc2 [] i32 slc2 = append ( slc1 , 3 ) slc2 = append ( slc2 , 4 ) i32 . print ( len ( slc1 )) // prints 2 i32 . print ( len ( slc2 )) // prints 4 } Input/Output Functions The following functions are used to handle input from the user and to print output to a terminal. read Example package main func main () { var password str for true { printf ( \"What's the password, kid? \" ) password = read () if password == \"123\" { str . print ( \"Welcome back.\" ) return } else { str . print ( \"Wrong, but you'll get another chance.\" ) } } } byte.print bool.print str.print i32.print i64.print f32.print f64.print printf Example package main func main () { byte . print ( 5 B ) bool . print ( true ) str . print ( \"Hello!\" ) i32 . print ( 5 ) i64 . print ( 5 L ) f32 . print ( 5.0 ) f64 . print ( 5.0 D ) printf ( \"For a better example, check section Type-inferenced Functions'\" ) } Parse Functions All parse functions follow the same pattern: XXX.YYY where XXX is the receiving type and YYY is the target type. You can read these functions as \"parse XXX to YYY\". byte.str byte.i32 byte.i64 byte.f32 byte.f64 Example package main func main () { var b byte b = 30 B str . print ( str . concat ( \"Hello, \" , byte . str ( b ))) i32 . print ( 5 + byte . i32 ( b )) i64 . print ( 10 L + byte . i64 ( b )) f32 . print ( 33.3 + byte . f32 ( b )) f64 . print ( 50.111 D + byte . f64 ( b )) } i32.byte i32.str i32.i64 i32.f32 i32.f64 Example package main func main () { var num i32 num = 43 str . print ( str . concat ( \"Hello, \" , i32 . str ( num ))) byte . print ( 5 B + i32 . byte ( num )) i64 . print ( 10 L + i32 . i64 ( num )) f32 . print ( 33.3 + i32 . f32 ( num )) f64 . print ( 50.111 D + i32 . f64 ( num )) } i64.byte i64.str i64.i32 i64.f32 i64.f64 Example package main func main () { var num i64 num = 43 L str . print ( str . concat ( \"Hello, \" , i64 . str ( num ))) byte . print ( 5 B + i64 . byte ( num )) i64 . print ( 10 L + i64 . i64 ( num )) f32 . print ( 33.3 + i64 . f32 ( num )) f64 . print ( 50.111 D + i64 . f64 ( num )) } f32.byte f32.str f32.i32 f32.i64 f32.f64 Example package main func main () { var num f32 num = 43.33 str . print ( str . concat ( \"Hello, \" , f32 . str ( num ))) byte . print ( 5 B + f32 . byte ( num )) i32 . print ( 33 + f32 . f32 ( num )) i64 . print ( 10 L + f32 . i64 ( num )) f64 . print ( 50.111 D + f32 . f64 ( num )) } f64.byte f64.str f64.i32 f64.i64 f64.f32 Example package main func main () { var num f64 num = 43.33 D str . print ( str . concat ( \"Hello, \" , f64 . str ( num ))) byte . print ( 5 B + f64 . byte ( num )) i32 . print ( 33 + f64 . f32 ( num )) i64 . print ( 10 L + f64 . i64 ( num )) f32 . print ( 50.111 + f64 . f32 ( num )) } str.byte str.i32 str.i64 str.f32 str.f64 Example package main func main () { var num str num = \"33\" byte . print ( 5 B + str . byte ( num )) i32 . print ( 33 + str . f32 ( num )) i64 . print ( 10 L + str . i64 ( num )) f32 . print ( 50.111 + str . f32 ( num )) f64 . print ( 50.111 D + str . f32 ( num )) } Unit Testing The assert function is used to test the value of an expression against another value. This function is useful to test that a package is working as intended. assert Example package main func foo () ( res str ) { res = \"Working well\" } func main () { var results [] bool results = append ( results , assert ( 5 + 5 , 10 , \"Something went wrong with 5 + 5\" )) results = append ( results , assert ( foo (), \"Working well\" , \"Something went wrong with foo()\" )) var successfulTests i32 for c := 0 ; c < len ( results ); c ++ { if results [ c ] { successfulTests = successfulTests + 1 } } printf ( \"%d tests were performed\\n\" , len ( results )) printf ( \"%d were successful\\n\" , successfulTests ) printf ( \"%d failed\\n\" , len ( results ) - successfulTests ) } bool Type Functions bool.print bool.eq bool.uneq bool.not bool.or bool.and Example package main func main () { bool . print ( bool . eq ( true , true )) bool . print ( bool . uneq ( false , true )) bool . print ( bool . not ( false )) bool . print ( bool . or ( true , false )) bool . print ( bool . and ( true , true )) } Type Functions str Type Functions str.print str.concat Example package main func main () { str . print ( str . concat ( \"Hello, \" , \"World!\" )) } i32 Type Functions The following functions are of general purpose and are restricted to work with data structures of type i32 where it makes sense. i32.print i32.add i32.sub i32.mul i32.div i32.mod i32.abs Example package main func main () { i32 . print ( i32 . add ( 5 , 7 )) i32 . print ( i32 . sub ( 6 , 3 )) i32 . print ( i32 . mul ( 4 , 8 )) i32 . print ( i32 . div ( 15 , 3 )) i32 . print ( i32 . mod ( 5 , 3 )) i32 . print ( i32 . abs ( - 13 )) } i32.log i32.log2 i32.log10 i32.pow i32.sqrt Example package main func main () { i32 . print ( i32 . log ( 13 )) i32 . print ( i32 . log2 ( 3 )) i32 . print ( i32 . log10 ( 12 )) i32 . print ( i32 . pow ( 4 , 4 )) i32 . print ( i32 . sqrt ( 2 )) } i32.gt i32.gteq i32.lt i32.lteq i32.eq i32.uneq Example package main func main () { bool . print ( i32 . gt ( 5 , 3 )) bool . print ( i32 . gteq ( 3 , 8 )) bool . print ( i32 . lt ( 4 , 3 )) bool . print ( i32 . lteq ( 8 , 6 )) bool . print ( i32 . eq ( - 9 , - 9 )) bool . print ( i32 . uneq ( 3 , 3 )) } i32.bitand i32.bitor i32.bitxor i32.bitclear i32.bitshl i32.bitshr Example package main func main () { i32 . print ( i32 . bitand ( 2 , 5 )) i32 . print ( i32 . bitor ( 8 , 3 )) i32 . print ( i32 . bitxor ( 3 , 9 )) i32 . print ( i32 . bitclear ( 4 , 4 )) i32 . print ( i32 . bitshl ( 5 , 9 )) i32 . print ( i32 . bitshr ( 1 , 6 )) } i32.max i32.min Example package main func main () { i32 . print ( i32 . max ( 2 , 5 )) i32 . print ( i32 . min ( 10 , 3 )) } i32.rand Example package main func main () { i32 . print ( i32 . rand ( 0 , 100 )) } i64 Type Functions The following functions are of general purpose and are restricted to work with data structures of type i64 where it makes sense. i64.print i64.add i64.sub i64.mul i64.div i64.mod i64.abs Example package main func main () { i64 . print ( i64 . add ( 5 L , 7 L )) i64 . print ( i64 . sub ( 6 L , 3 L )) i64 . print ( i64 . mul ( 4 L , 8 L )) i64 . print ( i64 . div ( 15 L , 3 L )) i64 . print ( i64 . mod ( 5 L , 3 L )) i64 . print ( i64 . abs ( - 13 L )) } i64.log i64.log2 i64.log10 i64.pow i64.sqrt Example package main func main () { i64 . print ( i64 . log ( 13 L )) i64 . print ( i64 . log2 ( 3 L )) i64 . print ( i64 . log10 ( 12 L )) i64 . print ( i64 . pow ( 4 L , 4 L )) i64 . print ( i64 . sqrt ( 2 L )) } i64.gt i64.gteq i64.lt i64.lteq i64.eq i64.uneq Example package main func main () { bool . print ( i64 . gt ( 5 L , 3 L )) bool . print ( i64 . gteq ( 3 L , 8 L )) bool . print ( i64 . lt ( 4 L , 3 L )) bool . print ( i64 . lteq ( 8 L , 6 L )) bool . print ( i64 . eq ( - 9 L , - 9 L )) bool . print ( i64 . uneq ( 3 L , 3 L )) } i64.bitand i64.bitor i64.bitxor i64.bitclear i64.bitshl i64.bitshr Example package main func main () { i64 . print ( i64 . bitand ( 2 L , 5 L )) i64 . print ( i64 . bitor ( 8 L , 3 L )) i64 . print ( i64 . bitxor ( 3 L , 9 L )) i64 . print ( i64 . bitclear ( 4 L , 4 L )) i64 . print ( i64 . bitshl ( 5 L , 9 L )) i64 . print ( i64 . bitshr ( 1 L , 6 L )) } i64.max i64.min Example package main func main () { i64 . print ( i64 . max ( 2 L , 5 L )) i64 . print ( i64 . min ( 10 L , 3 L )) } i64.rand Example package main func main () { i64 . print ( i64 . rand ( 0 L , 100 L )) } f32 Type Functions The following functions are of general purpose and are restricted to work with data structures of type f32 where it makes sense. f32.print f32.add f32.sub f32.mul f32.div f32.abs Example package main func main () { f32 . print ( f32 . add ( 5.3 , 10.5 )) f32 . print ( f32 . sub ( 3.2 , 6.7 )) f32 . print ( f32 . mul ( - 7.9 , - 7.1 )) f32 . print ( f32 . div ( 10.3 , 2.4 )) f32 . print ( f32 . abs ( - 3.14159 )) } f32.log f32.log2 f32.log10 f32.pow f32.sqrt Example package main func main () { f32 . print ( f32 . log ( 2.3 )) f32 . print ( f32 . log2 ( 3.4 )) f32 . print ( f32 . log10 ( 3.0 )) f32 . print ( f32 . pow ( - 5.3 , 2.0 )) f32 . print ( f32 . sqrt ( 4.0 )) } f32.sin f32.cos Example package main func main () { f32 . print ( f32 . sin ( 1.0 )) f32 . print ( f32 . cos ( 2.0 )) } f32.gt f32.gteq f32.lt f32.lteq f32.eq f32.uneq Example package main func main () { bool . print ( f32 . gt ( 5.3 , 3.1 )) bool . print ( f32 . gteq ( 3.7 , 1.9 )) bool . print ( f32 . lt ( 2.4 , 5.5 )) bool . print ( f32 . lteq ( 8.4 , 3.2 )) bool . print ( f32 . eq ( 10.3 , 10.3 )) bool . print ( f32 . uneq ( 8.9 , 3.3 )) } f32.max f32.min Example package main func main () { f32 . print ( f32 . max ( 3.3 , 4.2 )) f32 . print ( f32 . min ( 5.8 , 9.9 )) } f64 Type Functions The following functions are of general purpose and are restricted to work with data structures of type f64 where it makes sense. f64.print f64.add f64.sub f64.mul f64.div f64.abs Example package main func main () { f64 . print ( f64 . add ( 5.3 D , 10.5 D )) f64 . print ( f64 . sub ( 3.2 D , 6.7 D )) f64 . print ( f64 . mul ( - 7.9 D , - 7.1 D )) f64 . print ( f64 . div ( 10.3 D , 2.4 D )) f64 . print ( f64 . abs ( - 3.14159 D )) } f64.log f64.log2 f64.log10 f64.pow f64.sqrt Example package main func main () { f64 . print ( f64 . log ( 2.3 D )) f64 . print ( f64 . log2 ( 3.4 D )) f64 . print ( f64 . log10 ( 3.0 D )) f64 . print ( f64 . pow ( - 5.3 D , 2.0 D )) f64 . print ( f64 . sqrt ( 4.0 D )) } f64.sin f64.cos Example package main func main () { f64 . print ( f64 . sin ( 1.0 D )) f64 . print ( f64 . cos ( 2.0 D )) } f64.gt f64.gteq f64.lt f64.lteq f64.eq f64.uneq Example package main func main () { bool . print ( f64 . gt ( 5.3 D , 3.1 D )) bool . print ( f64 . gteq ( 3.7 D , 1.9 D )) bool . print ( f64 . lt ( 2.4 D , 5.5 D )) bool . print ( f64 . lteq ( 8.4 D , 3.2 D )) bool . print ( f64 . eq ( 10.3 D , 10.3 D )) bool . print ( f64 . uneq ( 8.9 D , 3.3 D )) } f64.max f64.min Example package main func main () { f64 . print ( f64 . max ( 3.3 D , 4.2 D )) f64 . print ( f64 . min ( 5.8 D , 9.9 D )) }","title":"Native Functions"},{"location":"software/cx/basics-native-functions/#native-functions","text":"","title":"Native Functions"},{"location":"software/cx/basics-native-functions/#type-inferenced-functions","text":"CX has a small set of functions that are not associated to a single type signature. For example, instead of using i32.add to add two 32-bit integers, you can use the generalized add function. Furthermore, whenever you use arithmetic operators, such as + , - or % , these are translated to their corresponding \"type-inferenced\" function, e.g. num = 5 + 5 is translated to num = i32.add(5, 5) . These native functions still follow CX's philosophy of having a strict typing system, as the types of the arguments sent to these native functions must be the same. Note that after listing a group of similar \"type-inferenced\" functions below, we list the compatible types for the corresponding functions.","title":"Type-inferenced Functions"},{"location":"software/cx/basics-native-functions/#eq","text":"","title":"eq"},{"location":"software/cx/basics-native-functions/#uneq","text":"Note: the preceding functions only work with arguments of type bool , byte , str , i32 , i64 , f32 or f64 .","title":"uneq"},{"location":"software/cx/basics-native-functions/#example","text":"package main func main () { bool . print ( eq ( 5 , 5 )) bool . print ( 5 == 5 ) // alternative bool . print ( uneq ( \"hihi\" , \"byebye\" )) bool . print ( \"hihi\" != \"byebye\" ) // alternative }","title":"Example"},{"location":"software/cx/basics-native-functions/#lt","text":"","title":"lt"},{"location":"software/cx/basics-native-functions/#gt","text":"","title":"gt"},{"location":"software/cx/basics-native-functions/#lteq","text":"","title":"lteq"},{"location":"software/cx/basics-native-functions/#gteq","text":"Note: the preceding function only works with arguments of type byte , bool , str , i32 , i64 , f32 or f64 .","title":"gteq"},{"location":"software/cx/basics-native-functions/#example_1","text":"package main func main () { bool . print ( lt ( 3 B , 4 B )) bool . print ( 3 B < 4 B ) // alternative bool . print ( gt ( \"hello\" , \"hi!\" )) bool . print ( \"hello\" > \"hi!\" ) // alternative bool . print ( lteq ( 5.3 D , 5.3 D )) bool . print ( 5.3 D <= 5.3 D ) // alternative bool . print ( gteq ( 10 L , 3 L )) bool . print ( 10 L >= 3 L ) // alternative }","title":"Example"},{"location":"software/cx/basics-native-functions/#bitand","text":"","title":"bitand"},{"location":"software/cx/basics-native-functions/#bitor","text":"","title":"bitor"},{"location":"software/cx/basics-native-functions/#bitxor","text":"","title":"bitxor"},{"location":"software/cx/basics-native-functions/#bitclear","text":"","title":"bitclear"},{"location":"software/cx/basics-native-functions/#bitshl","text":"","title":"bitshl"},{"location":"software/cx/basics-native-functions/#bitshr","text":"Note: the preceding functions only work with arguments of type i32 or i64 .","title":"bitshr"},{"location":"software/cx/basics-native-functions/#example_2","text":"package main func main () { i32 . print ( bitand ( 5 , 1 )) i32 . print ( 5 & 1 ) // alternative i64 . print ( bitor ( 3 L , 2 L )) i64 . print ( 3 L | 2 L ) // alternative i32 . print ( bitxor ( 10 , 2 )) i32 . print ( 10 ^ 2 ) // alternative i64 . print ( bitclear ( 5 L , 2 L )) i64 . print ( 5 L &^ 2 L ) // alternative i32 . print ( bitshl ( 2 , 3 )) i32 . print ( 2 << 3 ) // alternative i32 . print ( bitshr ( 16 , 3 )) i32 . print ( 16 >> 3 ) // alternative }","title":"Example"},{"location":"software/cx/basics-native-functions/#add","text":"","title":"add"},{"location":"software/cx/basics-native-functions/#sub","text":"","title":"sub"},{"location":"software/cx/basics-native-functions/#mul","text":"","title":"mul"},{"location":"software/cx/basics-native-functions/#div","text":"Note: the preceding functions only work with arguments of type byte , i32 , i64 , f32 or f64 .","title":"div"},{"location":"software/cx/basics-native-functions/#example_3","text":"package main func main () { byte . print ( add ( 5 B , 10 B )) byte . print ( 5 B + 10 B ) // alternative i32 . print ( sub ( 3 , 7 )) i32 . print ( 3 - 7 ) // alternative i64 . print ( mul ( 4 L , 5 L )) i64 . print ( 4 L * 5 L ) // alternative f32 . print ( div ( 4.3 , 2.1 )) f32 . print ( 4.3 / 2.1 ) // alternative }","title":"Example"},{"location":"software/cx/basics-native-functions/#mod","text":"Note: the preceding function only works with arguments of type byte , i32 or i64 .","title":"mod"},{"location":"software/cx/basics-native-functions/#example_4","text":"package main func main () { byte . print ( mod ( 5 B , 3 B )) byte . print ( 5 B % 3 B ) // alternative }","title":"Example"},{"location":"software/cx/basics-native-functions/#len","text":"Note: the preceding function only works with arguments of type str , arrays or slices .","title":"len"},{"location":"software/cx/basics-native-functions/#example_5","text":"package main func main () { var string str var array [ 5 ] i32 var slice [] i32 string = \"this should print 20\" array = [ 5 ] i32 { 1 , 2 , 3 , 4 , 5 } slice = [] i32 { 10 , 20 , 30 } i32 . print ( len ( string )) // prints 20 i32 . print ( len ( array )) // prints 5 i32 . print ( len ( slice )) // prints 3 }","title":"Example"},{"location":"software/cx/basics-native-functions/#printf","text":"Note: the preceding function requires a format str as its first argument, followed by any number of arguments of type str , i32 , i64 , f32 or f64 . The format string recognizes the following directives: %s for strings, %d for integers and %f for floating point numbers.","title":"printf"},{"location":"software/cx/basics-native-functions/#example_6","text":"package main func main () { var name str var age i32 var wrongPI f32 var error f64 name = \"Richard\" age = 14 wrongPI = 3.16 error = 0.0000000000000001 D printf ( \"Hello, %s. My name is %s. I see that you calculated the value of PI wrong (%f). I think this is not so bad, considering your young age of %d. When I was %d years old, I remember I miscalculated it, too (I got %f as a result, using a numerical method). If you are using a numerical method, please consider reaching an error lower than %f to get an acceptable result, and not a ridiculous value such as %f. \\n\\nBest regards!\\n\" , name , \"Edward\" , wrongPI , age , 25 , 3.1417 , error , 0.1 ) }","title":"Example"},{"location":"software/cx/basics-native-functions/#sprintf","text":"Note: the preceding function requires a format str as its first argument, followed by any number of arguments of type str , i32 , i64 , f32 or f64 . The format string recognizes the following directives: %s for strings, %d for integers and %f for floating point numbers. package main func main () { var reply str var name str var title str name = \"Edward\" title = \"Richard 8 PI\" reply = sprintf ( \"Thank you for contacting our technical support, %s. We see that you are having trouble with our video game titled '%s', targetted to kids under age %d. If you provide us with your parents e-mail address, we'll be glad to help you!\" , name , title , 14 ) str . print ( reply ) }","title":"sprintf"},{"location":"software/cx/basics-native-functions/#slice-functions","text":"","title":"Slice Functions"},{"location":"software/cx/basics-native-functions/#append","text":"","title":"append"},{"location":"software/cx/basics-native-functions/#example_7","text":"package main func main () { var slc1 [] i32 slc1 = append ( slc1 , 1 ) slc1 = append ( slc1 , 2 ) var slc2 [] i32 slc2 = append ( slc1 , 3 ) slc2 = append ( slc2 , 4 ) i32 . print ( len ( slc1 )) // prints 2 i32 . print ( len ( slc2 )) // prints 4 }","title":"Example"},{"location":"software/cx/basics-native-functions/#inputoutput-functions","text":"The following functions are used to handle input from the user and to print output to a terminal.","title":"Input/Output Functions"},{"location":"software/cx/basics-native-functions/#read","text":"","title":"read"},{"location":"software/cx/basics-native-functions/#example_8","text":"package main func main () { var password str for true { printf ( \"What's the password, kid? \" ) password = read () if password == \"123\" { str . print ( \"Welcome back.\" ) return } else { str . print ( \"Wrong, but you'll get another chance.\" ) } } }","title":"Example"},{"location":"software/cx/basics-native-functions/#byteprint","text":"","title":"byte.print"},{"location":"software/cx/basics-native-functions/#boolprint","text":"","title":"bool.print"},{"location":"software/cx/basics-native-functions/#strprint","text":"","title":"str.print"},{"location":"software/cx/basics-native-functions/#i32print","text":"","title":"i32.print"},{"location":"software/cx/basics-native-functions/#i64print","text":"","title":"i64.print"},{"location":"software/cx/basics-native-functions/#f32print","text":"","title":"f32.print"},{"location":"software/cx/basics-native-functions/#f64print","text":"","title":"f64.print"},{"location":"software/cx/basics-native-functions/#printf_1","text":"","title":"printf"},{"location":"software/cx/basics-native-functions/#example_9","text":"package main func main () { byte . print ( 5 B ) bool . print ( true ) str . print ( \"Hello!\" ) i32 . print ( 5 ) i64 . print ( 5 L ) f32 . print ( 5.0 ) f64 . print ( 5.0 D ) printf ( \"For a better example, check section Type-inferenced Functions'\" ) }","title":"Example"},{"location":"software/cx/basics-native-functions/#parse-functions","text":"All parse functions follow the same pattern: XXX.YYY where XXX is the receiving type and YYY is the target type. You can read these functions as \"parse XXX to YYY\".","title":"Parse Functions"},{"location":"software/cx/basics-native-functions/#bytestr","text":"","title":"byte.str"},{"location":"software/cx/basics-native-functions/#bytei32","text":"","title":"byte.i32"},{"location":"software/cx/basics-native-functions/#bytei64","text":"","title":"byte.i64"},{"location":"software/cx/basics-native-functions/#bytef32","text":"","title":"byte.f32"},{"location":"software/cx/basics-native-functions/#bytef64","text":"","title":"byte.f64"},{"location":"software/cx/basics-native-functions/#example_10","text":"package main func main () { var b byte b = 30 B str . print ( str . concat ( \"Hello, \" , byte . str ( b ))) i32 . print ( 5 + byte . i32 ( b )) i64 . print ( 10 L + byte . i64 ( b )) f32 . print ( 33.3 + byte . f32 ( b )) f64 . print ( 50.111 D + byte . f64 ( b )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i32byte","text":"","title":"i32.byte"},{"location":"software/cx/basics-native-functions/#i32str","text":"","title":"i32.str"},{"location":"software/cx/basics-native-functions/#i32i64","text":"","title":"i32.i64"},{"location":"software/cx/basics-native-functions/#i32f32","text":"","title":"i32.f32"},{"location":"software/cx/basics-native-functions/#i32f64","text":"","title":"i32.f64"},{"location":"software/cx/basics-native-functions/#example_11","text":"package main func main () { var num i32 num = 43 str . print ( str . concat ( \"Hello, \" , i32 . str ( num ))) byte . print ( 5 B + i32 . byte ( num )) i64 . print ( 10 L + i32 . i64 ( num )) f32 . print ( 33.3 + i32 . f32 ( num )) f64 . print ( 50.111 D + i32 . f64 ( num )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i64byte","text":"","title":"i64.byte"},{"location":"software/cx/basics-native-functions/#i64str","text":"","title":"i64.str"},{"location":"software/cx/basics-native-functions/#i64i32","text":"","title":"i64.i32"},{"location":"software/cx/basics-native-functions/#i64f32","text":"","title":"i64.f32"},{"location":"software/cx/basics-native-functions/#i64f64","text":"","title":"i64.f64"},{"location":"software/cx/basics-native-functions/#example_12","text":"package main func main () { var num i64 num = 43 L str . print ( str . concat ( \"Hello, \" , i64 . str ( num ))) byte . print ( 5 B + i64 . byte ( num )) i64 . print ( 10 L + i64 . i64 ( num )) f32 . print ( 33.3 + i64 . f32 ( num )) f64 . print ( 50.111 D + i64 . f64 ( num )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f32byte","text":"","title":"f32.byte"},{"location":"software/cx/basics-native-functions/#f32str","text":"","title":"f32.str"},{"location":"software/cx/basics-native-functions/#f32i32","text":"","title":"f32.i32"},{"location":"software/cx/basics-native-functions/#f32i64","text":"","title":"f32.i64"},{"location":"software/cx/basics-native-functions/#f32f64","text":"","title":"f32.f64"},{"location":"software/cx/basics-native-functions/#example_13","text":"package main func main () { var num f32 num = 43.33 str . print ( str . concat ( \"Hello, \" , f32 . str ( num ))) byte . print ( 5 B + f32 . byte ( num )) i32 . print ( 33 + f32 . f32 ( num )) i64 . print ( 10 L + f32 . i64 ( num )) f64 . print ( 50.111 D + f32 . f64 ( num )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f64byte","text":"","title":"f64.byte"},{"location":"software/cx/basics-native-functions/#f64str","text":"","title":"f64.str"},{"location":"software/cx/basics-native-functions/#f64i32","text":"","title":"f64.i32"},{"location":"software/cx/basics-native-functions/#f64i64","text":"","title":"f64.i64"},{"location":"software/cx/basics-native-functions/#f64f32","text":"","title":"f64.f32"},{"location":"software/cx/basics-native-functions/#example_14","text":"package main func main () { var num f64 num = 43.33 D str . print ( str . concat ( \"Hello, \" , f64 . str ( num ))) byte . print ( 5 B + f64 . byte ( num )) i32 . print ( 33 + f64 . f32 ( num )) i64 . print ( 10 L + f64 . i64 ( num )) f32 . print ( 50.111 + f64 . f32 ( num )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#strbyte","text":"","title":"str.byte"},{"location":"software/cx/basics-native-functions/#stri32","text":"","title":"str.i32"},{"location":"software/cx/basics-native-functions/#stri64","text":"","title":"str.i64"},{"location":"software/cx/basics-native-functions/#strf32","text":"","title":"str.f32"},{"location":"software/cx/basics-native-functions/#strf64","text":"","title":"str.f64"},{"location":"software/cx/basics-native-functions/#example_15","text":"package main func main () { var num str num = \"33\" byte . print ( 5 B + str . byte ( num )) i32 . print ( 33 + str . f32 ( num )) i64 . print ( 10 L + str . i64 ( num )) f32 . print ( 50.111 + str . f32 ( num )) f64 . print ( 50.111 D + str . f32 ( num )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#unit-testing","text":"The assert function is used to test the value of an expression against another value. This function is useful to test that a package is working as intended.","title":"Unit Testing"},{"location":"software/cx/basics-native-functions/#assert","text":"","title":"assert"},{"location":"software/cx/basics-native-functions/#example_16","text":"package main func foo () ( res str ) { res = \"Working well\" } func main () { var results [] bool results = append ( results , assert ( 5 + 5 , 10 , \"Something went wrong with 5 + 5\" )) results = append ( results , assert ( foo (), \"Working well\" , \"Something went wrong with foo()\" )) var successfulTests i32 for c := 0 ; c < len ( results ); c ++ { if results [ c ] { successfulTests = successfulTests + 1 } } printf ( \"%d tests were performed\\n\" , len ( results )) printf ( \"%d were successful\\n\" , successfulTests ) printf ( \"%d failed\\n\" , len ( results ) - successfulTests ) }","title":"Example"},{"location":"software/cx/basics-native-functions/#bool-type-functions","text":"","title":"bool Type Functions"},{"location":"software/cx/basics-native-functions/#boolprint_1","text":"","title":"bool.print"},{"location":"software/cx/basics-native-functions/#booleq","text":"","title":"bool.eq"},{"location":"software/cx/basics-native-functions/#booluneq","text":"","title":"bool.uneq"},{"location":"software/cx/basics-native-functions/#boolnot","text":"","title":"bool.not"},{"location":"software/cx/basics-native-functions/#boolor","text":"","title":"bool.or"},{"location":"software/cx/basics-native-functions/#booland","text":"","title":"bool.and"},{"location":"software/cx/basics-native-functions/#example_17","text":"package main func main () { bool . print ( bool . eq ( true , true )) bool . print ( bool . uneq ( false , true )) bool . print ( bool . not ( false )) bool . print ( bool . or ( true , false )) bool . print ( bool . and ( true , true )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#type-functions","text":"","title":"Type Functions"},{"location":"software/cx/basics-native-functions/#str-type-functions","text":"","title":"str Type Functions"},{"location":"software/cx/basics-native-functions/#strprint_1","text":"","title":"str.print"},{"location":"software/cx/basics-native-functions/#strconcat","text":"","title":"str.concat"},{"location":"software/cx/basics-native-functions/#example_18","text":"package main func main () { str . print ( str . concat ( \"Hello, \" , \"World!\" )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i32-type-functions","text":"The following functions are of general purpose and are restricted to work with data structures of type i32 where it makes sense.","title":"i32 Type Functions"},{"location":"software/cx/basics-native-functions/#i32print_1","text":"","title":"i32.print"},{"location":"software/cx/basics-native-functions/#i32add","text":"","title":"i32.add"},{"location":"software/cx/basics-native-functions/#i32sub","text":"","title":"i32.sub"},{"location":"software/cx/basics-native-functions/#i32mul","text":"","title":"i32.mul"},{"location":"software/cx/basics-native-functions/#i32div","text":"","title":"i32.div"},{"location":"software/cx/basics-native-functions/#i32mod","text":"","title":"i32.mod"},{"location":"software/cx/basics-native-functions/#i32abs","text":"","title":"i32.abs"},{"location":"software/cx/basics-native-functions/#example_19","text":"package main func main () { i32 . print ( i32 . add ( 5 , 7 )) i32 . print ( i32 . sub ( 6 , 3 )) i32 . print ( i32 . mul ( 4 , 8 )) i32 . print ( i32 . div ( 15 , 3 )) i32 . print ( i32 . mod ( 5 , 3 )) i32 . print ( i32 . abs ( - 13 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i32log","text":"","title":"i32.log"},{"location":"software/cx/basics-native-functions/#i32log2","text":"","title":"i32.log2"},{"location":"software/cx/basics-native-functions/#i32log10","text":"","title":"i32.log10"},{"location":"software/cx/basics-native-functions/#i32pow","text":"","title":"i32.pow"},{"location":"software/cx/basics-native-functions/#i32sqrt","text":"","title":"i32.sqrt"},{"location":"software/cx/basics-native-functions/#example_20","text":"package main func main () { i32 . print ( i32 . log ( 13 )) i32 . print ( i32 . log2 ( 3 )) i32 . print ( i32 . log10 ( 12 )) i32 . print ( i32 . pow ( 4 , 4 )) i32 . print ( i32 . sqrt ( 2 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i32gt","text":"","title":"i32.gt"},{"location":"software/cx/basics-native-functions/#i32gteq","text":"","title":"i32.gteq"},{"location":"software/cx/basics-native-functions/#i32lt","text":"","title":"i32.lt"},{"location":"software/cx/basics-native-functions/#i32lteq","text":"","title":"i32.lteq"},{"location":"software/cx/basics-native-functions/#i32eq","text":"","title":"i32.eq"},{"location":"software/cx/basics-native-functions/#i32uneq","text":"","title":"i32.uneq"},{"location":"software/cx/basics-native-functions/#example_21","text":"package main func main () { bool . print ( i32 . gt ( 5 , 3 )) bool . print ( i32 . gteq ( 3 , 8 )) bool . print ( i32 . lt ( 4 , 3 )) bool . print ( i32 . lteq ( 8 , 6 )) bool . print ( i32 . eq ( - 9 , - 9 )) bool . print ( i32 . uneq ( 3 , 3 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i32bitand","text":"","title":"i32.bitand"},{"location":"software/cx/basics-native-functions/#i32bitor","text":"","title":"i32.bitor"},{"location":"software/cx/basics-native-functions/#i32bitxor","text":"","title":"i32.bitxor"},{"location":"software/cx/basics-native-functions/#i32bitclear","text":"","title":"i32.bitclear"},{"location":"software/cx/basics-native-functions/#i32bitshl","text":"","title":"i32.bitshl"},{"location":"software/cx/basics-native-functions/#i32bitshr","text":"","title":"i32.bitshr"},{"location":"software/cx/basics-native-functions/#example_22","text":"package main func main () { i32 . print ( i32 . bitand ( 2 , 5 )) i32 . print ( i32 . bitor ( 8 , 3 )) i32 . print ( i32 . bitxor ( 3 , 9 )) i32 . print ( i32 . bitclear ( 4 , 4 )) i32 . print ( i32 . bitshl ( 5 , 9 )) i32 . print ( i32 . bitshr ( 1 , 6 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i32max","text":"","title":"i32.max"},{"location":"software/cx/basics-native-functions/#i32min","text":"","title":"i32.min"},{"location":"software/cx/basics-native-functions/#example_23","text":"package main func main () { i32 . print ( i32 . max ( 2 , 5 )) i32 . print ( i32 . min ( 10 , 3 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i32rand","text":"","title":"i32.rand"},{"location":"software/cx/basics-native-functions/#example_24","text":"package main func main () { i32 . print ( i32 . rand ( 0 , 100 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i64-type-functions","text":"The following functions are of general purpose and are restricted to work with data structures of type i64 where it makes sense.","title":"i64 Type Functions"},{"location":"software/cx/basics-native-functions/#i64print_1","text":"","title":"i64.print"},{"location":"software/cx/basics-native-functions/#i64add","text":"","title":"i64.add"},{"location":"software/cx/basics-native-functions/#i64sub","text":"","title":"i64.sub"},{"location":"software/cx/basics-native-functions/#i64mul","text":"","title":"i64.mul"},{"location":"software/cx/basics-native-functions/#i64div","text":"","title":"i64.div"},{"location":"software/cx/basics-native-functions/#i64mod","text":"","title":"i64.mod"},{"location":"software/cx/basics-native-functions/#i64abs","text":"","title":"i64.abs"},{"location":"software/cx/basics-native-functions/#example_25","text":"package main func main () { i64 . print ( i64 . add ( 5 L , 7 L )) i64 . print ( i64 . sub ( 6 L , 3 L )) i64 . print ( i64 . mul ( 4 L , 8 L )) i64 . print ( i64 . div ( 15 L , 3 L )) i64 . print ( i64 . mod ( 5 L , 3 L )) i64 . print ( i64 . abs ( - 13 L )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i64log","text":"","title":"i64.log"},{"location":"software/cx/basics-native-functions/#i64log2","text":"","title":"i64.log2"},{"location":"software/cx/basics-native-functions/#i64log10","text":"","title":"i64.log10"},{"location":"software/cx/basics-native-functions/#i64pow","text":"","title":"i64.pow"},{"location":"software/cx/basics-native-functions/#i64sqrt","text":"","title":"i64.sqrt"},{"location":"software/cx/basics-native-functions/#example_26","text":"package main func main () { i64 . print ( i64 . log ( 13 L )) i64 . print ( i64 . log2 ( 3 L )) i64 . print ( i64 . log10 ( 12 L )) i64 . print ( i64 . pow ( 4 L , 4 L )) i64 . print ( i64 . sqrt ( 2 L )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i64gt","text":"","title":"i64.gt"},{"location":"software/cx/basics-native-functions/#i64gteq","text":"","title":"i64.gteq"},{"location":"software/cx/basics-native-functions/#i64lt","text":"","title":"i64.lt"},{"location":"software/cx/basics-native-functions/#i64lteq","text":"","title":"i64.lteq"},{"location":"software/cx/basics-native-functions/#i64eq","text":"","title":"i64.eq"},{"location":"software/cx/basics-native-functions/#i64uneq","text":"","title":"i64.uneq"},{"location":"software/cx/basics-native-functions/#example_27","text":"package main func main () { bool . print ( i64 . gt ( 5 L , 3 L )) bool . print ( i64 . gteq ( 3 L , 8 L )) bool . print ( i64 . lt ( 4 L , 3 L )) bool . print ( i64 . lteq ( 8 L , 6 L )) bool . print ( i64 . eq ( - 9 L , - 9 L )) bool . print ( i64 . uneq ( 3 L , 3 L )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i64bitand","text":"","title":"i64.bitand"},{"location":"software/cx/basics-native-functions/#i64bitor","text":"","title":"i64.bitor"},{"location":"software/cx/basics-native-functions/#i64bitxor","text":"","title":"i64.bitxor"},{"location":"software/cx/basics-native-functions/#i64bitclear","text":"","title":"i64.bitclear"},{"location":"software/cx/basics-native-functions/#i64bitshl","text":"","title":"i64.bitshl"},{"location":"software/cx/basics-native-functions/#i64bitshr","text":"","title":"i64.bitshr"},{"location":"software/cx/basics-native-functions/#example_28","text":"package main func main () { i64 . print ( i64 . bitand ( 2 L , 5 L )) i64 . print ( i64 . bitor ( 8 L , 3 L )) i64 . print ( i64 . bitxor ( 3 L , 9 L )) i64 . print ( i64 . bitclear ( 4 L , 4 L )) i64 . print ( i64 . bitshl ( 5 L , 9 L )) i64 . print ( i64 . bitshr ( 1 L , 6 L )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i64max","text":"","title":"i64.max"},{"location":"software/cx/basics-native-functions/#i64min","text":"","title":"i64.min"},{"location":"software/cx/basics-native-functions/#example_29","text":"package main func main () { i64 . print ( i64 . max ( 2 L , 5 L )) i64 . print ( i64 . min ( 10 L , 3 L )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#i64rand","text":"","title":"i64.rand"},{"location":"software/cx/basics-native-functions/#example_30","text":"package main func main () { i64 . print ( i64 . rand ( 0 L , 100 L )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f32-type-functions","text":"The following functions are of general purpose and are restricted to work with data structures of type f32 where it makes sense.","title":"f32 Type Functions"},{"location":"software/cx/basics-native-functions/#f32print_1","text":"","title":"f32.print"},{"location":"software/cx/basics-native-functions/#f32add","text":"","title":"f32.add"},{"location":"software/cx/basics-native-functions/#f32sub","text":"","title":"f32.sub"},{"location":"software/cx/basics-native-functions/#f32mul","text":"","title":"f32.mul"},{"location":"software/cx/basics-native-functions/#f32div","text":"","title":"f32.div"},{"location":"software/cx/basics-native-functions/#f32abs","text":"","title":"f32.abs"},{"location":"software/cx/basics-native-functions/#example_31","text":"package main func main () { f32 . print ( f32 . add ( 5.3 , 10.5 )) f32 . print ( f32 . sub ( 3.2 , 6.7 )) f32 . print ( f32 . mul ( - 7.9 , - 7.1 )) f32 . print ( f32 . div ( 10.3 , 2.4 )) f32 . print ( f32 . abs ( - 3.14159 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f32log","text":"","title":"f32.log"},{"location":"software/cx/basics-native-functions/#f32log2","text":"","title":"f32.log2"},{"location":"software/cx/basics-native-functions/#f32log10","text":"","title":"f32.log10"},{"location":"software/cx/basics-native-functions/#f32pow","text":"","title":"f32.pow"},{"location":"software/cx/basics-native-functions/#f32sqrt","text":"","title":"f32.sqrt"},{"location":"software/cx/basics-native-functions/#example_32","text":"package main func main () { f32 . print ( f32 . log ( 2.3 )) f32 . print ( f32 . log2 ( 3.4 )) f32 . print ( f32 . log10 ( 3.0 )) f32 . print ( f32 . pow ( - 5.3 , 2.0 )) f32 . print ( f32 . sqrt ( 4.0 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f32sin","text":"","title":"f32.sin"},{"location":"software/cx/basics-native-functions/#f32cos","text":"","title":"f32.cos"},{"location":"software/cx/basics-native-functions/#example_33","text":"package main func main () { f32 . print ( f32 . sin ( 1.0 )) f32 . print ( f32 . cos ( 2.0 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f32gt","text":"","title":"f32.gt"},{"location":"software/cx/basics-native-functions/#f32gteq","text":"","title":"f32.gteq"},{"location":"software/cx/basics-native-functions/#f32lt","text":"","title":"f32.lt"},{"location":"software/cx/basics-native-functions/#f32lteq","text":"","title":"f32.lteq"},{"location":"software/cx/basics-native-functions/#f32eq","text":"","title":"f32.eq"},{"location":"software/cx/basics-native-functions/#f32uneq","text":"","title":"f32.uneq"},{"location":"software/cx/basics-native-functions/#example_34","text":"package main func main () { bool . print ( f32 . gt ( 5.3 , 3.1 )) bool . print ( f32 . gteq ( 3.7 , 1.9 )) bool . print ( f32 . lt ( 2.4 , 5.5 )) bool . print ( f32 . lteq ( 8.4 , 3.2 )) bool . print ( f32 . eq ( 10.3 , 10.3 )) bool . print ( f32 . uneq ( 8.9 , 3.3 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f32max","text":"","title":"f32.max"},{"location":"software/cx/basics-native-functions/#f32min","text":"","title":"f32.min"},{"location":"software/cx/basics-native-functions/#example_35","text":"package main func main () { f32 . print ( f32 . max ( 3.3 , 4.2 )) f32 . print ( f32 . min ( 5.8 , 9.9 )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f64-type-functions","text":"The following functions are of general purpose and are restricted to work with data structures of type f64 where it makes sense.","title":"f64 Type Functions"},{"location":"software/cx/basics-native-functions/#f64print_1","text":"","title":"f64.print"},{"location":"software/cx/basics-native-functions/#f64add","text":"","title":"f64.add"},{"location":"software/cx/basics-native-functions/#f64sub","text":"","title":"f64.sub"},{"location":"software/cx/basics-native-functions/#f64mul","text":"","title":"f64.mul"},{"location":"software/cx/basics-native-functions/#f64div","text":"","title":"f64.div"},{"location":"software/cx/basics-native-functions/#f64abs","text":"","title":"f64.abs"},{"location":"software/cx/basics-native-functions/#example_36","text":"package main func main () { f64 . print ( f64 . add ( 5.3 D , 10.5 D )) f64 . print ( f64 . sub ( 3.2 D , 6.7 D )) f64 . print ( f64 . mul ( - 7.9 D , - 7.1 D )) f64 . print ( f64 . div ( 10.3 D , 2.4 D )) f64 . print ( f64 . abs ( - 3.14159 D )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f64log","text":"","title":"f64.log"},{"location":"software/cx/basics-native-functions/#f64log2","text":"","title":"f64.log2"},{"location":"software/cx/basics-native-functions/#f64log10","text":"","title":"f64.log10"},{"location":"software/cx/basics-native-functions/#f64pow","text":"","title":"f64.pow"},{"location":"software/cx/basics-native-functions/#f64sqrt","text":"","title":"f64.sqrt"},{"location":"software/cx/basics-native-functions/#example_37","text":"package main func main () { f64 . print ( f64 . log ( 2.3 D )) f64 . print ( f64 . log2 ( 3.4 D )) f64 . print ( f64 . log10 ( 3.0 D )) f64 . print ( f64 . pow ( - 5.3 D , 2.0 D )) f64 . print ( f64 . sqrt ( 4.0 D )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f64sin","text":"","title":"f64.sin"},{"location":"software/cx/basics-native-functions/#f64cos","text":"","title":"f64.cos"},{"location":"software/cx/basics-native-functions/#example_38","text":"package main func main () { f64 . print ( f64 . sin ( 1.0 D )) f64 . print ( f64 . cos ( 2.0 D )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f64gt","text":"","title":"f64.gt"},{"location":"software/cx/basics-native-functions/#f64gteq","text":"","title":"f64.gteq"},{"location":"software/cx/basics-native-functions/#f64lt","text":"","title":"f64.lt"},{"location":"software/cx/basics-native-functions/#f64lteq","text":"","title":"f64.lteq"},{"location":"software/cx/basics-native-functions/#f64eq","text":"","title":"f64.eq"},{"location":"software/cx/basics-native-functions/#f64uneq","text":"","title":"f64.uneq"},{"location":"software/cx/basics-native-functions/#example_39","text":"package main func main () { bool . print ( f64 . gt ( 5.3 D , 3.1 D )) bool . print ( f64 . gteq ( 3.7 D , 1.9 D )) bool . print ( f64 . lt ( 2.4 D , 5.5 D )) bool . print ( f64 . lteq ( 8.4 D , 3.2 D )) bool . print ( f64 . eq ( 10.3 D , 10.3 D )) bool . print ( f64 . uneq ( 8.9 D , 3.3 D )) }","title":"Example"},{"location":"software/cx/basics-native-functions/#f64max","text":"","title":"f64.max"},{"location":"software/cx/basics-native-functions/#f64min","text":"","title":"f64.min"},{"location":"software/cx/basics-native-functions/#example_40","text":"package main func main () { f64 . print ( f64 . max ( 3.3 D , 4.2 D )) f64 . print ( f64 . min ( 5.8 D , 9.9 D )) }","title":"Example"},{"location":"software/cx/basics-repl/","text":"REPL Once CX has been successfully installed, running cx should print this in your terminal: CX 0.5.13 More information about CX is available at http : //cx.skycoin.net/ and https://github.com/skycoin/cx/ : func main { ... * This is the CX REPL ( read-eval-print loop ), where you can debug and modify CX programs. The CX REPL starts with a barebones CX structure (a main package and a main function) that you can use to start building a program. Let's create a small program to test the REPL. First, write str.print(\"Testing the REPL\") after the * , and press enter. After pressing enter you'll see the message \"Testing the REPL\" on the screen. If you then write :dp (short for :dProgram or debug program ), you should get the current program AST printed: Program 0. - Package : main Functions 0. - Function : main () () 0. - Expression : str . print ( \"\" str ) 1. - Function : * init () () As we can see, we have a main package, a main function, and we have a single expression: str.print(\"Testing the REPL\") . Let's now create a new function. In order to do this, we first need to leave the main function. At this moment, any expression (or function call) that we add to our program is going to be added to main . To exit a function declaration, press Ctrl+D . The prompt ( * ) should have changed indentation, and the REPL now shouldn't print :func main {... above the prompt: : func main { ... * * Now, let's enter a function prototype (an empty function which only specifies the name, the inputs and the outputs): * func sum ( num1 i32 , num2 i32 ) ( num3 i32 ) {} * You can check that the function was indeed added by issuing a :dp command. If we want to add expressions to sum , we have to select it: * : func sum : func sum { ... * Notice that there's a semicolon before func sum . Now we can add an expression to it: : func sum { ... * num3 = num1 + num2 Now, exit sum and select main with the command :func main . Let's add a call to sum and print the value that it returns when giving the arguments 10 and 20: : func main { ... * i32 . print ( sum ( 10 , 20 )) 30","title":"REPL"},{"location":"software/cx/basics-repl/#repl","text":"Once CX has been successfully installed, running cx should print this in your terminal: CX 0.5.13 More information about CX is available at http : //cx.skycoin.net/ and https://github.com/skycoin/cx/ : func main { ... * This is the CX REPL ( read-eval-print loop ), where you can debug and modify CX programs. The CX REPL starts with a barebones CX structure (a main package and a main function) that you can use to start building a program. Let's create a small program to test the REPL. First, write str.print(\"Testing the REPL\") after the * , and press enter. After pressing enter you'll see the message \"Testing the REPL\" on the screen. If you then write :dp (short for :dProgram or debug program ), you should get the current program AST printed: Program 0. - Package : main Functions 0. - Function : main () () 0. - Expression : str . print ( \"\" str ) 1. - Function : * init () () As we can see, we have a main package, a main function, and we have a single expression: str.print(\"Testing the REPL\") . Let's now create a new function. In order to do this, we first need to leave the main function. At this moment, any expression (or function call) that we add to our program is going to be added to main . To exit a function declaration, press Ctrl+D . The prompt ( * ) should have changed indentation, and the REPL now shouldn't print :func main {... above the prompt: : func main { ... * * Now, let's enter a function prototype (an empty function which only specifies the name, the inputs and the outputs): * func sum ( num1 i32 , num2 i32 ) ( num3 i32 ) {} * You can check that the function was indeed added by issuing a :dp command. If we want to add expressions to sum , we have to select it: * : func sum : func sum { ... * Notice that there's a semicolon before func sum . Now we can add an expression to it: : func sum { ... * num3 = num1 + num2 Now, exit sum and select main with the command :func main . Let's add a call to sum and print the value that it returns when giving the arguments 10 and 20: : func main { ... * i32 . print ( sum ( 10 , 20 )) 30","title":"REPL"},{"location":"software/cx/basics-running-cx/","text":"Running CX To run a CX program, you have to type, for example, cx the-program.cx . Let's try to run some examples from the examples directory in this repository. In a terminal, type this: cd $GOPATH /src/github.com/skycoin/cx/ cx examples/hello-world.cx This should print Hello World! in the terminal. Now try running cx examples/opengl/game.cx . Other Options If you write cx --help or cx -h , you should see a text describing CX's usage, options and more. Some interesting options are: --base which generates a CX program's assembly code (in Go) --compile which generates an executable file --repl which loads the program and makes CX run in REPL mode (useful for debugging a program) --web which starts CX as a RESTful web service (you can send code to be evaluated to this endpoint: http://127.0.0.1:5336/eval)","title":"Running CX"},{"location":"software/cx/basics-running-cx/#running-cx","text":"To run a CX program, you have to type, for example, cx the-program.cx . Let's try to run some examples from the examples directory in this repository. In a terminal, type this: cd $GOPATH /src/github.com/skycoin/cx/ cx examples/hello-world.cx This should print Hello World! in the terminal. Now try running cx examples/opengl/game.cx .","title":"Running CX"},{"location":"software/cx/basics-running-cx/#other-options","text":"If you write cx --help or cx -h , you should see a text describing CX's usage, options and more. Some interesting options are: --base which generates a CX program's assembly code (in Go) --compile which generates an executable file --repl which loads the program and makes CX run in REPL mode (useful for debugging a program) --web which starts CX as a RESTful web service (you can send code to be evaluated to this endpoint: http://127.0.0.1:5336/eval)","title":"Other Options"},{"location":"software/cx/basics-runtime/","text":"Runtime The previous section presents the language features from a syntax perspective. In this section we'll cover what's the logic behind these features: how they interact with other elements in your program, and what are the intrinsic capabilities of each of these features. Packages Packages are CX's mechanism for better organizing your code. Although it is theoretically possible to store a big project in a single package, the code will most likely become very hard to understand. In CX the programmer is encouraged to place the files that define the code of a package in separate directory. Any subdirectory in a package's directory should also contain only source code files that define elements of the same package. Nevertheless, CX will not throw any error if you don't follow this way of laying out your source files. In fact, you can declare different packages in a single source code file. Data Structures Data structures are particular arrangements of bytes that the language interprets and stores in special ways. The most basic data structures represent basic data, such as numbers and character strings, but these basic types can be used to construct more complex data types. Literals A literal is any data structure that is not being referenced by any variable yet. For example: 1 , true , []i32{1, 2, 3} , Point{x: 10, y: 20} . It's important to make a distinction, particularly with arrays , slices and struct instances . package main type Point struct { x i32 y i32 } func main () { var p1 Point p1 . x = 10 p1 . y = 20 p2 := Point { x : 11 , y : 21 } i32 . print ( p2 . x ) i32 . print ( p2 . y ) } In the example above we are creating two instances of the Point type. The first method we use does not involve struct literals, as a variable of that type is first created and then initialized. In the second case ( p2 ), the full struct instance is first created. CX creates an anonymous struct instance as soon as it encounters Points{x: 11, y: 21} , and then it proceeds to assign that literal to the p2 variable, using short variable declarations . package main func main () { var arr1 [ 3 ] i32 arr1 [ 0 ] = 1 arr1 [ 1 ] = 2 arr1 [ 2 ] = 3 arr2 := [ 3 ] i32 { 10 , 20 , 30 } } package main func main () { var slc1 [] i32 slc1 = append ( slc1 , 1 ) slc1 = append ( slc1 , 2 ) slc1 = append ( slc1 , 3 ) slc2 := [] i32 { 10 , 20 , 30 } } Similarly, in the two examples above we can see how we can declare array and slice variables and then we initialize them. In the case of arrays, we use the bracket notation, and for slices we have to use append , as slc1 starts with a size and capacity of 0. In the cases of arr2 and slc2 , we use literals to initialize them more conveniently. Regarding numbers, you need to be aware that implicit casting does not exist in CX. This means that the number 34 cannot be assigned to a variable of type i64 . In order to assign it, you need to either parse it using the native function i32.i64 or you can create a 64-bit integer literal. To create a number literal of a type other than i32 , you can use different suffixes: B , L and D , for byte , i64 (long) and f64 , respectively. So, assuming foo is of type i64 , you can do this assignment: foo = 34L . Variables When CX compiles a program, it knows how many bytes need to be reserved in the stack for each of the functions. CX can know this thanks to variable declarations. package main type Point struct { x i32 y i32 } func foo ( inp Point ) { var test1 i64 var test2 bool } func main () { var test3 i32 var test4 f32 } The two functions declared in the example above are going to reserve 17 and 8 bytes in the stack, respectively. In the case of the first function, foo needs to reserve space for an input parameter of type Point , which requires 8 bytes (because of the two i32 fields), and two local variables: one 64-bit integer that requires 8 bytes and a Boolean that requires a single byte. In the case of main , CX needs to reserve bytes for two local variables: a 32-bit integer and a single-precision floating point number, where each of them require 4 bytes. package main var global1 i32 func main () { var local i32 } Local variables are different than global variables. In order for globals to have a global scope they need to be allocated in a different memory segment than local variables. This different memory segment does not shrink or get bigger like the stack. This means that any global variable is going to be kept \"alive\" as long as the program keeps being executed. A global scope means that variables of this type are accessible to any function declared in the same package where the variable is declared, and to any function of other packages that are importing this package. package main func main () { var foo i32 i32 . print ( foo ) // prints 0 } In CX every variable is going to initially point to a nil value. This nil value is basically a series of one or more zeroes, depending on the size of the data type of a given variable. For example, in the code above we see that we have declared a variable of type i32 and we immediately print its value without initializing it. This CX program will print 0, as the value of foo is [0 0 0 0] in the stack (4 zeroes, as a 32-bit integer is represented by 4 bytes). In the case of data types that point to variable-sized structures, such as slices or character strings, these are initialized to a nil pointer, which is represented by 4 zeroed bytes. This nil pointer is located in the heap memory segment, instead of the stack. Primitive types There are seven primitive types in CX: bool , str , byte , i32 , i64 , f32 , and f64 . These types can be used to construct other more complex types, as will be seen in the next sections. bool and byte both require a single byte to represent their values. In the case of bool , there are only two possible values: true or false . In the case of byte you can represent up to 256 values, which range from 0 to 255. Next in size, we have i32 and f32 , where both of them require 4 bytes, and then we have i64 and f64 , which require 8 bytes each. Now, strings are special as they are static and dynamic sized at the same time. If you have a look at how a variable of type str reserves memory in the stack, you'll see that it requires 4 bytes, regardless of what text it's pointing to. The explanation behind this is that any str in CX actually behaves like a pointer behind the scenes, and the actual string gets stored in the heap memory segment. package main func main () { var foo str foo = str . concat ( \"Hello, \" , \"World!\" ) foo = \"Hi\" } When CX compiles the example above, three strings are first stored in the data memory segment (just like global variables, as these strings are constants, memory-wise): \"Hello, \" , \"World\" and \"Hi\" . When the program is executed, str.concat is called, which creates a new string by concatenating \"Hello, \" and \"World!\" , and this new character string is allocated in the heap memory segment. Then foo is assigned only the address of this new character string. Then we immediately re-assign foo with the address of \"Hi\" . This means that foo was first assigned a memory address located in the data memory segment, and then it was assigned an address located in the heap. Arrays Arrays, as in other programming languages, are used to create collections of data structures. These data structures can be primitive types, custom types or even arrays or slices. package main type Point struct { x i32 y i32 } func main () { var [ 5 ] i32 var [ 5 ] Point } In the example above, we're creating two arrays, one of a primitive type and the other one of a custom type. CX reserves memory for these arrays in the stack as soon as the function that contains them is called. In this case, 60 bytes are going to be reserved for main as soon as the program starts its execution, as main acts as the program's entry point. You need to be careful with arrays, as those can easily fill up your memory, especially with multi-dimensional arrays (or matrices). Also, another point to consider is performance. While accessing arrays is almost as fast as accessing an atomic variable, arrays can be troublesome when being sent/received as to/from functions. The reason behind this is that an array needs to be copied whenever it is sent to another function. If you're working with arrays of millions of elements and you need to be sending that arrays millions of times to another function, it's going to impact your program's performance a lot. A way to avoid this is to either use pointers to arrays or slices. Slices Dynamic arrays don't exist in CX. This means that the following code is not a valid CX program: package main func main () { var size i32 size = 13 var arr [ size ] // this is not valid } If you need an array that can grow in size as required, you need to use slices. Behind the scenes, slices are just arrays with some extra features. First of all, any slice in CX goes directly to the heap, as it's a data structure that is going to be changing in size. In contrast, arrays are always going to be stored in the stack, unless we're handling pointers to arrays. However, this behavior may change in the future, when CX's escape analysis mechanism improves (for example, the compiler can determine if an array is never going to change its size, and decide to keep it in the stack). The second characteristic of slices in CX is how they change their size. Any slice, when it's first declared, starts with a size and capacity of 0. The size represents how many elements are in a given slice, while the capacity represents how many elements can be allocated in that slice without having to be relocated in the heap. package main func main () { var slc [] i32 slc = append ( slc , 1 ) slc = append ( slc , 2 ) slc = append ( slc , 3 ) slc = append ( slc , 4 ) } In the code above we can see how we declare a slice and then we initialize it using the append function. After all the append s, we'll end up with a slice of size 4 and capacity 4, and this append ing process will create the following objects in the heap: [ 0 0 0 0 0 12 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 16 0 0 0 2 0 0 0 2 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 24 0 0 0 4 0 0 0 4 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 ] First, the slice slc starts with 0 objects in it; it is pointing to nil . Then, after the first append , the object [0 0 0 0 0 12 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0] is allocated to the heap. The first five bytes are used by CX's garbage collector. The next 4 bytes indicate the size of the object, and the remaining bytes are the actual slice slc . The first four bytes of slc tell us its current size, while the next four tell us its capacity. The remaining bytes of this object are the elements of the slice. The following object, [0 0 0 0 0 16 0 0 0 2 0 0 0 2 0 0 0 1 0 0 0 2 0 0 0] , shows now a size of 2 and a capacity of 2, with the 32-bit integers 1 and 2 as its elements. The last object, 0 0 0 0 0 24 0 0 0 4 0 0 0 4 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 , needs careful attention. We can see that our objects jumped from size 1 to 2 and finally 4. The same happened to its capacity, and the containing elements are now 1 , 2 , 3 and 4 . What happened to the slice of size 3 and capacity 3? First of all, capacities are increased by getting doubled each time the size of an object is greater than its capacity, so we would never get a slice of capacity 4 by following this method. Next, we need to think on what is capacity used for. Slices are just arrays, which means that they can't be resized. The dynamic nature of slices is emulated by copying the full slice to somewhere else in memory, but with a greater capacity. However, this will only happen if adding a new element to the existing slice would overflow it. This is why slices keep track of two metrics: size and capacity , i.e. how many actual elements are in the slice, and how many elements the currently allocated slice can hold, respectively. package main func main () { var arr1 [ 1 ] i32 arr1 [ 0 ] = 1 // add the first value var arr2 [ 2 ] i32 // double the size arr2 [ 0 ] = arr1 [ 0 ] // copy previous array arr2 [ 1 ] = 2 // add the second value var arr3 [ 4 ] i32 // double the size arr3 [ 0 ] = arr2 [ 0 ] // copy previous array arr3 [ 1 ] = arr2 [ 1 ] // copy previous array arr3 [ 2 ] = 3 // add the third value arr3 [ 3 ] = 4 // add the fourth value } The example above shows the behavior of the slice in the previous example, but using arrays. Structures Structures are CX's mechanism for creating custom types, as in many other C-like languages. Structures are basically a grouping of other primitive or custom types (called fields ) that together create another type of data structure. For example, a point can be defined by its coordinates in a two-dimensional space. In order to create a type Point , you can use a structure that contains two fields of type i32 , one for x and another for y , as in the example below. package main type Point struct { x i32 y i32 } func main () { var p Point p . x = 10 p . y = 20 } Whenever an instance of a structure is created by either declaring a variable of that type or by creating a literal of that type, CX reserves memory to hold space for all the fields defined in the structure declaration. Like in C, the bytes are reserved depending on the order of the fields in the structure declaration. package main type struct1 struct { field1 bool field2 i32 field3 i64 } type struct2 struct { field1 i64 field2 bool field3 i32 } func main () { var s1 struct1 var s2 struct2 } For example, in the code above a call to main will reserve a total of 26 bytes in the stack. In the case of the first struct instance, the first byte is going to represent field1 of type bool , the next four bytes are going to represent field2 of type i32 , and the final 8 bytes are going to represent field3 of type i64 . In the case of the next struct instance, the first eight bytes represent an i64 field so, although both struct instances contain the same number of fields and of the same type, the byte layout changes. Pointers Sometimes it's useful to pass variables to functions by reference instead of by value. package main import \"time\" func foo ( nums [ 100 ][ 100 ] i32 ) { // do something with nums } func main () { var start i64 var end i64 var nums [ 100 ][ 100 ] i32 start = time . UnixMilli () for c := 0 ; c < 10000 ; c ++ { foo ( nums ) } end = time . UnixMilli () printf ( \"elapsed time: \\t%d milliseconds\\n\" , end - start ) } The example above is very inefficient, as CX is going to be sending a 10,000 element matrix to foo 10,000 times. Every time foo is called, every byte of that matrix needs to be copied for foo . In my computer the example above takes around 638 milliseconds to run. package main import \"time\" func foo ( nums * [ 100 ][ 100 ] i32 ) { // do something with nums } func main () { var start i64 var end i64 var nums [ 100 ][ 100 ] i32 start = time . UnixMilli () for c := 0 ; c < 10000 ; c ++ { foo ( & nums ) } end = time . UnixMilli () printf ( \"elapsed time: \\t%d milliseconds\\n\" , end - start ) } A new version of the last program is shown above. In contrast to the last program, the code above sends a pointer to the matrix to foo . A pointer in CX uses only 4 bytes (in the future, pointers will use 8 bytes in 64-bit systems and 4 bytes in 32-bit systems), so instead of copying 10,000 bytes, we only copy 4 bytes to foo every time we call it. This version of the program takes only 3 milliseconds to run in my computer. package main func foo ( inp i32 ) { inp = 10 } func main () { var num i32 num = 15 i32 . print ( num ) // prints 15 foo ( num ) i32 . print ( num ) // prints 15 } In the example above, we send num to foo , and then we re-assign the input's value to 10 . If we print the value of num before and after calling foo , we can see that in both instances 15 will be printed to the console. package main func foo ( num * i32 ) { * num = 10 } func main () { var num i32 num = 15 i32 . print ( num ) // prints 15 foo ( & num ) i32 . print ( num ) // prints 10 } The code above is a pointer-version of the previous example. In this case, instead of sending num by value, we send it by reference, using the & operator. foo also changed, and it now accepts a pointer to a 32-bit integer, i.e. *i32 . After running the example, you'll notice that, this time, foo is now changing num 's value. Escape Analysis Consider the following example: package main func foo () ( pNum * i32 ) { var num i32 num = 5 // this is in the stack pNum = & num } func stackDestroyer () { var arr [ 5 ] i32 } func main () { var pNum * i32 pNum = foo () stackDestroyer () i32 . print ( * pNum ) } If we store foo 's num 's value ( 5 ) in the stack, and then we call stackDestroyer , isn't arr going to overwrite the bytes storing the 5 ? This doesn't happen, because that 5 is now in the heap. But this doesn't mean that any value being pointed to is going to be moved to the heap. For example, let's re-examine one of the examples presented in the Pointers section: package main func foo ( num * i32 ) { * num = 10 } func main () { var num i32 num = 15 i32 . print ( num ) // prints 15 foo ( & num ) i32 . print ( num ) // prints 10 } If any value being pointed to by a pointer was sent to the heap, we wouldn't be able to change num s value, which is stored in the stack; we would be changing the heap's copied value. package main func foo () ( pNum * i32 ) { var num i32 var pNum * i32 num = 5 pNum = & num } func main () { var pNum * i32 pNum = foo () i32 . print ( * pNum ) // prints 5, which is stored in the heap } Basically, in order to fix this problem, whenever a pointer needs to be returned from a function, the value it is pointing to \"escapes\" to the heap. In the example above, we can see that num 's value is going to be preserved by escaping to the heap, as we are returning a pointer to it from foo . package main func foo () ( pNum * i32 ) { var num i32 var pNum * i32 num = 5 // this is in the stack pNum = & num // the pointer will be returned, so the value is sent to the heap } func stackDestroyer () { var arr [ 5 ] i32 } func main () { var pNum * i32 pNum = foo () stackDestroyer () // if 5 does not escape, it would be destroyed by this function i32 . print ( * pNum ) // prints 5, which is stored in the heap } We can check this behavior even further in the example above. After calling foo , we call stackDestroyer , which overwrites the following 20 bytes after main 's stack frame. Yet, when we call i32.print(*pNum) , we'll see that we still have access to a 5 . This 5 is not the one created in foo , though, but a copy of it that was allocated in the heap. Control Flow Once we have the appropriate data structures for our program, we'll now need to process them. In order to do so, we need to have access to some control flow structures. Functions Functions are used to encapsulate routines that we plan to be frequently calling. In addition to encapsulating a series of expressions and statements, we can also receive input parameters and return output parameters, just like mathematical functions. package main func main () { var players [] str players = [] str { \"Richard\" , \"Mario\" , \"Edward\" } str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , players [ 0 ])) str . print ( \"=======================\" ) str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , players [ 1 ])) str . print ( \"=======================\" ) str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , players [ 2 ])) str . print ( \"=======================\" ) } For example, if we see the code above we'll notice that it seems repetitive. We can fix this by creating a function, as seen in the example below. package main func drawBox ( player str ) { str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , player )) str . print ( \"=======================\" ) } func main () { var players [] str players = [] str { \"Richard\" , \"Mario\" , \"Edward\" } drawBox ( players [ 0 ]) drawBox ( players [ 1 ]) drawBox ( players [ 2 ]) } Methods Methods are useful when we want to associate a particular function to a particular custom type (associating functions to primitive types is not allowed). This allows us to create more readable code. package main type Player struct { Name str HP i32 Mana i32 Lives i32 } type Monster struct { Name str HP i32 Mana i32 } func ( player Player ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\tLives: \\t%d\\n\\n%s\" , player . Name , player . HP , player . Mana , player . Lives , ` \u2500\u2584\u2588\u2588\u2588\u2588\u2584\u2584\u2591 \u2584\u2580\u2588\u2580\u2590\u2514\u2500\u2510\u2591\u2591 \u2588\u2584\u2590\u258c\u2584\u2588\u2584\u2518\u2588\u2588 \u2514\u2584\u2584\u2584\u2584\u2584\u2518\u2588\u2588\u2588 \u2588\u2588\u2592\u2588\u2592\u2588\u2588\u2588\u2580` )) } func ( monster Monster ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\n%s\" , monster . Name , monster . HP , monster . Mana , ` \u2572\u2572\u256d\u2501\u2501\u2501\u2501\u256e\u2572\u2572 \u256d\u256e\u2503\u2586\u2508\u2508\u2586\u2503\u256d\u256e \u2503\u2570\u252b\u25bd\u25bd\u25bd\u25bd\u2523\u256f\u2503 \u2570\u2501\u252b\u25b3\u25b3\u25b3\u25b3\u2523\u2501\u256f \u2572\u2572\u2503\u2508\u2508\u2508\u2508\u2503\u2572\u2572 \u2572\u2572\u2503\u2508\u250f\u2513\u2508\u2503\u2572\u2572 \u2594\u2594\u2570\u2501\u256f\u2570\u2501\u256f\u2594\u2594` )) } func main () { var player Player player . Name = \"Mario\" player . HP = 10 player . Mana = 10 player . Lives = 3 player . draw () var monster Monster monster . Name = \"Domo-kun\" monster . HP = 7 monster . Mana = 4 monster . draw () } The example above shows us how we can create two versions of the function draw , and the behavior of each depends on the custom type that we're using to call it. If and if/else if and if/else statements are used to execute a block of instructions only if certain condition is true or false. Behind the scenes, if and if/else statements are parsed to a series of jmp instructions internally. For example, in the case of an if statement, we will jump 0 instructions if certain predicate is true, and it will jump n instructions if the predicate is false, where n is the number of instructions in the if block of instructions. package main func main () { if true { str . print ( \"hi\" ) } str . print ( \"bye\" ) } Program 0. - Package : main Functions 0. - Function : main () () 0. - Expression : jmp ( true bool ) 1. - Expression : str . print ( \"\" str ) 2. - Expression : jmp ( true bool ) 3. - Expression : str . print ( \"\" str ) 1. - Function : * init () () In the two code snippets above we can see how an if statement is translated by the parser to a set of two jmp instructions. These jmp instructions have some meta data in them that is not shown in the second snippet: how many lines to jump if its predicate is true and how many lines to jump if the predicate is false. jmp is not meant to be used by CX programmers (it's only part of the CX base language), so you don't need to worry about it. package main type Player struct { Name str HP i32 Mana i32 Lives i32 } type Monster struct { Name str HP i32 Mana i32 } func main () { var player Player player . Name = \"Mario\" player . HP = 10 player . Mana = 10 player . Lives = 3 var monster Monster monster . Name = \"Domo-kun\" monster . HP = 7 monster . Mana = 4 if player . HP < 5 { str . print ( \"===DANGER!===\" ) } else { str . print ( \"===YOU CAN DO IT!===\" ) } if monster . HP < 10 { str . print ( sprintf ( \"===%s is bleeding!===\" , monster . Name )) } if monster . HP < 5 { str . print ( sprintf ( \"===%s is dying!===\" , monster . Name )) } if monster . HP == 0 { str . print ( sprintf ( \"===%s is dead!===\" , monster . Name )) } } Continuing with the example from the previous section (to some extent), let's use if and if/else statements to determine what messages are going to be displayed to the user. These messages represent the state of the player or the monster, depending on their hit points (HP). For loop The for loop is the only looping mechanism in CX. Just like if and if/else statements are constructed using jmp statements, for loop statements are also constructed the same way. package main func main () { for c := 0 ; c < 10 ; c ++ { i32 . print ( c ) } } Program 0. - Package : main Functions 0. - Function : main () () 0. - Declaration : c i32 1. - Expression : c i32 = identity ( 0 i32 ) 2. - Expression : * lcl_0 bool = lt ( c i32 , 10 i32 ) 3. - Expression : jmp ( * lcl_0 bool ) 4. - Expression : i32 . print ( c i32 ) 5. - Declaration : c i32 6. - Expression : c i32 = i32 . add ( c i32 , 1 i32 ) 7. - Expression : jmp ( true bool ) 1. - Function : * init () () The code snippets above illustrate how a for loop that counts from 0 to 9 is translated to a set of of jmp instructions. package main type Player struct { Name str HP i32 Mana i32 Lives i32 } type Monster struct { Name str HP i32 Mana i32 } func ( player Player ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\tLives: \\t%d\\n\\n%s\" , player . Name , player . HP , player . Mana , player . Lives , ` \u2500\u2584\u2588\u2588\u2588\u2588\u2584\u2584\u2591 \u2584\u2580\u2588\u2580\u2590\u2514\u2500\u2510\u2591\u2591 \u2588\u2584\u2590\u258c\u2584\u2588\u2584\u2518\u2588\u2588 \u2514\u2584\u2584\u2584\u2584\u2584\u2518\u2588\u2588\u2588 \u2588\u2588\u2592\u2588\u2592\u2588\u2588\u2588\u2580` )) } func ( monster Monster ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\n%s\" , monster . Name , monster . HP , monster . Mana , ` \u2572\u2572\u256d\u2501\u2501\u2501\u2501\u256e\u2572\u2572 \u256d\u256e\u2503\u2586\u2508\u2508\u2586\u2503\u256d\u256e \u2503\u2570\u252b\u25bd\u25bd\u25bd\u25bd\u2523\u256f\u2503 \u2570\u2501\u252b\u25b3\u25b3\u25b3\u25b3\u2523\u2501\u256f \u2572\u2572\u2503\u2508\u2508\u2508\u2508\u2503\u2572\u2572 \u2572\u2572\u2503\u2508\u250f\u2513\u2508\u2503\u2572\u2572 \u2594\u2594\u2570\u2501\u256f\u2570\u2501\u256f\u2594\u2594` )) } func ( player Player ) attack ( cmd str , monster * Monster ) { if bool . or ( cmd == \"M\" , cmd == \"m\" ) { var dmg i32 dmg = i32 . rand ( 1 , 4 ) ( * monster ). HP = ( * monster ). HP - dmg printf ( \"'%s' suffered a magic attack. Lost %d HP. New HP is %d\\n\" , ( * monster ). Name , dmg , ( * monster ). HP ) } else { var dmg i32 dmg = i32 . rand ( 1 , 2 ) ( * monster ). HP = ( * monster ). HP - dmg printf ( \"'%s' suffered a physical attack. Lost %d HP. New HP is %d\\n\" , ( * monster ). Name , dmg , ( * monster ). HP ) } } func ( monster Monster ) attack ( cmd str , player * Player ) { var dmg i32 dmg = i32 . rand ( 1 , 5 ) ( * player ). HP = ( * player ). HP - dmg printf ( \"'%s' suffered a physical attack. Lost %d HP. New HP is %d\\n\" , ( * player ). Name , dmg , ( * player ). HP ) } func battleStatus ( player Player , monster Monster ) { if player . HP < 5 { str . print ( \"===DANGER!===\" ) } else { str . print ( \"===YOU CAN DO IT!===\" ) } if player . HP == 0 { str . print ( \"===YOU DIED===\" ) } if monster . HP < 10 && monster . HP >= 5 { str . print ( sprintf ( \"===%s is bleeding!===\" , monster . Name )) } if monster . HP < 5 && monster . HP > 0 { str . print ( sprintf ( \"===%s is dying!===\" , monster . Name )) } if monster . HP <= 0 { str . print ( sprintf ( \"===%s is dead!===\" , monster . Name )) } } func main () { var player Player player . Name = \"Mario\" player . HP = 10 player . Mana = 10 player . Lives = 3 var monster Monster monster . Name = \"Domo-kun\" monster . HP = 7 monster . Mana = 4 player . draw () monster . draw () for true { if player . HP < 1 || monster . HP < 1 { return } printf ( \"Command? (M)agic; (P)hysical; (E)xit\\t\" ) var cmd str cmd = read () if cmd == \"E\" || cmd == \"e\" { return } player . draw () monster . draw () player . attack ( cmd , & monster ) monster . attack ( cmd , & player ) battleStatus ( player , monster ) } } Lastly, we can see how we use a for loop to create something similar to a REPL for the program that we have been building in the last few sections. Go-to The last control flow mechanism is go-to , which is achieved through the goto statement. package main func main () ( out i32 ) { beginning : printf ( \"What animal do you like the most: (C)at; (D)og; (P)igeon\\n\" ) var cmd str cmd = read () if cmd == \"C\" || cmd == \"c\" { goto cat } if cmd == \"D\" || cmd == \"d\" { goto dog } if cmd == \"P\" || cmd == \"p\" { goto pigeon } cat : str . print ( \"meow\" ) goto beginning dog : str . print ( \"woof\" ) goto beginning pigeon : str . print ( \"tweet\" ) goto beginning } The program above creates an infinite loop by using goto s. The loop will keep asking the user to input commands, and will jump to certain expression depending on the command. Affordances","title":"Runtime"},{"location":"software/cx/basics-runtime/#runtime","text":"The previous section presents the language features from a syntax perspective. In this section we'll cover what's the logic behind these features: how they interact with other elements in your program, and what are the intrinsic capabilities of each of these features.","title":"Runtime"},{"location":"software/cx/basics-runtime/#packages","text":"Packages are CX's mechanism for better organizing your code. Although it is theoretically possible to store a big project in a single package, the code will most likely become very hard to understand. In CX the programmer is encouraged to place the files that define the code of a package in separate directory. Any subdirectory in a package's directory should also contain only source code files that define elements of the same package. Nevertheless, CX will not throw any error if you don't follow this way of laying out your source files. In fact, you can declare different packages in a single source code file.","title":"Packages"},{"location":"software/cx/basics-runtime/#data-structures","text":"Data structures are particular arrangements of bytes that the language interprets and stores in special ways. The most basic data structures represent basic data, such as numbers and character strings, but these basic types can be used to construct more complex data types.","title":"Data Structures"},{"location":"software/cx/basics-runtime/#literals","text":"A literal is any data structure that is not being referenced by any variable yet. For example: 1 , true , []i32{1, 2, 3} , Point{x: 10, y: 20} . It's important to make a distinction, particularly with arrays , slices and struct instances . package main type Point struct { x i32 y i32 } func main () { var p1 Point p1 . x = 10 p1 . y = 20 p2 := Point { x : 11 , y : 21 } i32 . print ( p2 . x ) i32 . print ( p2 . y ) } In the example above we are creating two instances of the Point type. The first method we use does not involve struct literals, as a variable of that type is first created and then initialized. In the second case ( p2 ), the full struct instance is first created. CX creates an anonymous struct instance as soon as it encounters Points{x: 11, y: 21} , and then it proceeds to assign that literal to the p2 variable, using short variable declarations . package main func main () { var arr1 [ 3 ] i32 arr1 [ 0 ] = 1 arr1 [ 1 ] = 2 arr1 [ 2 ] = 3 arr2 := [ 3 ] i32 { 10 , 20 , 30 } } package main func main () { var slc1 [] i32 slc1 = append ( slc1 , 1 ) slc1 = append ( slc1 , 2 ) slc1 = append ( slc1 , 3 ) slc2 := [] i32 { 10 , 20 , 30 } } Similarly, in the two examples above we can see how we can declare array and slice variables and then we initialize them. In the case of arrays, we use the bracket notation, and for slices we have to use append , as slc1 starts with a size and capacity of 0. In the cases of arr2 and slc2 , we use literals to initialize them more conveniently. Regarding numbers, you need to be aware that implicit casting does not exist in CX. This means that the number 34 cannot be assigned to a variable of type i64 . In order to assign it, you need to either parse it using the native function i32.i64 or you can create a 64-bit integer literal. To create a number literal of a type other than i32 , you can use different suffixes: B , L and D , for byte , i64 (long) and f64 , respectively. So, assuming foo is of type i64 , you can do this assignment: foo = 34L .","title":"Literals"},{"location":"software/cx/basics-runtime/#variables","text":"When CX compiles a program, it knows how many bytes need to be reserved in the stack for each of the functions. CX can know this thanks to variable declarations. package main type Point struct { x i32 y i32 } func foo ( inp Point ) { var test1 i64 var test2 bool } func main () { var test3 i32 var test4 f32 } The two functions declared in the example above are going to reserve 17 and 8 bytes in the stack, respectively. In the case of the first function, foo needs to reserve space for an input parameter of type Point , which requires 8 bytes (because of the two i32 fields), and two local variables: one 64-bit integer that requires 8 bytes and a Boolean that requires a single byte. In the case of main , CX needs to reserve bytes for two local variables: a 32-bit integer and a single-precision floating point number, where each of them require 4 bytes. package main var global1 i32 func main () { var local i32 } Local variables are different than global variables. In order for globals to have a global scope they need to be allocated in a different memory segment than local variables. This different memory segment does not shrink or get bigger like the stack. This means that any global variable is going to be kept \"alive\" as long as the program keeps being executed. A global scope means that variables of this type are accessible to any function declared in the same package where the variable is declared, and to any function of other packages that are importing this package. package main func main () { var foo i32 i32 . print ( foo ) // prints 0 } In CX every variable is going to initially point to a nil value. This nil value is basically a series of one or more zeroes, depending on the size of the data type of a given variable. For example, in the code above we see that we have declared a variable of type i32 and we immediately print its value without initializing it. This CX program will print 0, as the value of foo is [0 0 0 0] in the stack (4 zeroes, as a 32-bit integer is represented by 4 bytes). In the case of data types that point to variable-sized structures, such as slices or character strings, these are initialized to a nil pointer, which is represented by 4 zeroed bytes. This nil pointer is located in the heap memory segment, instead of the stack.","title":"Variables"},{"location":"software/cx/basics-runtime/#primitive-types","text":"There are seven primitive types in CX: bool , str , byte , i32 , i64 , f32 , and f64 . These types can be used to construct other more complex types, as will be seen in the next sections. bool and byte both require a single byte to represent their values. In the case of bool , there are only two possible values: true or false . In the case of byte you can represent up to 256 values, which range from 0 to 255. Next in size, we have i32 and f32 , where both of them require 4 bytes, and then we have i64 and f64 , which require 8 bytes each. Now, strings are special as they are static and dynamic sized at the same time. If you have a look at how a variable of type str reserves memory in the stack, you'll see that it requires 4 bytes, regardless of what text it's pointing to. The explanation behind this is that any str in CX actually behaves like a pointer behind the scenes, and the actual string gets stored in the heap memory segment. package main func main () { var foo str foo = str . concat ( \"Hello, \" , \"World!\" ) foo = \"Hi\" } When CX compiles the example above, three strings are first stored in the data memory segment (just like global variables, as these strings are constants, memory-wise): \"Hello, \" , \"World\" and \"Hi\" . When the program is executed, str.concat is called, which creates a new string by concatenating \"Hello, \" and \"World!\" , and this new character string is allocated in the heap memory segment. Then foo is assigned only the address of this new character string. Then we immediately re-assign foo with the address of \"Hi\" . This means that foo was first assigned a memory address located in the data memory segment, and then it was assigned an address located in the heap.","title":"Primitive types"},{"location":"software/cx/basics-runtime/#arrays","text":"Arrays, as in other programming languages, are used to create collections of data structures. These data structures can be primitive types, custom types or even arrays or slices. package main type Point struct { x i32 y i32 } func main () { var [ 5 ] i32 var [ 5 ] Point } In the example above, we're creating two arrays, one of a primitive type and the other one of a custom type. CX reserves memory for these arrays in the stack as soon as the function that contains them is called. In this case, 60 bytes are going to be reserved for main as soon as the program starts its execution, as main acts as the program's entry point. You need to be careful with arrays, as those can easily fill up your memory, especially with multi-dimensional arrays (or matrices). Also, another point to consider is performance. While accessing arrays is almost as fast as accessing an atomic variable, arrays can be troublesome when being sent/received as to/from functions. The reason behind this is that an array needs to be copied whenever it is sent to another function. If you're working with arrays of millions of elements and you need to be sending that arrays millions of times to another function, it's going to impact your program's performance a lot. A way to avoid this is to either use pointers to arrays or slices.","title":"Arrays"},{"location":"software/cx/basics-runtime/#slices","text":"Dynamic arrays don't exist in CX. This means that the following code is not a valid CX program: package main func main () { var size i32 size = 13 var arr [ size ] // this is not valid } If you need an array that can grow in size as required, you need to use slices. Behind the scenes, slices are just arrays with some extra features. First of all, any slice in CX goes directly to the heap, as it's a data structure that is going to be changing in size. In contrast, arrays are always going to be stored in the stack, unless we're handling pointers to arrays. However, this behavior may change in the future, when CX's escape analysis mechanism improves (for example, the compiler can determine if an array is never going to change its size, and decide to keep it in the stack). The second characteristic of slices in CX is how they change their size. Any slice, when it's first declared, starts with a size and capacity of 0. The size represents how many elements are in a given slice, while the capacity represents how many elements can be allocated in that slice without having to be relocated in the heap. package main func main () { var slc [] i32 slc = append ( slc , 1 ) slc = append ( slc , 2 ) slc = append ( slc , 3 ) slc = append ( slc , 4 ) } In the code above we can see how we declare a slice and then we initialize it using the append function. After all the append s, we'll end up with a slice of size 4 and capacity 4, and this append ing process will create the following objects in the heap: [ 0 0 0 0 0 12 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 16 0 0 0 2 0 0 0 2 0 0 0 1 0 0 0 2 0 0 0 0 0 0 0 0 24 0 0 0 4 0 0 0 4 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 ] First, the slice slc starts with 0 objects in it; it is pointing to nil . Then, after the first append , the object [0 0 0 0 0 12 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0] is allocated to the heap. The first five bytes are used by CX's garbage collector. The next 4 bytes indicate the size of the object, and the remaining bytes are the actual slice slc . The first four bytes of slc tell us its current size, while the next four tell us its capacity. The remaining bytes of this object are the elements of the slice. The following object, [0 0 0 0 0 16 0 0 0 2 0 0 0 2 0 0 0 1 0 0 0 2 0 0 0] , shows now a size of 2 and a capacity of 2, with the 32-bit integers 1 and 2 as its elements. The last object, 0 0 0 0 0 24 0 0 0 4 0 0 0 4 0 0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 , needs careful attention. We can see that our objects jumped from size 1 to 2 and finally 4. The same happened to its capacity, and the containing elements are now 1 , 2 , 3 and 4 . What happened to the slice of size 3 and capacity 3? First of all, capacities are increased by getting doubled each time the size of an object is greater than its capacity, so we would never get a slice of capacity 4 by following this method. Next, we need to think on what is capacity used for. Slices are just arrays, which means that they can't be resized. The dynamic nature of slices is emulated by copying the full slice to somewhere else in memory, but with a greater capacity. However, this will only happen if adding a new element to the existing slice would overflow it. This is why slices keep track of two metrics: size and capacity , i.e. how many actual elements are in the slice, and how many elements the currently allocated slice can hold, respectively. package main func main () { var arr1 [ 1 ] i32 arr1 [ 0 ] = 1 // add the first value var arr2 [ 2 ] i32 // double the size arr2 [ 0 ] = arr1 [ 0 ] // copy previous array arr2 [ 1 ] = 2 // add the second value var arr3 [ 4 ] i32 // double the size arr3 [ 0 ] = arr2 [ 0 ] // copy previous array arr3 [ 1 ] = arr2 [ 1 ] // copy previous array arr3 [ 2 ] = 3 // add the third value arr3 [ 3 ] = 4 // add the fourth value } The example above shows the behavior of the slice in the previous example, but using arrays.","title":"Slices"},{"location":"software/cx/basics-runtime/#structures","text":"Structures are CX's mechanism for creating custom types, as in many other C-like languages. Structures are basically a grouping of other primitive or custom types (called fields ) that together create another type of data structure. For example, a point can be defined by its coordinates in a two-dimensional space. In order to create a type Point , you can use a structure that contains two fields of type i32 , one for x and another for y , as in the example below. package main type Point struct { x i32 y i32 } func main () { var p Point p . x = 10 p . y = 20 } Whenever an instance of a structure is created by either declaring a variable of that type or by creating a literal of that type, CX reserves memory to hold space for all the fields defined in the structure declaration. Like in C, the bytes are reserved depending on the order of the fields in the structure declaration. package main type struct1 struct { field1 bool field2 i32 field3 i64 } type struct2 struct { field1 i64 field2 bool field3 i32 } func main () { var s1 struct1 var s2 struct2 } For example, in the code above a call to main will reserve a total of 26 bytes in the stack. In the case of the first struct instance, the first byte is going to represent field1 of type bool , the next four bytes are going to represent field2 of type i32 , and the final 8 bytes are going to represent field3 of type i64 . In the case of the next struct instance, the first eight bytes represent an i64 field so, although both struct instances contain the same number of fields and of the same type, the byte layout changes.","title":"Structures"},{"location":"software/cx/basics-runtime/#pointers","text":"Sometimes it's useful to pass variables to functions by reference instead of by value. package main import \"time\" func foo ( nums [ 100 ][ 100 ] i32 ) { // do something with nums } func main () { var start i64 var end i64 var nums [ 100 ][ 100 ] i32 start = time . UnixMilli () for c := 0 ; c < 10000 ; c ++ { foo ( nums ) } end = time . UnixMilli () printf ( \"elapsed time: \\t%d milliseconds\\n\" , end - start ) } The example above is very inefficient, as CX is going to be sending a 10,000 element matrix to foo 10,000 times. Every time foo is called, every byte of that matrix needs to be copied for foo . In my computer the example above takes around 638 milliseconds to run. package main import \"time\" func foo ( nums * [ 100 ][ 100 ] i32 ) { // do something with nums } func main () { var start i64 var end i64 var nums [ 100 ][ 100 ] i32 start = time . UnixMilli () for c := 0 ; c < 10000 ; c ++ { foo ( & nums ) } end = time . UnixMilli () printf ( \"elapsed time: \\t%d milliseconds\\n\" , end - start ) } A new version of the last program is shown above. In contrast to the last program, the code above sends a pointer to the matrix to foo . A pointer in CX uses only 4 bytes (in the future, pointers will use 8 bytes in 64-bit systems and 4 bytes in 32-bit systems), so instead of copying 10,000 bytes, we only copy 4 bytes to foo every time we call it. This version of the program takes only 3 milliseconds to run in my computer. package main func foo ( inp i32 ) { inp = 10 } func main () { var num i32 num = 15 i32 . print ( num ) // prints 15 foo ( num ) i32 . print ( num ) // prints 15 } In the example above, we send num to foo , and then we re-assign the input's value to 10 . If we print the value of num before and after calling foo , we can see that in both instances 15 will be printed to the console. package main func foo ( num * i32 ) { * num = 10 } func main () { var num i32 num = 15 i32 . print ( num ) // prints 15 foo ( & num ) i32 . print ( num ) // prints 10 } The code above is a pointer-version of the previous example. In this case, instead of sending num by value, we send it by reference, using the & operator. foo also changed, and it now accepts a pointer to a 32-bit integer, i.e. *i32 . After running the example, you'll notice that, this time, foo is now changing num 's value.","title":"Pointers"},{"location":"software/cx/basics-runtime/#escape-analysis","text":"Consider the following example: package main func foo () ( pNum * i32 ) { var num i32 num = 5 // this is in the stack pNum = & num } func stackDestroyer () { var arr [ 5 ] i32 } func main () { var pNum * i32 pNum = foo () stackDestroyer () i32 . print ( * pNum ) } If we store foo 's num 's value ( 5 ) in the stack, and then we call stackDestroyer , isn't arr going to overwrite the bytes storing the 5 ? This doesn't happen, because that 5 is now in the heap. But this doesn't mean that any value being pointed to is going to be moved to the heap. For example, let's re-examine one of the examples presented in the Pointers section: package main func foo ( num * i32 ) { * num = 10 } func main () { var num i32 num = 15 i32 . print ( num ) // prints 15 foo ( & num ) i32 . print ( num ) // prints 10 } If any value being pointed to by a pointer was sent to the heap, we wouldn't be able to change num s value, which is stored in the stack; we would be changing the heap's copied value. package main func foo () ( pNum * i32 ) { var num i32 var pNum * i32 num = 5 pNum = & num } func main () { var pNum * i32 pNum = foo () i32 . print ( * pNum ) // prints 5, which is stored in the heap } Basically, in order to fix this problem, whenever a pointer needs to be returned from a function, the value it is pointing to \"escapes\" to the heap. In the example above, we can see that num 's value is going to be preserved by escaping to the heap, as we are returning a pointer to it from foo . package main func foo () ( pNum * i32 ) { var num i32 var pNum * i32 num = 5 // this is in the stack pNum = & num // the pointer will be returned, so the value is sent to the heap } func stackDestroyer () { var arr [ 5 ] i32 } func main () { var pNum * i32 pNum = foo () stackDestroyer () // if 5 does not escape, it would be destroyed by this function i32 . print ( * pNum ) // prints 5, which is stored in the heap } We can check this behavior even further in the example above. After calling foo , we call stackDestroyer , which overwrites the following 20 bytes after main 's stack frame. Yet, when we call i32.print(*pNum) , we'll see that we still have access to a 5 . This 5 is not the one created in foo , though, but a copy of it that was allocated in the heap.","title":"Escape Analysis"},{"location":"software/cx/basics-runtime/#control-flow","text":"Once we have the appropriate data structures for our program, we'll now need to process them. In order to do so, we need to have access to some control flow structures.","title":"Control Flow"},{"location":"software/cx/basics-runtime/#functions","text":"Functions are used to encapsulate routines that we plan to be frequently calling. In addition to encapsulating a series of expressions and statements, we can also receive input parameters and return output parameters, just like mathematical functions. package main func main () { var players [] str players = [] str { \"Richard\" , \"Mario\" , \"Edward\" } str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , players [ 0 ])) str . print ( \"=======================\" ) str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , players [ 1 ])) str . print ( \"=======================\" ) str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , players [ 2 ])) str . print ( \"=======================\" ) } For example, if we see the code above we'll notice that it seems repetitive. We can fix this by creating a function, as seen in the example below. package main func drawBox ( player str ) { str . print ( \"=======================\" ) str . print ( str . concat ( \"Name: \\t\" , player )) str . print ( \"=======================\" ) } func main () { var players [] str players = [] str { \"Richard\" , \"Mario\" , \"Edward\" } drawBox ( players [ 0 ]) drawBox ( players [ 1 ]) drawBox ( players [ 2 ]) }","title":"Functions"},{"location":"software/cx/basics-runtime/#methods","text":"Methods are useful when we want to associate a particular function to a particular custom type (associating functions to primitive types is not allowed). This allows us to create more readable code. package main type Player struct { Name str HP i32 Mana i32 Lives i32 } type Monster struct { Name str HP i32 Mana i32 } func ( player Player ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\tLives: \\t%d\\n\\n%s\" , player . Name , player . HP , player . Mana , player . Lives , ` \u2500\u2584\u2588\u2588\u2588\u2588\u2584\u2584\u2591 \u2584\u2580\u2588\u2580\u2590\u2514\u2500\u2510\u2591\u2591 \u2588\u2584\u2590\u258c\u2584\u2588\u2584\u2518\u2588\u2588 \u2514\u2584\u2584\u2584\u2584\u2584\u2518\u2588\u2588\u2588 \u2588\u2588\u2592\u2588\u2592\u2588\u2588\u2588\u2580` )) } func ( monster Monster ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\n%s\" , monster . Name , monster . HP , monster . Mana , ` \u2572\u2572\u256d\u2501\u2501\u2501\u2501\u256e\u2572\u2572 \u256d\u256e\u2503\u2586\u2508\u2508\u2586\u2503\u256d\u256e \u2503\u2570\u252b\u25bd\u25bd\u25bd\u25bd\u2523\u256f\u2503 \u2570\u2501\u252b\u25b3\u25b3\u25b3\u25b3\u2523\u2501\u256f \u2572\u2572\u2503\u2508\u2508\u2508\u2508\u2503\u2572\u2572 \u2572\u2572\u2503\u2508\u250f\u2513\u2508\u2503\u2572\u2572 \u2594\u2594\u2570\u2501\u256f\u2570\u2501\u256f\u2594\u2594` )) } func main () { var player Player player . Name = \"Mario\" player . HP = 10 player . Mana = 10 player . Lives = 3 player . draw () var monster Monster monster . Name = \"Domo-kun\" monster . HP = 7 monster . Mana = 4 monster . draw () } The example above shows us how we can create two versions of the function draw , and the behavior of each depends on the custom type that we're using to call it.","title":"Methods"},{"location":"software/cx/basics-runtime/#if-and-ifelse","text":"if and if/else statements are used to execute a block of instructions only if certain condition is true or false. Behind the scenes, if and if/else statements are parsed to a series of jmp instructions internally. For example, in the case of an if statement, we will jump 0 instructions if certain predicate is true, and it will jump n instructions if the predicate is false, where n is the number of instructions in the if block of instructions. package main func main () { if true { str . print ( \"hi\" ) } str . print ( \"bye\" ) } Program 0. - Package : main Functions 0. - Function : main () () 0. - Expression : jmp ( true bool ) 1. - Expression : str . print ( \"\" str ) 2. - Expression : jmp ( true bool ) 3. - Expression : str . print ( \"\" str ) 1. - Function : * init () () In the two code snippets above we can see how an if statement is translated by the parser to a set of two jmp instructions. These jmp instructions have some meta data in them that is not shown in the second snippet: how many lines to jump if its predicate is true and how many lines to jump if the predicate is false. jmp is not meant to be used by CX programmers (it's only part of the CX base language), so you don't need to worry about it. package main type Player struct { Name str HP i32 Mana i32 Lives i32 } type Monster struct { Name str HP i32 Mana i32 } func main () { var player Player player . Name = \"Mario\" player . HP = 10 player . Mana = 10 player . Lives = 3 var monster Monster monster . Name = \"Domo-kun\" monster . HP = 7 monster . Mana = 4 if player . HP < 5 { str . print ( \"===DANGER!===\" ) } else { str . print ( \"===YOU CAN DO IT!===\" ) } if monster . HP < 10 { str . print ( sprintf ( \"===%s is bleeding!===\" , monster . Name )) } if monster . HP < 5 { str . print ( sprintf ( \"===%s is dying!===\" , monster . Name )) } if monster . HP == 0 { str . print ( sprintf ( \"===%s is dead!===\" , monster . Name )) } } Continuing with the example from the previous section (to some extent), let's use if and if/else statements to determine what messages are going to be displayed to the user. These messages represent the state of the player or the monster, depending on their hit points (HP).","title":"If and if/else"},{"location":"software/cx/basics-runtime/#for-loop","text":"The for loop is the only looping mechanism in CX. Just like if and if/else statements are constructed using jmp statements, for loop statements are also constructed the same way. package main func main () { for c := 0 ; c < 10 ; c ++ { i32 . print ( c ) } } Program 0. - Package : main Functions 0. - Function : main () () 0. - Declaration : c i32 1. - Expression : c i32 = identity ( 0 i32 ) 2. - Expression : * lcl_0 bool = lt ( c i32 , 10 i32 ) 3. - Expression : jmp ( * lcl_0 bool ) 4. - Expression : i32 . print ( c i32 ) 5. - Declaration : c i32 6. - Expression : c i32 = i32 . add ( c i32 , 1 i32 ) 7. - Expression : jmp ( true bool ) 1. - Function : * init () () The code snippets above illustrate how a for loop that counts from 0 to 9 is translated to a set of of jmp instructions. package main type Player struct { Name str HP i32 Mana i32 Lives i32 } type Monster struct { Name str HP i32 Mana i32 } func ( player Player ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\tLives: \\t%d\\n\\n%s\" , player . Name , player . HP , player . Mana , player . Lives , ` \u2500\u2584\u2588\u2588\u2588\u2588\u2584\u2584\u2591 \u2584\u2580\u2588\u2580\u2590\u2514\u2500\u2510\u2591\u2591 \u2588\u2584\u2590\u258c\u2584\u2588\u2584\u2518\u2588\u2588 \u2514\u2584\u2584\u2584\u2584\u2584\u2518\u2588\u2588\u2588 \u2588\u2588\u2592\u2588\u2592\u2588\u2588\u2588\u2580` )) } func ( monster Monster ) draw () { str . print ( sprintf ( \"\\n\\tName: \\t%s\\n\\tHP: \\t%d\\n\\tMana: \\t%d\\n\\n%s\" , monster . Name , monster . HP , monster . Mana , ` \u2572\u2572\u256d\u2501\u2501\u2501\u2501\u256e\u2572\u2572 \u256d\u256e\u2503\u2586\u2508\u2508\u2586\u2503\u256d\u256e \u2503\u2570\u252b\u25bd\u25bd\u25bd\u25bd\u2523\u256f\u2503 \u2570\u2501\u252b\u25b3\u25b3\u25b3\u25b3\u2523\u2501\u256f \u2572\u2572\u2503\u2508\u2508\u2508\u2508\u2503\u2572\u2572 \u2572\u2572\u2503\u2508\u250f\u2513\u2508\u2503\u2572\u2572 \u2594\u2594\u2570\u2501\u256f\u2570\u2501\u256f\u2594\u2594` )) } func ( player Player ) attack ( cmd str , monster * Monster ) { if bool . or ( cmd == \"M\" , cmd == \"m\" ) { var dmg i32 dmg = i32 . rand ( 1 , 4 ) ( * monster ). HP = ( * monster ). HP - dmg printf ( \"'%s' suffered a magic attack. Lost %d HP. New HP is %d\\n\" , ( * monster ). Name , dmg , ( * monster ). HP ) } else { var dmg i32 dmg = i32 . rand ( 1 , 2 ) ( * monster ). HP = ( * monster ). HP - dmg printf ( \"'%s' suffered a physical attack. Lost %d HP. New HP is %d\\n\" , ( * monster ). Name , dmg , ( * monster ). HP ) } } func ( monster Monster ) attack ( cmd str , player * Player ) { var dmg i32 dmg = i32 . rand ( 1 , 5 ) ( * player ). HP = ( * player ). HP - dmg printf ( \"'%s' suffered a physical attack. Lost %d HP. New HP is %d\\n\" , ( * player ). Name , dmg , ( * player ). HP ) } func battleStatus ( player Player , monster Monster ) { if player . HP < 5 { str . print ( \"===DANGER!===\" ) } else { str . print ( \"===YOU CAN DO IT!===\" ) } if player . HP == 0 { str . print ( \"===YOU DIED===\" ) } if monster . HP < 10 && monster . HP >= 5 { str . print ( sprintf ( \"===%s is bleeding!===\" , monster . Name )) } if monster . HP < 5 && monster . HP > 0 { str . print ( sprintf ( \"===%s is dying!===\" , monster . Name )) } if monster . HP <= 0 { str . print ( sprintf ( \"===%s is dead!===\" , monster . Name )) } } func main () { var player Player player . Name = \"Mario\" player . HP = 10 player . Mana = 10 player . Lives = 3 var monster Monster monster . Name = \"Domo-kun\" monster . HP = 7 monster . Mana = 4 player . draw () monster . draw () for true { if player . HP < 1 || monster . HP < 1 { return } printf ( \"Command? (M)agic; (P)hysical; (E)xit\\t\" ) var cmd str cmd = read () if cmd == \"E\" || cmd == \"e\" { return } player . draw () monster . draw () player . attack ( cmd , & monster ) monster . attack ( cmd , & player ) battleStatus ( player , monster ) } } Lastly, we can see how we use a for loop to create something similar to a REPL for the program that we have been building in the last few sections.","title":"For loop"},{"location":"software/cx/basics-runtime/#go-to","text":"The last control flow mechanism is go-to , which is achieved through the goto statement. package main func main () ( out i32 ) { beginning : printf ( \"What animal do you like the most: (C)at; (D)og; (P)igeon\\n\" ) var cmd str cmd = read () if cmd == \"C\" || cmd == \"c\" { goto cat } if cmd == \"D\" || cmd == \"d\" { goto dog } if cmd == \"P\" || cmd == \"p\" { goto pigeon } cat : str . print ( \"meow\" ) goto beginning dog : str . print ( \"woof\" ) goto beginning pigeon : str . print ( \"tweet\" ) goto beginning } The program above creates an infinite loop by using goto s. The loop will keep asking the user to input commands, and will jump to certain expression depending on the command.","title":"Go-to"},{"location":"software/cx/basics-runtime/#affordances","text":"","title":"Affordances"},{"location":"software/cx/basics-syntax/","text":"Syntax In this section, we're going to have a look at how a CX program looks like. Basically, the following sections are not going to discuss about the logic behind the various CX constructs, i.e. how they behave; we're only going to see how they look like. Comments Some of the code snippets that follow have comments in them, i.e., blocks of text that are not actually \"run\" by the CX compiler or interpreter. Just like in C, Golang and many other programming languages, single line comments are created by placing double slashes (//) before the text being commented. For example: // Example of adding two 32 bit integers in CX i32 . add ( 3 , 4 ) // This will be ignored // End of the program Mult-line comments are opened by writing slash-asterisk (/*), and are closed by writing asterisk-slash (*/). /* This code won't be executed str.print(\"Hello world!\") */ Declarations A declaration refers to a named element in a program's structure, which are described using other constructs, such as expressions and other statements. For example: a function can be referred by its name and it's constructed by expressions and local variable declarations. Allowed Names Any name that satisfies the PCRE regular expression [_a-zA-Z][_a-zA-Z0-9]* is allowed as an identifier for a declared element. In other words, an identifier can start with an underscore ( _ ) or any lowercase or uppercase letter, and can be followed by 0 or more underscores or lowercase or uppercase letters, and any number from 0 to 9. Strict Type System One of CX's goals is to provide a very strict type system. The purpose of this is to reduce runtime errors as much as possible. In order to achieve this goal, many of CX's native functions are constrained to a single type signature. For example, if you want to add two 32-bit integers, you'd need to use i32.add . In contrast, if you want to add two 64-bit integers, you'd use i64.add . These functions can help the programmer to ensure that a particular data type is being received or sent during a process. If the programmer doesn't want to use those type-specific functions, CX still provides type inference in some cases. For example, instead of writing i32.add(5, 5) you can just write 5 + 5 . In this case, CX is going to see that you're using 32-bit integers, and the parser is going to transform that expression to i32.add(5, 5) . However, if you try to do 5 + 5L , i.e. if you try to add a 32-bit integer to a 64-bit integer, CX will throw a compile-time error because you're mixing types. The proper way to handle types in CX is to explicitly parse everything. This way one can be sure that you're always going to be handling the desired type. So, retaking the previous example, you'd need to parse one of them to match the other's type, either i32.i64(5) + 5L or 5 + i64.i32(5L) . Primitive Types There are seven primitive types in CX: bool , str , byte , i32 , i64 , f32 , and f64 . Those represent Booleans ( true or false ), character strings, bytes, 32-bit integers, 64-bit integers, single precision and double precision floating-point numbers, respectively. Global variables Global variables are different from local variables regarding scope. Global variables are available to any function defined in a package, and to any package that is importing the package that contains that global declaration. An example of some global variables is shown below. package main var global1 i32 var global2 i64 func foo () { i32 . print ( global1 ) i64 . print ( global2 ) } func main () { global1 = 5 global2 = 5 L i32 . print ( global1 ) i64 . print ( global2 ) } In the example above we can see that both the main and foo functions are printing the values of the two global variables defined. They are going to print the same values, as they are referring to the same variables. Local variables In contrast to global variables, local variables are constrained to the function where they are declared. This means that is not possible for another function to call a variable defined in another function. package main func foo () { i32 . print ( local ) // this expression will throw a compile-time error } func main () { var local i32 local = 5 i32 . print ( 5 ) foo () } If you try to run the example above, CX will throw an error similar to this: error: examples/testing.cx:4 identifier 'local' does not exist , so CX will not even try to run that program. If we could de-activate CX's compile-time type checking, and the program above could make it to the runtime, CX would not print 5 when running foo() , as that function is unaware of that variable. Arrays Arrays (or vectors) and multi-dimensional arrays (or matrices) can be declared using a syntax similar to C's. package main type Point struct { x i32 y i32 } func main () { var arr1 [ 5 ] i32 var arr2 [ 5 ] Point var arr3 [ 2 ][ 2 ] f32 arr1 [ 0 ] = 10 arr2 [ 1 ] = 20 } In the example above we see the declaration of an array of 5 elements of type i32 , followed by an array of the same cardinality but of type Point , which is a custom type. Custom types are discussed in a later section. Lastly, we see an example of a 2x2 matrix of type f32 . Lastly, we can see how we can initialize an array using the bracket notation, e.g. arr1[0] = 10 . Slices Golang-like slices exist in CX (dynamic arrays). Slices are declared similarly to arrays, with the only difference that the size is omitted. package main type Point struct { x i32 y i32 } func main () { var slc1 [] i32 var slc2 [] Point var slc3 [][] f32 } Slices, unlike arrays, cannot be directly initialized using the bracket notation (unless you use the native function make first). You can use the bracket notation to reassign values to a slice, once an element associated to the index that you want to use already exists, as shown in the example below. package main func main () { var slc [] i32 slc = append ( slc , 1 ) slc = append ( slc , 2 ) slc [ 0 ] = 10 slc [ 2 ] = 30 // This is not allowed, as len(slc) == 2, not 3 } As this behavior is more related to the logic behind slices, it is further explained in the Runtime->Data Structures->Slices section. Literals A literal is any data structure that is not being referenced by any variable yet. For example: 1 , true , []i32{1, 2, 3} , Point{x: 10, y: 20} . Particularly, it is worth noting the cases of array, slice and struct literals. package main type Point struct { x i32 y i32 } func main () { var a Point var b [ 5 ] i32 var c [] i32 a = Point { x : 10 , y : 20 } b = [ 5 ] i32 { 1 , 2 , 3 , 4 , 5 } c = [] i32 { 100 , 200 , 300 } } In the example above we can see examples of struct ( Point{x: 10, y: 20} ), array ( [5]i32{1, 2, 3, 4, 5} ), and slice ( []i32{100, 200, 300} ) literals, in that order. These literals exist to simplify the creation of such data structures. Functions Functions in CX are similar in syntax to functions in Go. The only exception is that named outputs are enforced at the moment (this will most likely change in the future). package main func foo () { } func main () { foo () } The example above doesn't do anything, but it illustrates the anatomy of a function. In the case of foo , we have an empty function declaration, and then we have main , which is defined by a single call to foo . Functions can also receive inputs and return outputs, as in the example below. package main func foo ( in i32 ) { i32 . print ( in ) // this will print 5 } func bar () ( out i32 ){ out = 10 } func main () { foo ( 5 ) var local i32 local = bar () i32 . print ( local ) // this will print 10 } In this case, foo is declared to receive one input parameter, and bar is declared to return one output parameter. Custom Types If primitive types are not enough, you can define your own custom types by combining the primitive types and other constructs like slices, arrays, and even other custom types. package main type Point struct { x i32 y i32 } func main () { var p Point p . x = 10 p . y = 20 printf ( \"Point coordinates: (%d, %d)\\n\" , p . x , p . y ) } In the example above, we can see a custom type that defines a Point as the combination of two 32-bit integers ( i32 ). After declaring the custom type, you can start declaring variables of that type anywhere in the package where it was declared in. The code in foo shows how you can create and use an instance of that structure. Methods A variation of functions that are associated to custom types are methods . package main type Point struct { x i32 y i32 } type Line struct { a Point b Point } func ( p Point ) print () { printf ( \"Point coordinates: (%d, %d)\\n\" , p . x , p . y ) } func ( l Line ) print () { printf ( \"Line point A: (%d, %d), Line point B: (%d, %d)\\n\" , l . a . x , l . a . y , l . b . x , l . b . y ) } func main () { var l Line var p1 Point var p2 Point p1 . x = 10 p1 . y = 20 p2 . x = 11 p2 . y = 21 l . a = p1 l . b = p2 p1 . print () p2 . print () l . print () } In the example above, we define two custom types: Point and Line . The type line is defined by two fields of type Point , and the type Point is defined as coordinate defined by two fields of type i32 . As a simple example, we create two methods called print , one for the type Point and another for the type Line . In the case of Point.print , we just print the two coordinates, and in the case of Line.print we print the coordinates of the two points that define the Line instance. Packages In the previous examples we have always been using a single package: main . If your program grows too large it's convenient to divide your code into different packages. package foo func fn ( in i32 ) { i32 . print ( in ) } package bar func fn () ( out i32 ) { out = 5 } package main import \"foo\" import \"bar\" func main () { foo . fn ( 10 ) // prints 10 var num i32 num = bar . fn () i32 . print ( num ) // prints } In the example above, we can see how two functions with the same name ( fn ) are declared, each in a separate package. Both of these functions have different signatures, as foo.fn accepts a single input parameter and bar.fn doesn't accept any inputs but returns a single output parameter. We can then see how the main package import s both the foo and bar packages, to later call each of these functions. Statements Statements are different to declarations, as they don't create any named elements in a program. They are used to control the flow of a program. If and if/else The most basic statement is the if statement, which is going to execute a block of code only if a condition is true. package main func main () { if false { str . print ( \"This will never print\" ) } } The example above won't do anything, as the condition for the if statement is always going to evaluate to false . package main func main () { if true { str . print ( \"This will always print\" ) } } In contrast, the example above will always print. package main func main () { if true { str . print ( \"This will always print\" ) } else { str . print ( \"This will never print\" ) } } Lastly, the example above shows how to write an if/else statement in CX. As a note about its syntax, the predicates or conditions don't need to be enclosed in parentheses, just like in Go. Else if Instead of simply adding one alternative path, you can string together a series of else if blocks, which check for as many different conditions as you like. Giving you similar functionality as Go's switch / select blocks (containing various conditions/cases). package main func main () { var i i32 i = 0 if i == 0 { str . print ( \"i is 0\" ) } else if i == 1 { str . print ( \"i is 1\" ) } else if i == 2 { str . print ( \"i is 2\" ) } else { str . print ( \"i is NOT 0, 1 or 2\" ) } } For loop CX's only looping statement is the for loop. Similar to Go, the for loop in CX can be used as the while statement in other programming languages, and as a traditional for statement. package main func main () { for true { str . print ( \"forever\" ) } } As the simplest example of a loop, we have the infinite loop shown in the example above. In this case, the loop will print the character string \"forever\" indefinitely. If you try this code, remember that you can cancel the program's execution by hitting Ctrl-C . package main func main () { for str . eq ( \"hi\" , \"hi\" ) { str . print ( \"hi\" ) } } The code above shows another example, one where we use an expression as its predicate, rather than a literal true or false . It is worth mentioning that you can replace str.eq(\"hi\", \"hi\") by \"hi\" == \"hi\" . package main func main () { var c i32 for c = 0 ; c < 10 ; c ++ { i32 . print ( c ) } } The traditional for loop shown in the example above. In languages like C, you need to first declare your counter variable, and then you have the option to initialize or reassign the counter in the first part of the for loop. The second part of the for loop is reserved for the predicate, and the last part is usually used to increment the counter. Nevertheless, just like in C, there's nothing stopping you from doing whatever you want in the first and last parts. However, the predicate part needs to be an expression that evaluates to a Boolean. package main func main () { for c := 0 ; c < 10 ; c ++ { i32 . print ( c ) } } A more Go-ish way of declaring and initializing the counter is to use an inline declaration, as seen in the example above. package main func main () { var c i32 c = 0 for ; c < 10 ; c ++ { i32 . print ( c ) } } Lastly, the for loop can also completely omit the initialization part, as seen above. Goto goto can be used to immediately jump the execution of a program to the corresponding labeled expression. package main func main () ( out i32 ) { goto label2 label1 : str . print ( \"this should never be reached\" ) label2 : str . print ( \"this should be printed\" ) } In the example above, we see how a goto statement forces CX to ignore executing the expression labeled as label1 , and instead jumps to the label2 expression. Expressions Expressions are basically function calls. But the term expression also takes into consideration the variables that are receiving the function's output arguments, the input arguments, and any dereference operations. package main func foo () ( arr [ 2 ] i32 ) { arr = [ 2 ] i32 { 10 , 20 } } func main () { i32 . print ( foo ()[ 0 ]) } For example, the expression i32.print(foo()[0]) in the code above consists of two function calls, and the array returned by the call to foo is \"dereferenced\" to its 0 th element. Assignments and Initializations As in many other C-like languages, assignments are done using the equal ( = ) sign. package main func main () { var foo i32 foo = 5 foo = 50 } In the case of the code above, the variable foo is declared and then initialized to 5 using the = sign. Then we reassign the foo variable to the value 50 . package main func main () { foo := 5 foo = 50 } As in other programming languages, short variable declarations exist in CX. The := token can be used to tell CX to infer a variable's type. This way, CX declares and initializes at the same time, as seen in the example above. Affordances The affordance system in CX uses a special operator: -> . This operator takes a series of statements that have the form of function calls, and transforms them to a series of instructions that can be internally interpreted by the affordance system. package main func exprPredicate ( expr Expression ) ( res bool ) { if expr . Operator == \"i32.add\" { res = true } } func prgrmPredicate ( prgrm Program ) () { if prgrm . FreeHeap > 50 { res = true } } func main () { num1 := 5 num2 := 10 targetExpr : sum := i32 . add ( 0 , 0 ) tgt := - >{ pkg ( main ) fn ( main ) expr ( targetExpr ) } fltrs := - >{ filter ( exprPredicate ) filter ( prgrmPredicate ) } aff . print ( tgt ) aff . print ( fltrs ) affs := aff . query ( fltrs , tgt ) aff . on ( affs , tgt ) aff . of ( affs , tgt ) aff . inform ( affs , 0 , tgt ) aff . request ( affs , 0 , tgt ) }","title":"Syntax"},{"location":"software/cx/basics-syntax/#syntax","text":"In this section, we're going to have a look at how a CX program looks like. Basically, the following sections are not going to discuss about the logic behind the various CX constructs, i.e. how they behave; we're only going to see how they look like.","title":"Syntax"},{"location":"software/cx/basics-syntax/#comments","text":"Some of the code snippets that follow have comments in them, i.e., blocks of text that are not actually \"run\" by the CX compiler or interpreter. Just like in C, Golang and many other programming languages, single line comments are created by placing double slashes (//) before the text being commented. For example: // Example of adding two 32 bit integers in CX i32 . add ( 3 , 4 ) // This will be ignored // End of the program Mult-line comments are opened by writing slash-asterisk (/*), and are closed by writing asterisk-slash (*/). /* This code won't be executed str.print(\"Hello world!\") */","title":"Comments"},{"location":"software/cx/basics-syntax/#declarations","text":"A declaration refers to a named element in a program's structure, which are described using other constructs, such as expressions and other statements. For example: a function can be referred by its name and it's constructed by expressions and local variable declarations.","title":"Declarations"},{"location":"software/cx/basics-syntax/#allowed-names","text":"Any name that satisfies the PCRE regular expression [_a-zA-Z][_a-zA-Z0-9]* is allowed as an identifier for a declared element. In other words, an identifier can start with an underscore ( _ ) or any lowercase or uppercase letter, and can be followed by 0 or more underscores or lowercase or uppercase letters, and any number from 0 to 9.","title":"Allowed Names"},{"location":"software/cx/basics-syntax/#strict-type-system","text":"One of CX's goals is to provide a very strict type system. The purpose of this is to reduce runtime errors as much as possible. In order to achieve this goal, many of CX's native functions are constrained to a single type signature. For example, if you want to add two 32-bit integers, you'd need to use i32.add . In contrast, if you want to add two 64-bit integers, you'd use i64.add . These functions can help the programmer to ensure that a particular data type is being received or sent during a process. If the programmer doesn't want to use those type-specific functions, CX still provides type inference in some cases. For example, instead of writing i32.add(5, 5) you can just write 5 + 5 . In this case, CX is going to see that you're using 32-bit integers, and the parser is going to transform that expression to i32.add(5, 5) . However, if you try to do 5 + 5L , i.e. if you try to add a 32-bit integer to a 64-bit integer, CX will throw a compile-time error because you're mixing types. The proper way to handle types in CX is to explicitly parse everything. This way one can be sure that you're always going to be handling the desired type. So, retaking the previous example, you'd need to parse one of them to match the other's type, either i32.i64(5) + 5L or 5 + i64.i32(5L) .","title":"Strict Type System"},{"location":"software/cx/basics-syntax/#primitive-types","text":"There are seven primitive types in CX: bool , str , byte , i32 , i64 , f32 , and f64 . Those represent Booleans ( true or false ), character strings, bytes, 32-bit integers, 64-bit integers, single precision and double precision floating-point numbers, respectively.","title":"Primitive Types"},{"location":"software/cx/basics-syntax/#global-variables","text":"Global variables are different from local variables regarding scope. Global variables are available to any function defined in a package, and to any package that is importing the package that contains that global declaration. An example of some global variables is shown below. package main var global1 i32 var global2 i64 func foo () { i32 . print ( global1 ) i64 . print ( global2 ) } func main () { global1 = 5 global2 = 5 L i32 . print ( global1 ) i64 . print ( global2 ) } In the example above we can see that both the main and foo functions are printing the values of the two global variables defined. They are going to print the same values, as they are referring to the same variables.","title":"Global variables"},{"location":"software/cx/basics-syntax/#local-variables","text":"In contrast to global variables, local variables are constrained to the function where they are declared. This means that is not possible for another function to call a variable defined in another function. package main func foo () { i32 . print ( local ) // this expression will throw a compile-time error } func main () { var local i32 local = 5 i32 . print ( 5 ) foo () } If you try to run the example above, CX will throw an error similar to this: error: examples/testing.cx:4 identifier 'local' does not exist , so CX will not even try to run that program. If we could de-activate CX's compile-time type checking, and the program above could make it to the runtime, CX would not print 5 when running foo() , as that function is unaware of that variable.","title":"Local variables"},{"location":"software/cx/basics-syntax/#arrays","text":"Arrays (or vectors) and multi-dimensional arrays (or matrices) can be declared using a syntax similar to C's. package main type Point struct { x i32 y i32 } func main () { var arr1 [ 5 ] i32 var arr2 [ 5 ] Point var arr3 [ 2 ][ 2 ] f32 arr1 [ 0 ] = 10 arr2 [ 1 ] = 20 } In the example above we see the declaration of an array of 5 elements of type i32 , followed by an array of the same cardinality but of type Point , which is a custom type. Custom types are discussed in a later section. Lastly, we see an example of a 2x2 matrix of type f32 . Lastly, we can see how we can initialize an array using the bracket notation, e.g. arr1[0] = 10 .","title":"Arrays"},{"location":"software/cx/basics-syntax/#slices","text":"Golang-like slices exist in CX (dynamic arrays). Slices are declared similarly to arrays, with the only difference that the size is omitted. package main type Point struct { x i32 y i32 } func main () { var slc1 [] i32 var slc2 [] Point var slc3 [][] f32 } Slices, unlike arrays, cannot be directly initialized using the bracket notation (unless you use the native function make first). You can use the bracket notation to reassign values to a slice, once an element associated to the index that you want to use already exists, as shown in the example below. package main func main () { var slc [] i32 slc = append ( slc , 1 ) slc = append ( slc , 2 ) slc [ 0 ] = 10 slc [ 2 ] = 30 // This is not allowed, as len(slc) == 2, not 3 } As this behavior is more related to the logic behind slices, it is further explained in the Runtime->Data Structures->Slices section.","title":"Slices"},{"location":"software/cx/basics-syntax/#literals","text":"A literal is any data structure that is not being referenced by any variable yet. For example: 1 , true , []i32{1, 2, 3} , Point{x: 10, y: 20} . Particularly, it is worth noting the cases of array, slice and struct literals. package main type Point struct { x i32 y i32 } func main () { var a Point var b [ 5 ] i32 var c [] i32 a = Point { x : 10 , y : 20 } b = [ 5 ] i32 { 1 , 2 , 3 , 4 , 5 } c = [] i32 { 100 , 200 , 300 } } In the example above we can see examples of struct ( Point{x: 10, y: 20} ), array ( [5]i32{1, 2, 3, 4, 5} ), and slice ( []i32{100, 200, 300} ) literals, in that order. These literals exist to simplify the creation of such data structures.","title":"Literals"},{"location":"software/cx/basics-syntax/#functions","text":"Functions in CX are similar in syntax to functions in Go. The only exception is that named outputs are enforced at the moment (this will most likely change in the future). package main func foo () { } func main () { foo () } The example above doesn't do anything, but it illustrates the anatomy of a function. In the case of foo , we have an empty function declaration, and then we have main , which is defined by a single call to foo . Functions can also receive inputs and return outputs, as in the example below. package main func foo ( in i32 ) { i32 . print ( in ) // this will print 5 } func bar () ( out i32 ){ out = 10 } func main () { foo ( 5 ) var local i32 local = bar () i32 . print ( local ) // this will print 10 } In this case, foo is declared to receive one input parameter, and bar is declared to return one output parameter.","title":"Functions"},{"location":"software/cx/basics-syntax/#custom-types","text":"If primitive types are not enough, you can define your own custom types by combining the primitive types and other constructs like slices, arrays, and even other custom types. package main type Point struct { x i32 y i32 } func main () { var p Point p . x = 10 p . y = 20 printf ( \"Point coordinates: (%d, %d)\\n\" , p . x , p . y ) } In the example above, we can see a custom type that defines a Point as the combination of two 32-bit integers ( i32 ). After declaring the custom type, you can start declaring variables of that type anywhere in the package where it was declared in. The code in foo shows how you can create and use an instance of that structure.","title":"Custom Types"},{"location":"software/cx/basics-syntax/#methods","text":"A variation of functions that are associated to custom types are methods . package main type Point struct { x i32 y i32 } type Line struct { a Point b Point } func ( p Point ) print () { printf ( \"Point coordinates: (%d, %d)\\n\" , p . x , p . y ) } func ( l Line ) print () { printf ( \"Line point A: (%d, %d), Line point B: (%d, %d)\\n\" , l . a . x , l . a . y , l . b . x , l . b . y ) } func main () { var l Line var p1 Point var p2 Point p1 . x = 10 p1 . y = 20 p2 . x = 11 p2 . y = 21 l . a = p1 l . b = p2 p1 . print () p2 . print () l . print () } In the example above, we define two custom types: Point and Line . The type line is defined by two fields of type Point , and the type Point is defined as coordinate defined by two fields of type i32 . As a simple example, we create two methods called print , one for the type Point and another for the type Line . In the case of Point.print , we just print the two coordinates, and in the case of Line.print we print the coordinates of the two points that define the Line instance.","title":"Methods"},{"location":"software/cx/basics-syntax/#packages","text":"In the previous examples we have always been using a single package: main . If your program grows too large it's convenient to divide your code into different packages. package foo func fn ( in i32 ) { i32 . print ( in ) } package bar func fn () ( out i32 ) { out = 5 } package main import \"foo\" import \"bar\" func main () { foo . fn ( 10 ) // prints 10 var num i32 num = bar . fn () i32 . print ( num ) // prints } In the example above, we can see how two functions with the same name ( fn ) are declared, each in a separate package. Both of these functions have different signatures, as foo.fn accepts a single input parameter and bar.fn doesn't accept any inputs but returns a single output parameter. We can then see how the main package import s both the foo and bar packages, to later call each of these functions.","title":"Packages"},{"location":"software/cx/basics-syntax/#statements","text":"Statements are different to declarations, as they don't create any named elements in a program. They are used to control the flow of a program.","title":"Statements"},{"location":"software/cx/basics-syntax/#if-and-ifelse","text":"The most basic statement is the if statement, which is going to execute a block of code only if a condition is true. package main func main () { if false { str . print ( \"This will never print\" ) } } The example above won't do anything, as the condition for the if statement is always going to evaluate to false . package main func main () { if true { str . print ( \"This will always print\" ) } } In contrast, the example above will always print. package main func main () { if true { str . print ( \"This will always print\" ) } else { str . print ( \"This will never print\" ) } } Lastly, the example above shows how to write an if/else statement in CX. As a note about its syntax, the predicates or conditions don't need to be enclosed in parentheses, just like in Go.","title":"If and if/else"},{"location":"software/cx/basics-syntax/#else-if","text":"Instead of simply adding one alternative path, you can string together a series of else if blocks, which check for as many different conditions as you like. Giving you similar functionality as Go's switch / select blocks (containing various conditions/cases). package main func main () { var i i32 i = 0 if i == 0 { str . print ( \"i is 0\" ) } else if i == 1 { str . print ( \"i is 1\" ) } else if i == 2 { str . print ( \"i is 2\" ) } else { str . print ( \"i is NOT 0, 1 or 2\" ) } }","title":"Else if"},{"location":"software/cx/basics-syntax/#for-loop","text":"CX's only looping statement is the for loop. Similar to Go, the for loop in CX can be used as the while statement in other programming languages, and as a traditional for statement. package main func main () { for true { str . print ( \"forever\" ) } } As the simplest example of a loop, we have the infinite loop shown in the example above. In this case, the loop will print the character string \"forever\" indefinitely. If you try this code, remember that you can cancel the program's execution by hitting Ctrl-C . package main func main () { for str . eq ( \"hi\" , \"hi\" ) { str . print ( \"hi\" ) } } The code above shows another example, one where we use an expression as its predicate, rather than a literal true or false . It is worth mentioning that you can replace str.eq(\"hi\", \"hi\") by \"hi\" == \"hi\" . package main func main () { var c i32 for c = 0 ; c < 10 ; c ++ { i32 . print ( c ) } } The traditional for loop shown in the example above. In languages like C, you need to first declare your counter variable, and then you have the option to initialize or reassign the counter in the first part of the for loop. The second part of the for loop is reserved for the predicate, and the last part is usually used to increment the counter. Nevertheless, just like in C, there's nothing stopping you from doing whatever you want in the first and last parts. However, the predicate part needs to be an expression that evaluates to a Boolean. package main func main () { for c := 0 ; c < 10 ; c ++ { i32 . print ( c ) } } A more Go-ish way of declaring and initializing the counter is to use an inline declaration, as seen in the example above. package main func main () { var c i32 c = 0 for ; c < 10 ; c ++ { i32 . print ( c ) } } Lastly, the for loop can also completely omit the initialization part, as seen above.","title":"For loop"},{"location":"software/cx/basics-syntax/#goto","text":"goto can be used to immediately jump the execution of a program to the corresponding labeled expression. package main func main () ( out i32 ) { goto label2 label1 : str . print ( \"this should never be reached\" ) label2 : str . print ( \"this should be printed\" ) } In the example above, we see how a goto statement forces CX to ignore executing the expression labeled as label1 , and instead jumps to the label2 expression.","title":"Goto"},{"location":"software/cx/basics-syntax/#expressions","text":"Expressions are basically function calls. But the term expression also takes into consideration the variables that are receiving the function's output arguments, the input arguments, and any dereference operations. package main func foo () ( arr [ 2 ] i32 ) { arr = [ 2 ] i32 { 10 , 20 } } func main () { i32 . print ( foo ()[ 0 ]) } For example, the expression i32.print(foo()[0]) in the code above consists of two function calls, and the array returned by the call to foo is \"dereferenced\" to its 0 th element.","title":"Expressions"},{"location":"software/cx/basics-syntax/#assignments-and-initializations","text":"As in many other C-like languages, assignments are done using the equal ( = ) sign. package main func main () { var foo i32 foo = 5 foo = 50 } In the case of the code above, the variable foo is declared and then initialized to 5 using the = sign. Then we reassign the foo variable to the value 50 . package main func main () { foo := 5 foo = 50 } As in other programming languages, short variable declarations exist in CX. The := token can be used to tell CX to infer a variable's type. This way, CX declares and initializes at the same time, as seen in the example above.","title":"Assignments and Initializations"},{"location":"software/cx/basics-syntax/#affordances","text":"The affordance system in CX uses a special operator: -> . This operator takes a series of statements that have the form of function calls, and transforms them to a series of instructions that can be internally interpreted by the affordance system. package main func exprPredicate ( expr Expression ) ( res bool ) { if expr . Operator == \"i32.add\" { res = true } } func prgrmPredicate ( prgrm Program ) () { if prgrm . FreeHeap > 50 { res = true } } func main () { num1 := 5 num2 := 10 targetExpr : sum := i32 . add ( 0 , 0 ) tgt := - >{ pkg ( main ) fn ( main ) expr ( targetExpr ) } fltrs := - >{ filter ( exprPredicate ) filter ( prgrmPredicate ) } aff . print ( tgt ) aff . print ( fltrs ) affs := aff . query ( fltrs , tgt ) aff . on ( affs , tgt ) aff . of ( affs , tgt ) aff . inform ( affs , 0 , tgt ) aff . request ( affs , 0 , tgt ) }","title":"Affordances"},{"location":"software/cx/installation-linux/","text":"CX Installation on Linux Info You have got two options to install CX on Windows. Binary Releases - Fast and safe Installation Compiling from Source - better to customize your cx-options, also necessary for CX-Chains Binary Releases Download the latest version of cx from https://github.com/SkycoinProject/cx/releases TODO: terminal command Unzip into the destination folder you want to have your CX-files. TODO: terminal command Setup the Environmental Variable $PATH so it knows your destination folder. TODO: terminal command Compiling from Source Requirements To compile cx from source you need golang installed! Install Go Source: https://raw.githubusercontent.com/skycoin/skycoin/develop/INSTALLATION.md Installation Packet Manager We need to install linux dependencies on the correct distribution. Ubuntu and Debian sudo apt-get update && sudo apt-get upgrade -y sudo apt-get install -y curl git mercurial make binutils gcc bzr bison libgmp3-dev screen gcc build-essential Centos and Fedora sudo yum update -y && sudo yum upgrade -y sudo yum install -y git curl make gcc mercurial binutils bzr bison screen if [[ \" $( cat /etc/redhat-release | grep -o CentOS ) \" == \"CentOS\" ]] ; then sudo yum install -y build-essential libgmp3-dev ; else sudo yum groupinstall -y \"Development Tools\" \"Development Libraries\" && sudo yum install -y gmp ; fi ; Archlinux First update the system and ensure the dependancies are met sudo pacman -Syy && sudo pacman -Syu sudo pacman -S base-devel Install the latest version of go on Archlinux with: sudo pacman -S go Install Go From Source Let's go to home directory and declare go 's version that you want to download. cd ~ export GOV = 1 .11.1 # golang version After that, let's download and uncompress golang source. curl -sS https://storage.googleapis.com/golang/go $GOV .linux-amd64.tar.gz > go $GOV .linux-amd64.tar.gz tar xvf go $GOV .linux-amd64.tar.gz rm go $GOV .linux-amd64.tar.gz lastly, let's install go . sudo mv go /usr/local/go sudo ln -s /usr/local/go/bin/go /usr/local/bin/go sudo ln -s /usr/local/go/bin/godoc /usr/local/bin/godoc sudo ln -s /usr/local/go/bin/gofmt /usr/local/bin/gofmt Note Find any golang source version at Go Website Setup your GOPATH The $GOPATH environment variable specifies the location of your workspace. It defaults to a directory named go inside your home directory, so $HOME/go on Unix. Create your workspace directory with it's respective inner folders: mkdir -p $HOME /go mkdir -p $HOME /go/bin mkdir -p $HOME /go/src mkdir -p $HOME /go/pkg Setup $GOPATH variable, add it to ~/.bashrc. After editing, run source ~/.bashrc or open a new tab. export GOROOT = /usr/local/go export GOPATH = $HOME /go export GOBIN = $GOPATH /bin export PATH = $PATH : $GOBIN Test your Go installation Create and run the hello.go application described here to check if your Go installation is working. Make sure you have got go1.10+ installed. If not follow the guide above. Download CX's respository with: go get github.com/SkycoinProject/cx/cx/... Navigate to CX's repository and run: make install Test your installation by running: make test Note If you intend to develop games with CX test by running: make test-full To update your CX-Installation just run make install again. Hello, World! TODO Next Step The next step should be to search for a development environment that fits you to code as easy as possible. Have a look into Programming Tools to find and setup your favorite Code Editor.","title":"Linux"},{"location":"software/cx/installation-linux/#cx-installation-on-linux","text":"Info You have got two options to install CX on Windows. Binary Releases - Fast and safe Installation Compiling from Source - better to customize your cx-options, also necessary for CX-Chains Binary Releases Download the latest version of cx from https://github.com/SkycoinProject/cx/releases TODO: terminal command Unzip into the destination folder you want to have your CX-files. TODO: terminal command Setup the Environmental Variable $PATH so it knows your destination folder. TODO: terminal command Compiling from Source Requirements To compile cx from source you need golang installed! Install Go Source: https://raw.githubusercontent.com/skycoin/skycoin/develop/INSTALLATION.md Installation Packet Manager We need to install linux dependencies on the correct distribution. Ubuntu and Debian sudo apt-get update && sudo apt-get upgrade -y sudo apt-get install -y curl git mercurial make binutils gcc bzr bison libgmp3-dev screen gcc build-essential Centos and Fedora sudo yum update -y && sudo yum upgrade -y sudo yum install -y git curl make gcc mercurial binutils bzr bison screen if [[ \" $( cat /etc/redhat-release | grep -o CentOS ) \" == \"CentOS\" ]] ; then sudo yum install -y build-essential libgmp3-dev ; else sudo yum groupinstall -y \"Development Tools\" \"Development Libraries\" && sudo yum install -y gmp ; fi ; Archlinux First update the system and ensure the dependancies are met sudo pacman -Syy && sudo pacman -Syu sudo pacman -S base-devel Install the latest version of go on Archlinux with: sudo pacman -S go Install Go From Source Let's go to home directory and declare go 's version that you want to download. cd ~ export GOV = 1 .11.1 # golang version After that, let's download and uncompress golang source. curl -sS https://storage.googleapis.com/golang/go $GOV .linux-amd64.tar.gz > go $GOV .linux-amd64.tar.gz tar xvf go $GOV .linux-amd64.tar.gz rm go $GOV .linux-amd64.tar.gz lastly, let's install go . sudo mv go /usr/local/go sudo ln -s /usr/local/go/bin/go /usr/local/bin/go sudo ln -s /usr/local/go/bin/godoc /usr/local/bin/godoc sudo ln -s /usr/local/go/bin/gofmt /usr/local/bin/gofmt Note Find any golang source version at Go Website Setup your GOPATH The $GOPATH environment variable specifies the location of your workspace. It defaults to a directory named go inside your home directory, so $HOME/go on Unix. Create your workspace directory with it's respective inner folders: mkdir -p $HOME /go mkdir -p $HOME /go/bin mkdir -p $HOME /go/src mkdir -p $HOME /go/pkg Setup $GOPATH variable, add it to ~/.bashrc. After editing, run source ~/.bashrc or open a new tab. export GOROOT = /usr/local/go export GOPATH = $HOME /go export GOBIN = $GOPATH /bin export PATH = $PATH : $GOBIN Test your Go installation Create and run the hello.go application described here to check if your Go installation is working. Make sure you have got go1.10+ installed. If not follow the guide above. Download CX's respository with: go get github.com/SkycoinProject/cx/cx/... Navigate to CX's repository and run: make install Test your installation by running: make test Note If you intend to develop games with CX test by running: make test-full To update your CX-Installation just run make install again.","title":"CX Installation on Linux"},{"location":"software/cx/installation-linux/#hello-world","text":"TODO","title":"Hello, World!"},{"location":"software/cx/installation-linux/#next-step","text":"The next step should be to search for a development environment that fits you to code as easy as possible. Have a look into Programming Tools to find and setup your favorite Code Editor.","title":"Next Step"},{"location":"software/cx/installation-macos/","text":"CX Installation on macOS Info To install cx on macOS the best way is to use Homebrew . Homebrew-Install Download and install Homebrew by pressing \u2318 + Space and typing in Terminal to start Terminal, then type in the following command: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \u201d Installation Press \u2318 + Space and type in Terminal to start Terminal. Type in the following lines to install CX : brew tap skycoin/homebrew-skycoin brew install skycoin-cx To update use the following command: brew update skycoin-cx Hello, World! To check our Installation with something more than a version output we will now make a cx-file to print out 'Hello World!' Make a new text-file and rename it to hello-world.cx Open the file with a text editor and type in the following: package main func main () { str . print ( \"Hello, World!\" ) } Save and close Press \u2318 + Space and type in Terminal to start Terminal. Move to the direction where your hello-world.cx is and type in cx hello-world.cx or just drag and drop your file into the terminal after typing in cx followed by a Space Next Step The next step should be to search for a development environment that fits you to code as easy as possible. Have a look into Programming Tools to find and setup your favorite Code Editor.","title":"macOS"},{"location":"software/cx/installation-macos/#cx-installation-on-macos","text":"Info To install cx on macOS the best way is to use Homebrew . Homebrew-Install Download and install Homebrew by pressing \u2318 + Space and typing in Terminal to start Terminal, then type in the following command: /usr/bin/ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \u201d","title":"CX Installation on macOS"},{"location":"software/cx/installation-macos/#installation","text":"Press \u2318 + Space and type in Terminal to start Terminal. Type in the following lines to install CX : brew tap skycoin/homebrew-skycoin brew install skycoin-cx To update use the following command: brew update skycoin-cx","title":"Installation"},{"location":"software/cx/installation-macos/#hello-world","text":"To check our Installation with something more than a version output we will now make a cx-file to print out 'Hello World!' Make a new text-file and rename it to hello-world.cx Open the file with a text editor and type in the following: package main func main () { str . print ( \"Hello, World!\" ) } Save and close Press \u2318 + Space and type in Terminal to start Terminal. Move to the direction where your hello-world.cx is and type in cx hello-world.cx or just drag and drop your file into the terminal after typing in cx followed by a Space","title":"Hello, World!"},{"location":"software/cx/installation-macos/#next-step","text":"The next step should be to search for a development environment that fits you to code as easy as possible. Have a look into Programming Tools to find and setup your favorite Code Editor.","title":"Next Step"},{"location":"software/cx/installation-windows/","text":"Windows 10 Installation Installation Info You have got two options to install CX on Windows. Binary Releases - Fast and safe Installation Compiling from Source - better to customize your cx-options, also necessary for CX-Chains Binary Releases Download the latest version of cx.exe from https://github.com/SkycoinProject/cx/releases Unzip into the destination folder you want to have your CX-files. For example: D:\\Programs\\CX Setup Environment Variables to get access to your cx.exe through the terminal: Press WIN + R , type in C:\\Windows\\System32\\systempropertiesadvanced.exe and hit ENTER Search for Path in 'User variables for User', select it and press Edit. Make a new environment variable with the path, depending on your destination folder. Here D:\\Programs\\CX Check your installation like described here To update your CX-Installation just get the latest cx.exe and replace the old one. Compiling from Source Requirements To compile cx from source you need golang installed! Install Go Source: https://skywug.net/forum/Thread-Skywire-node-on-Windows Installation Download Go from https://golang.org/dl/ and install it. Setup Environment Variables 1. Press WIN + R to open run and type in C: \\W indows \\S ystem32 \\s ystempropertiesadvanced.exe 2. Select the GOPATH variable and change it's value to: %USERPROFILE% \\g o 3. Make a new variable called GOBIN with the value: %USERPROFILE% \\g o \\b in First make sure you have got GO installed and set up your Environment Variables . If not follow the guide above. You also need git to copy github repos. You can download it from https://git-scm.com/downloads . After the installation make a new Environment Variable like described in the next steps: 3.1 Press WIN + R to open run and type in C: \\W indows \\S ystem32 \\s ystempropertiesadvanced.exe 3.2 Make a new variable called CXPATH with the value: %USERPROFILE% \\g o \\s rc \\g ithub.com \\S kycoinProject \\c x 3.3 Make sure the Environment Variables from Step 1 are also set: GOPATH = %USERPROFILE% \\g o GOBIN = %USERPROFILE% \\g o \\b in Get the latest version of the github cx-repository 4.1 Press WIN + R , type in cmd.exe and hit ENTER 4.2 get github repo by typing in: mkdir -p %GOPATH% \\s rc \\g ithub.com \\S kycoinProject \\ cd %GOPATH% \\s rc \\g ithub.com \\S kycoinProject \\ git clone https://github.com/SkycoinProject/cx.git 4.2 To install cx type in: cd %CXPATH% cx-setup.bat Check your installation by typing in: cd %CXPATH% cx tests \\m ain.cx ++wdir = tests ++disable-tests = issue To update your CX-Installation just run cx-setup.bat again Check Installation Open Terminal with WIN + R and type in cmd.exe In Terminal type in cx -v The output should look like this: CX version X.X.X (the X represent the version you have installed) Hello, World! To check our Installation with something more than a version output we will now make a cx-file to print out 'Hello World!' Make a new text-file in the location where your cx.exe is and rename it to hello-world.cx Open the file with Editor and type in the following: package main func main () { str . print ( \"Hello, World!\" ) } Press Ctrl + S and close Open a terminal with WIN + R and type in cmd.exe Move to the direction where your hello-world.cx is and type in cx hello-world.cx or just drag and drop your file into the terminal after typing in cx followed by a Space Next Step The next step should be to search for a development environment that fits you to code as easy as possible. Have a look into Programming Tools to find your favorite Code Editor.","title":"Windows"},{"location":"software/cx/installation-windows/#windows-10-installation","text":"","title":"Windows 10 Installation"},{"location":"software/cx/installation-windows/#installation","text":"Info You have got two options to install CX on Windows. Binary Releases - Fast and safe Installation Compiling from Source - better to customize your cx-options, also necessary for CX-Chains Binary Releases Download the latest version of cx.exe from https://github.com/SkycoinProject/cx/releases Unzip into the destination folder you want to have your CX-files. For example: D:\\Programs\\CX Setup Environment Variables to get access to your cx.exe through the terminal: Press WIN + R , type in C:\\Windows\\System32\\systempropertiesadvanced.exe and hit ENTER Search for Path in 'User variables for User', select it and press Edit. Make a new environment variable with the path, depending on your destination folder. Here D:\\Programs\\CX Check your installation like described here To update your CX-Installation just get the latest cx.exe and replace the old one. Compiling from Source Requirements To compile cx from source you need golang installed! Install Go Source: https://skywug.net/forum/Thread-Skywire-node-on-Windows Installation Download Go from https://golang.org/dl/ and install it. Setup Environment Variables 1. Press WIN + R to open run and type in C: \\W indows \\S ystem32 \\s ystempropertiesadvanced.exe 2. Select the GOPATH variable and change it's value to: %USERPROFILE% \\g o 3. Make a new variable called GOBIN with the value: %USERPROFILE% \\g o \\b in First make sure you have got GO installed and set up your Environment Variables . If not follow the guide above. You also need git to copy github repos. You can download it from https://git-scm.com/downloads . After the installation make a new Environment Variable like described in the next steps: 3.1 Press WIN + R to open run and type in C: \\W indows \\S ystem32 \\s ystempropertiesadvanced.exe 3.2 Make a new variable called CXPATH with the value: %USERPROFILE% \\g o \\s rc \\g ithub.com \\S kycoinProject \\c x 3.3 Make sure the Environment Variables from Step 1 are also set: GOPATH = %USERPROFILE% \\g o GOBIN = %USERPROFILE% \\g o \\b in Get the latest version of the github cx-repository 4.1 Press WIN + R , type in cmd.exe and hit ENTER 4.2 get github repo by typing in: mkdir -p %GOPATH% \\s rc \\g ithub.com \\S kycoinProject \\ cd %GOPATH% \\s rc \\g ithub.com \\S kycoinProject \\ git clone https://github.com/SkycoinProject/cx.git 4.2 To install cx type in: cd %CXPATH% cx-setup.bat Check your installation by typing in: cd %CXPATH% cx tests \\m ain.cx ++wdir = tests ++disable-tests = issue To update your CX-Installation just run cx-setup.bat again","title":"Installation"},{"location":"software/cx/installation-windows/#check-installation","text":"Open Terminal with WIN + R and type in cmd.exe In Terminal type in cx -v The output should look like this: CX version X.X.X (the X represent the version you have installed)","title":"Check Installation"},{"location":"software/cx/installation-windows/#hello-world","text":"To check our Installation with something more than a version output we will now make a cx-file to print out 'Hello World!' Make a new text-file in the location where your cx.exe is and rename it to hello-world.cx Open the file with Editor and type in the following: package main func main () { str . print ( \"Hello, World!\" ) } Press Ctrl + S and close Open a terminal with WIN + R and type in cmd.exe Move to the direction where your hello-world.cx is and type in cx hello-world.cx or just drag and drop your file into the terminal after typing in cx followed by a Space","title":"Hello, World!"},{"location":"software/cx/installation-windows/#next-step","text":"The next step should be to search for a development environment that fits you to code as easy as possible. Have a look into Programming Tools to find your favorite Code Editor.","title":"Next Step"},{"location":"software/cx/package-gl/","text":"Using gl in CX To use the gl-Functions you first have to import it: import \"gl\" Source Code Until the documentation on this page is finished please refer to the official opengl documentation TODO gogl gl.Init gl.Strs gl.Free gl.NewTexture gl.NewGIF gl.FreeGIF gl.GIFFrameToTexture gl 0.0 gl.MatrixMode gl.Rotatef gl.Translatef gl.LoadIdentity gl.PushMatrix gl.PopMatrix gl.EnableClientState gl.Color3f gl.Color4f gl.Begin gl.End gl.Normal3f gl.Vertex2f gl.Vertex3f gl.Lightfv gl.Frustum gl.TexEnvi gl.Ortho gl.Scalef gl.TexCoord2d gl.TexCoord2f gl 1.0 gl.CullFace gl.Hint gl.Scissor gl.TexParameteri gl.TexImage2D gl.Clear gl.ClearColor gl.ClearStencil gl.StencilMask gl.ColorMask gl.DepthMask gl.Disable gl.Enable gl.BlendFunc gl.StencilFunc gl.StencilOp gl.DepthFunc gl.GetError gl.GetTexLevelParameteriv gl.DepthRange gl.Viewport gl 1.1 gl.DrawArrays gl.BindTexture gl.DeleteTextures gl.GenTextures gl 1.3 gl.ActiveTexture gl 1.5 gl.BindBuffer gl.DeleteBuffers gl.GenBuffers gl.BufferData gl.BufferSubData gl 2.0 gl.StencilOpSeparate gl.StencilFuncSeparate gl.StencilMaskSeparate gl.AttachShader gl.BindAttribLocation gl.CompileShader gl.CreateProgram gl.CreateShader gl.DeleteProgram gl.DeleteShader gl.DetachShader gl.EnableVertexAttribArray gl.GetAttribLocation gl.GetShaderiv gl.GetUniformLocation gl.LinkProgram gl.ShaderSource gl.UseProgram gl.Uniform1f gl.Uniform1i gl.VertexAttribPointer gl.VertexAttribPointerI32 gl 3.0 gl.BindRenderbuffer gl.DeleteRenderbuffers gl.GenRenderbuffers gl.RenderbufferStorage gl.BindFramebuffer gl.DeleteFramebuffers gl.GenFramebuffers gl.CheckFramebufferStatus gl.FramebufferTexture2D gl.FramebufferRenderbuffer gl.BindVertexArray gl.DeleteVertexArrays gl.GenVertexArrays","title":"gl"},{"location":"software/cx/package-gl/#using-gl-in-cx","text":"To use the gl-Functions you first have to import it: import \"gl\" Source Code Until the documentation on this page is finished please refer to the official opengl documentation","title":"Using gl in CX"},{"location":"software/cx/package-gl/#todo","text":"gogl gl.Init gl.Strs gl.Free gl.NewTexture gl.NewGIF gl.FreeGIF gl.GIFFrameToTexture gl 0.0 gl.MatrixMode gl.Rotatef gl.Translatef gl.LoadIdentity gl.PushMatrix gl.PopMatrix gl.EnableClientState gl.Color3f gl.Color4f gl.Begin gl.End gl.Normal3f gl.Vertex2f gl.Vertex3f gl.Lightfv gl.Frustum gl.TexEnvi gl.Ortho gl.Scalef gl.TexCoord2d gl.TexCoord2f gl 1.0 gl.CullFace gl.Hint gl.Scissor gl.TexParameteri gl.TexImage2D gl.Clear gl.ClearColor gl.ClearStencil gl.StencilMask gl.ColorMask gl.DepthMask gl.Disable gl.Enable gl.BlendFunc gl.StencilFunc gl.StencilOp gl.DepthFunc gl.GetError gl.GetTexLevelParameteriv gl.DepthRange gl.Viewport gl 1.1 gl.DrawArrays gl.BindTexture gl.DeleteTextures gl.GenTextures gl 1.3 gl.ActiveTexture gl 1.5 gl.BindBuffer gl.DeleteBuffers gl.GenBuffers gl.BufferData gl.BufferSubData gl 2.0 gl.StencilOpSeparate gl.StencilFuncSeparate gl.StencilMaskSeparate gl.AttachShader gl.BindAttribLocation gl.CompileShader gl.CreateProgram gl.CreateShader gl.DeleteProgram gl.DeleteShader gl.DetachShader gl.EnableVertexAttribArray gl.GetAttribLocation gl.GetShaderiv gl.GetUniformLocation gl.LinkProgram gl.ShaderSource gl.UseProgram gl.Uniform1f gl.Uniform1i gl.VertexAttribPointer gl.VertexAttribPointerI32 gl 3.0 gl.BindRenderbuffer gl.DeleteRenderbuffers gl.GenRenderbuffers gl.RenderbufferStorage gl.BindFramebuffer gl.DeleteFramebuffers gl.GenFramebuffers gl.CheckFramebufferStatus gl.FramebufferTexture2D gl.FramebufferRenderbuffer gl.BindVertexArray gl.DeleteVertexArrays gl.GenVertexArrays","title":"TODO"},{"location":"software/cx/package-glfw/","text":"Using glfw in CX To use the glfw-Functions you first have to import it: import \"glfw\" Source Code If you can't find any documentation on your problem have a look at the official glfw.org-documentation TODO glwf.PollEvents glfw.SwapBuffers glfw.GetFramebufferSize glfw.GetWindowPos glfw.GetWindowSize glfw.SwapInterval glfw.SetKeyCallback glfw.SetKeyCallbackEx glfw.GetTime glfw.SetMouseButtonCallback glfw.SetMouseButtonCallbackEx glfw.SetCursorPosCallback glfw.SetFramebufferSizeCallback glfw.SetWindowPosCallback glfw.SetWindowSizeCallback glfw.GetCursorPos glfw.SetInputMode glfw.SetWindowPos glfw.GetKey glfw.Fullscreen Functions glfw.Init Initializes the glfw-library glfw . Init () Example - > see glfw . CreateWindow glfw.WindowHint A function to save all setups for the next call of the function glfw.CreateWindow glfw . WindowHint ( hint i32 , value i32 ) Example - > see glfw . CreateWindow hints i32 see the glfw.org-documentation glfw.CreateWindow glfw . CreateWindow ( window_identifier str , window_width i32 , window_height i32 , window_caption str ) Example //glfw.Init, glfw.WindowHint, glfw.CreateWindow (,glfw.MakeContextCurrent) ////inputs var window_identifier str = \"Window1\" var window_widht i32 = 1920 //pixles var window_height i32 = 1000 //pixles var window_caption str = \"window-caption-example\" ////function call glfw . Init () glfw . WindowHint ( glfw . Resizable , glfw . False ) glfw . WindowHint ( glfw . ContextVersionMajor , 2 ) glfw . WindowHint ( glfw . ContextVersionMinor , 1 ) glfw . CreateWindow ( window_identifier , window_width , window_height , window_caption ) glfw . MakeContextCurrent ( window_identifier ) glfw.MakeContextCurrent Activates the given window glfw . MakeContextCurrent ( window_identifier str ) example - > see glfw . CreateWindow glfw.ShouldClose Returns if the given window should be closed glfw . ShouldClose ( window_identifier str )( should_close bool ) Example //glfw.ShouldClose ////input var window_identifier str = \"Window1\" ////output var should_close bool ////function call should_close = glfw . ShouldClose ( window_identifier str ) for bool . not ( should_close ){ //do something } ////function call alternative for bool . not ( glfw . ShouldClose ( window_identifier str )){ //do something } glfw.SetShouldClose Sets the ShouldClose of the given window to the given bool value glfw . SetShouldClose ( window_identifier str , should_close bool ) Example //glfw.SetShouldClose ////input var window_identifier str = \"Window1\" var should_close bool = true ////function call glfw . SetShouldClose ( window_identifier , should_close ) TODO: put constants into the functions where they are used Constants .False .True .Press .Release .Repeat .KeyUnknown .Cursor .StickyKeys .StickyMouseButtons .CursorNormal .CursorHidden .CursorDisabled .Resizable .ContextVersionMajor .ContextVersionMinor .Opengl.Coreprofile .Opengl.Profile .Opengl.ForwardCompatible .MouseButtonLast .MouseButtonLeft .MouseButtonRight .MouseButtonMiddle","title":"glfw"},{"location":"software/cx/package-glfw/#using-glfw-in-cx","text":"To use the glfw-Functions you first have to import it: import \"glfw\" Source Code If you can't find any documentation on your problem have a look at the official glfw.org-documentation TODO glwf.PollEvents glfw.SwapBuffers glfw.GetFramebufferSize glfw.GetWindowPos glfw.GetWindowSize glfw.SwapInterval glfw.SetKeyCallback glfw.SetKeyCallbackEx glfw.GetTime glfw.SetMouseButtonCallback glfw.SetMouseButtonCallbackEx glfw.SetCursorPosCallback glfw.SetFramebufferSizeCallback glfw.SetWindowPosCallback glfw.SetWindowSizeCallback glfw.GetCursorPos glfw.SetInputMode glfw.SetWindowPos glfw.GetKey glfw.Fullscreen","title":"Using glfw in CX"},{"location":"software/cx/package-glfw/#functions","text":"","title":"Functions"},{"location":"software/cx/package-glfw/#glfwinit","text":"Initializes the glfw-library glfw . Init () Example - > see glfw . CreateWindow","title":"glfw.Init"},{"location":"software/cx/package-glfw/#glfwwindowhint","text":"A function to save all setups for the next call of the function glfw.CreateWindow glfw . WindowHint ( hint i32 , value i32 ) Example - > see glfw . CreateWindow hints i32 see the glfw.org-documentation","title":"glfw.WindowHint"},{"location":"software/cx/package-glfw/#glfwcreatewindow","text":"glfw . CreateWindow ( window_identifier str , window_width i32 , window_height i32 , window_caption str ) Example //glfw.Init, glfw.WindowHint, glfw.CreateWindow (,glfw.MakeContextCurrent) ////inputs var window_identifier str = \"Window1\" var window_widht i32 = 1920 //pixles var window_height i32 = 1000 //pixles var window_caption str = \"window-caption-example\" ////function call glfw . Init () glfw . WindowHint ( glfw . Resizable , glfw . False ) glfw . WindowHint ( glfw . ContextVersionMajor , 2 ) glfw . WindowHint ( glfw . ContextVersionMinor , 1 ) glfw . CreateWindow ( window_identifier , window_width , window_height , window_caption ) glfw . MakeContextCurrent ( window_identifier )","title":"glfw.CreateWindow"},{"location":"software/cx/package-glfw/#glfwmakecontextcurrent","text":"Activates the given window glfw . MakeContextCurrent ( window_identifier str ) example - > see glfw . CreateWindow","title":"glfw.MakeContextCurrent"},{"location":"software/cx/package-glfw/#glfwshouldclose","text":"Returns if the given window should be closed glfw . ShouldClose ( window_identifier str )( should_close bool ) Example //glfw.ShouldClose ////input var window_identifier str = \"Window1\" ////output var should_close bool ////function call should_close = glfw . ShouldClose ( window_identifier str ) for bool . not ( should_close ){ //do something } ////function call alternative for bool . not ( glfw . ShouldClose ( window_identifier str )){ //do something }","title":"glfw.ShouldClose"},{"location":"software/cx/package-glfw/#glfwsetshouldclose","text":"Sets the ShouldClose of the given window to the given bool value glfw . SetShouldClose ( window_identifier str , should_close bool ) Example //glfw.SetShouldClose ////input var window_identifier str = \"Window1\" var should_close bool = true ////function call glfw . SetShouldClose ( window_identifier , should_close ) TODO: put constants into the functions where they are used","title":"glfw.SetShouldClose"},{"location":"software/cx/package-glfw/#constants","text":".False .True .Press .Release .Repeat .KeyUnknown .Cursor .StickyKeys .StickyMouseButtons .CursorNormal .CursorHidden .CursorDisabled .Resizable .ContextVersionMajor .ContextVersionMinor .Opengl.Coreprofile .Opengl.Profile .Opengl.ForwardCompatible .MouseButtonLast .MouseButtonLeft .MouseButtonRight .MouseButtonMiddle","title":"Constants"},{"location":"software/cx/package-gltext/","text":"Using gltext in CX To use the gltext-Functions you first have to import it: import \"gltext\" Source Code gltext.LoadTrueType This Function saves your font settings. You then can access your settings by the font_setting_identifier string you have given to the function. gltext . LoadTrueType ( font_setting_identifier str , font_file_directory str , scaleToPixelHeight i32 , low i32 , high i32 , direction i32 )() Example //gltext.LoadTrueType ////input var font_setting_identifier str = \"Roboto100\" var font_file_directory str = str . concat ( os . GetWorkingDirectory (), \"fonts/skycoin_light.ttf\" ) var scaleToPixelHeight i32 = 100 var direction i32 = gltext . LeftToRight ////function call os . Open ( font_file_directory ) gltext . LoadTrueType ( font_setting_identifier , font_file_directory , scaleToPixelHeight , 32 , 127 , direction ) os . Close ( font_file_directory ) low and high are the lower and upper rune limits, for standard ASCII low = 32, high = 127 directions i32: gltext . LeftToRight gltext . RightToLeft gltext . TopToBottom gltext.GlyphBounds Returns the width and height of the biggest rune of the given, loaded font setting gltext . GlyphBounds ( font_setting_identifier str )( width i32 , height i32 ) Example //gltext.GlyphBounds ////input var font_setting_identifier str = \"Roboto100\" ////output var width i32 var height i32 ////function call width , height = gltext . GlyphBounds ( font_setting_identifier ) gltext.GlyphMetrics Returns the width and height of the given glyph texture gltext . GlyphMetrics ( font_setting_identifier str , glyph_texture i32 )( width i32 , height i32 ) Example //gltext.Metrics ////input var font_setting_identifier str = \"Roboto100\" var glyph_texture i32 = gl . NewTexture ( sprintf ( \"%s%s%s\" , os . GetWorkingDirectory (), \"fonts/glyphs/\" , \"test-glyph.png\" )) ////output var width i32 var height i32 ////function call width , height = gltext . Metrics ( font_setting_identifier , glyph_texture ) gltext.GlyphInfo Returns all possible infos of the given glyph_texture gltext . GlyphInfo ( font_setting_identifier str , glyph_texture i32 )( x i32 , y i32 , width i32 , height i32 , advanced_size i32 ) Example //gltext.GlyphInfo ////input var font_setting_identifier str = \"Roboto100\" var glyph_texture i32 = gl . NewTexture ( sprintf ( \"%s%s%s\" , os . GetWorkingDirectory (), \"fonts/glyphs/\" , \"test-glyph.png\" )) ////output var x i32 //the x location of the glpyh on a sprite sheet var y i32 //the y location of the glpyh on a sprite sheet var width i32 var height i32 var advanced_size i32 //the distance to the next glyph ////function call x , y , width , height , advanced_size = gltext . Metrics ( font_setting_identifier , string_to_analyze ) gltext.Metrics Returns the width and the height of the given string gltext . Metrics ( font_setting_identifier str , string_to_analyze str ) ( width i32 , height i32 ) Example //gltext.Metrics() ////input var font_setting_identifier str = \"Roboto100\" var string_to_analyze str = \"Hello World\" ////output var width i32 var height i32 ////function call width , height = gltext . Metrics ( font_setting_identifier , string_to_analyze ) gltext.NextGlyph Returns all infos of the indexed char-glyph of the given string gltext . NextGlyph ( font_setting_identifier str , string_to_analyze str , index i32 ) ( glyph_texture i32 , width_in_bytes i32 , x i32 , y i32 , width i32 , height i32 , advanced_size i32 ) Example //gltext.NextGlyph ////input var font_setting_identifier str = \"Roboto100\" var string_to_analyze str = \"Hello World\" var index i32 = 2 ////output var glyph_texture i32 var width_in_bytes i32 var x i32 //the x location of the glpyh on a sprite sheet var y i32 //the y location of the glpyh on a sprite sheet var width i32 var height i32 var advanced_size i32 //the distance to the next glyph ////function call glyph_texture , width_in_bytes , x , y , width , height , advanced_size = gltext . NextGlyph ( font_setting_identifier , string_to_analyze , index ) gltext.Printf Prints the given string on the absolute pixel position of the screen gltext . Printf ( font_setting_identifier str , x_position f32 , y_position f32 , string_to_print str ) Example //gltext.Printf ////input var font_setting_identifier str = \"Roboto100\" var x_position f32 = 0.0 var y_position f32 = 0.0 var string_to_print str = \"Hello World\" ////function call gl . Color4f ( 0.5 , 0.3 , 0.8 , 1.0 ) //With this function call you can setup the color of your text gltext . Printf ( font_setting_identifier , x_position , y_position , string_to_print ) gltext.Texture Returns the number/index of the loaded font gltext . Texture ( font_setting_identifier str )( number_of_loaded_font i32 ) Example //gltext.Texture ////input var font_setting_identifier str = \"Roboto100\" ////output var number_of_loaded_font i32 ////function call number_of_loaded_font = gltext . Texture ( font_setting_identifier )","title":"gltext"},{"location":"software/cx/package-gltext/#using-gltext-in-cx","text":"To use the gltext-Functions you first have to import it: import \"gltext\" Source Code","title":"Using gltext in CX"},{"location":"software/cx/package-gltext/#gltextloadtruetype","text":"This Function saves your font settings. You then can access your settings by the font_setting_identifier string you have given to the function. gltext . LoadTrueType ( font_setting_identifier str , font_file_directory str , scaleToPixelHeight i32 , low i32 , high i32 , direction i32 )() Example //gltext.LoadTrueType ////input var font_setting_identifier str = \"Roboto100\" var font_file_directory str = str . concat ( os . GetWorkingDirectory (), \"fonts/skycoin_light.ttf\" ) var scaleToPixelHeight i32 = 100 var direction i32 = gltext . LeftToRight ////function call os . Open ( font_file_directory ) gltext . LoadTrueType ( font_setting_identifier , font_file_directory , scaleToPixelHeight , 32 , 127 , direction ) os . Close ( font_file_directory ) low and high are the lower and upper rune limits, for standard ASCII low = 32, high = 127 directions i32: gltext . LeftToRight gltext . RightToLeft gltext . TopToBottom","title":"gltext.LoadTrueType"},{"location":"software/cx/package-gltext/#gltextglyphbounds","text":"Returns the width and height of the biggest rune of the given, loaded font setting gltext . GlyphBounds ( font_setting_identifier str )( width i32 , height i32 ) Example //gltext.GlyphBounds ////input var font_setting_identifier str = \"Roboto100\" ////output var width i32 var height i32 ////function call width , height = gltext . GlyphBounds ( font_setting_identifier )","title":"gltext.GlyphBounds"},{"location":"software/cx/package-gltext/#gltextglyphmetrics","text":"Returns the width and height of the given glyph texture gltext . GlyphMetrics ( font_setting_identifier str , glyph_texture i32 )( width i32 , height i32 ) Example //gltext.Metrics ////input var font_setting_identifier str = \"Roboto100\" var glyph_texture i32 = gl . NewTexture ( sprintf ( \"%s%s%s\" , os . GetWorkingDirectory (), \"fonts/glyphs/\" , \"test-glyph.png\" )) ////output var width i32 var height i32 ////function call width , height = gltext . Metrics ( font_setting_identifier , glyph_texture )","title":"gltext.GlyphMetrics"},{"location":"software/cx/package-gltext/#gltextglyphinfo","text":"Returns all possible infos of the given glyph_texture gltext . GlyphInfo ( font_setting_identifier str , glyph_texture i32 )( x i32 , y i32 , width i32 , height i32 , advanced_size i32 ) Example //gltext.GlyphInfo ////input var font_setting_identifier str = \"Roboto100\" var glyph_texture i32 = gl . NewTexture ( sprintf ( \"%s%s%s\" , os . GetWorkingDirectory (), \"fonts/glyphs/\" , \"test-glyph.png\" )) ////output var x i32 //the x location of the glpyh on a sprite sheet var y i32 //the y location of the glpyh on a sprite sheet var width i32 var height i32 var advanced_size i32 //the distance to the next glyph ////function call x , y , width , height , advanced_size = gltext . Metrics ( font_setting_identifier , string_to_analyze )","title":"gltext.GlyphInfo"},{"location":"software/cx/package-gltext/#gltextmetrics","text":"Returns the width and the height of the given string gltext . Metrics ( font_setting_identifier str , string_to_analyze str ) ( width i32 , height i32 ) Example //gltext.Metrics() ////input var font_setting_identifier str = \"Roboto100\" var string_to_analyze str = \"Hello World\" ////output var width i32 var height i32 ////function call width , height = gltext . Metrics ( font_setting_identifier , string_to_analyze )","title":"gltext.Metrics"},{"location":"software/cx/package-gltext/#gltextnextglyph","text":"Returns all infos of the indexed char-glyph of the given string gltext . NextGlyph ( font_setting_identifier str , string_to_analyze str , index i32 ) ( glyph_texture i32 , width_in_bytes i32 , x i32 , y i32 , width i32 , height i32 , advanced_size i32 ) Example //gltext.NextGlyph ////input var font_setting_identifier str = \"Roboto100\" var string_to_analyze str = \"Hello World\" var index i32 = 2 ////output var glyph_texture i32 var width_in_bytes i32 var x i32 //the x location of the glpyh on a sprite sheet var y i32 //the y location of the glpyh on a sprite sheet var width i32 var height i32 var advanced_size i32 //the distance to the next glyph ////function call glyph_texture , width_in_bytes , x , y , width , height , advanced_size = gltext . NextGlyph ( font_setting_identifier , string_to_analyze , index )","title":"gltext.NextGlyph"},{"location":"software/cx/package-gltext/#gltextprintf","text":"Prints the given string on the absolute pixel position of the screen gltext . Printf ( font_setting_identifier str , x_position f32 , y_position f32 , string_to_print str ) Example //gltext.Printf ////input var font_setting_identifier str = \"Roboto100\" var x_position f32 = 0.0 var y_position f32 = 0.0 var string_to_print str = \"Hello World\" ////function call gl . Color4f ( 0.5 , 0.3 , 0.8 , 1.0 ) //With this function call you can setup the color of your text gltext . Printf ( font_setting_identifier , x_position , y_position , string_to_print )","title":"gltext.Printf"},{"location":"software/cx/package-gltext/#gltexttexture","text":"Returns the number/index of the loaded font gltext . Texture ( font_setting_identifier str )( number_of_loaded_font i32 ) Example //gltext.Texture ////input var font_setting_identifier str = \"Roboto100\" ////output var number_of_loaded_font i32 ////function call number_of_loaded_font = gltext . Texture ( font_setting_identifier )","title":"gltext.Texture"},{"location":"software/cx/package-os/","text":"Using os in CX To use the time-Functions you first have to import it: import \"os\" Source Code os.GetWorkingDirectory This function returns the directory of your running program os . GetWorkingDirectory ()( working_directory str ) Example //os.GetWorkingDirectory ////output var working_directory str ////function call working_directory = os . GetWorkingDirectory () os.Open This function opens the given file. Don't forget to close it, after you used it. os . Open ( file_directory str ) Example //os.Open ////input var file_directory str = \"C:/Files/testfile.txt\" ////function call os . Open ( file_directory ) os.Open This function closes the given and open file os . Close ( file_directory str ) Example //os.Close ////input var file_directory str = \"C:/Files/testfile.txt\" ////function call os . Close ( file_directory )","title":"os"},{"location":"software/cx/package-os/#using-os-in-cx","text":"To use the time-Functions you first have to import it: import \"os\" Source Code","title":"Using os in CX"},{"location":"software/cx/package-os/#osgetworkingdirectory","text":"This function returns the directory of your running program os . GetWorkingDirectory ()( working_directory str ) Example //os.GetWorkingDirectory ////output var working_directory str ////function call working_directory = os . GetWorkingDirectory ()","title":"os.GetWorkingDirectory"},{"location":"software/cx/package-os/#osopen","text":"This function opens the given file. Don't forget to close it, after you used it. os . Open ( file_directory str ) Example //os.Open ////input var file_directory str = \"C:/Files/testfile.txt\" ////function call os . Open ( file_directory )","title":"os.Open"},{"location":"software/cx/package-os/#osopen_1","text":"This function closes the given and open file os . Close ( file_directory str ) Example //os.Close ////input var file_directory str = \"C:/Files/testfile.txt\" ////function call os . Close ( file_directory )","title":"os.Open"},{"location":"software/cx/package-time/","text":"Using time in CX To use the time-Functions you first have to import it: import \"time\" Source Code time.Sleep By calling this function you force the code to pause the given amount of milliseconds time . Sleep ( milliseconds_to_pause i32 ) Example //time.Sleep ////input var milliseconds_to_pause i32 = 1000 ////function call time . Sleep ( milliseconds_to_pause ) time.UnixMilli This function returns the elapsed milliseconds since 01.01.1970 UTC time . UnixMilli ()( milliseconds_since_01011970 i64 ) Example //time.UnixMilli ////output var milliseconds_since_01011970 i64 ////function call milliseconds_since_01011970 = time . UnixMilli () time.UnixNano This function returns the elapsed nanoseconds since 01.01.1970 UTC time . UnixNano ()( nanoseconds_since_01011970 i64 ) Example //time.UnixNano ////output var nanoseconds_since_01011970 i64 ////function call nanoseconds_since_01011970 = time . UnixNano ()","title":"time"},{"location":"software/cx/package-time/#using-time-in-cx","text":"To use the time-Functions you first have to import it: import \"time\" Source Code","title":"Using time in CX"},{"location":"software/cx/package-time/#timesleep","text":"By calling this function you force the code to pause the given amount of milliseconds time . Sleep ( milliseconds_to_pause i32 ) Example //time.Sleep ////input var milliseconds_to_pause i32 = 1000 ////function call time . Sleep ( milliseconds_to_pause )","title":"time.Sleep"},{"location":"software/cx/package-time/#timeunixmilli","text":"This function returns the elapsed milliseconds since 01.01.1970 UTC time . UnixMilli ()( milliseconds_since_01011970 i64 ) Example //time.UnixMilli ////output var milliseconds_since_01011970 i64 ////function call milliseconds_since_01011970 = time . UnixMilli ()","title":"time.UnixMilli"},{"location":"software/cx/package-time/#timeunixnano","text":"This function returns the elapsed nanoseconds since 01.01.1970 UTC time . UnixNano ()( nanoseconds_since_01011970 i64 ) Example //time.UnixNano ////output var nanoseconds_since_01011970 i64 ////function call nanoseconds_since_01011970 = time . UnixNano ()","title":"time.UnixNano"},{"location":"software/cxfx/","text":"CXFX CXFX is a 3D Game Engine, that will deliver all the things needed to develop a Game of your choice. What will be possible and what already is you can see on the Roadmap . CXFX supports: macOS Windows Linux Android iOS. If you want to help here is How to contribute . Getting Started TODO Basics TODO Tutorials Here we will link all known links that use CXFX in the future Open-Source Projects Skylight Social Networks Github CXFX Development Repository Telegram Skycxfx Twitter skycoincxfx","title":"Introduction"},{"location":"software/cxfx/#cxfx","text":"CXFX is a 3D Game Engine, that will deliver all the things needed to develop a Game of your choice. What will be possible and what already is you can see on the Roadmap . CXFX supports: macOS Windows Linux Android iOS. If you want to help here is How to contribute .","title":"CXFX"},{"location":"software/cxfx/#getting-started","text":"TODO","title":"Getting Started"},{"location":"software/cxfx/#basics","text":"TODO","title":"Basics"},{"location":"software/cxfx/#tutorials","text":"Here we will link all known links that use CXFX in the future","title":"Tutorials"},{"location":"software/cxfx/#open-source-projects","text":"Skylight","title":"Open-Source Projects"},{"location":"software/cxfx/#social-networks","text":"","title":"Social Networks"},{"location":"software/cxfx/#github","text":"CXFX Development Repository","title":"Github"},{"location":"software/cxfx/#telegram","text":"Skycxfx","title":"Telegram"},{"location":"software/cxfx/#twitter","text":"skycoincxfx","title":"Twitter"},{"location":"software/cxfx/roadmap/","text":"Roadmap Well this is actually not a roadmap, but something similar: Wip: math: matrix basic matrix operations vector quaternion spline graphics: textures: texture 2d generate mipmaps load mipmaps texture cube generate mipmaps load mipmaps texture array texture 3d texture compression srgb shaders: shader permutations shader hot reload shader reflection (parse glsl and extract uniforms) shader uniform binding in gui rendering: physically based renderer kronos implementation debug diffuse irradiance specular irradiance hdr maps custom brdf realtime cubemap normal map emmissive map occlusion map output scene depth in a texture multiple render targets order independent transparency particles moving emitters anti aliasing atmospheric scattering terrain audio: wav 8bps/16bps wav f32/f64 3d audio audio streaming: compressed audio phycics: collision/intersection/response ellipsoid/triangle ellipsoid/ellipsoid ray/ellipsoid ray/OBB ray/AABB gravity torque cameras: free camera first person camera third person camera smooth motions cinematic camera gltf support (loader/renderer/exporter): flat mesh textured mesh hierarchical mesh pbr materials skinning animations cameras lights exporter 2d gui toolkit: game screens label picture scrollbar list json serialization application: resize events toggle fullscreen cli mobile: virtual keyboard ios android skycoin: cxo cxchain","title":"Roadmap"},{"location":"software/cxfx/roadmap/#roadmap","text":"Well this is actually not a roadmap, but something similar:","title":"Roadmap"},{"location":"software/cxfx/roadmap/#wip","text":"math: matrix basic matrix operations vector quaternion spline graphics: textures: texture 2d generate mipmaps load mipmaps texture cube generate mipmaps load mipmaps texture array texture 3d texture compression srgb shaders: shader permutations shader hot reload shader reflection (parse glsl and extract uniforms) shader uniform binding in gui rendering: physically based renderer kronos implementation debug diffuse irradiance specular irradiance hdr maps custom brdf realtime cubemap normal map emmissive map occlusion map output scene depth in a texture multiple render targets order independent transparency particles moving emitters anti aliasing atmospheric scattering terrain audio: wav 8bps/16bps wav f32/f64 3d audio audio streaming: compressed audio phycics: collision/intersection/response ellipsoid/triangle ellipsoid/ellipsoid ray/ellipsoid ray/OBB ray/AABB gravity torque cameras: free camera first person camera third person camera smooth motions cinematic camera gltf support (loader/renderer/exporter): flat mesh textured mesh hierarchical mesh pbr materials skinning animations cameras lights exporter 2d gui toolkit: game screens label picture scrollbar list json serialization application: resize events toggle fullscreen cli mobile: virtual keyboard ios android skycoin: cxo cxchain","title":"Wip:"},{"location":"software/cxo/","text":"CXO CXO (CX Object Systems) is the Skycoin immutable object system, previously called Aether. Designed to replace current conventional methods of peer-to-peer sharing, CXO creates a robust storage system that supersedes services like BitTorrent, Dropbox, and Google Drive. Data is replicated peer-to-peer utilizing the Skycoin CXO library. CXO incorporates and expands on the protocols utilized in other blockchain-based storage networks. CXO is an IPLD, with a built-in schema that sets constraints to classify relatable databases. InterPlanetary File Systems (IPFS) can be built on top of CXO. CXO provides data distribution over the Skywire network and is useful for data that must be secure and verifiable yet doesn't need storage on the blockchain. Simply, it is a low-level library designed to house applications for sharing objects. CXO acts as Content Addressable Storage (CAS) for Content Distribution Networks (CDNs). Data Sharing: Useful for data owners who want to share information, as it can share many feeds like public keys. CXO nodes can subscribe to a feed to receive updates and can connect using the discovery server, interconnecting data based on interests. Privacy: CXO data exists collectively over the network. Once data is published, it cannot be destroyed, and data feeds are downloaded from peer subscribers. For privacy, the publisher\u2019s location cannot be tracked as the publisher becomes merely a peer on the decentralized network Security: CXO exists within a self-contained standard ecosystem that is mathematically strict and is implemented from the ground up. The owners sign data using private keys, and users who receive the data can audit the signature through the use of public key feeds to be sure the data comes from the desired owner. Security is ensured because nodes cannot alter data without the use of the owner\u2019s private keys. CXO Applications: Applications on CXO are currently being tested with light use. SkyBBS is a social network similar to Facebook, Steemit, and Twitter, and is built on top of CXO, with many more to come. Getting Started TODO Tutorials Medium: How to use skycoins cxo 2.0 Open-Source Projects Here we will link Projects that use CXO 2 in the future. Apps Social Networks Telegram SkycoinCXO Skycoincxorus","title":"Introduction"},{"location":"software/cxo/#cxo","text":"CXO (CX Object Systems) is the Skycoin immutable object system, previously called Aether. Designed to replace current conventional methods of peer-to-peer sharing, CXO creates a robust storage system that supersedes services like BitTorrent, Dropbox, and Google Drive. Data is replicated peer-to-peer utilizing the Skycoin CXO library. CXO incorporates and expands on the protocols utilized in other blockchain-based storage networks. CXO is an IPLD, with a built-in schema that sets constraints to classify relatable databases. InterPlanetary File Systems (IPFS) can be built on top of CXO. CXO provides data distribution over the Skywire network and is useful for data that must be secure and verifiable yet doesn't need storage on the blockchain. Simply, it is a low-level library designed to house applications for sharing objects. CXO acts as Content Addressable Storage (CAS) for Content Distribution Networks (CDNs). Data Sharing: Useful for data owners who want to share information, as it can share many feeds like public keys. CXO nodes can subscribe to a feed to receive updates and can connect using the discovery server, interconnecting data based on interests. Privacy: CXO data exists collectively over the network. Once data is published, it cannot be destroyed, and data feeds are downloaded from peer subscribers. For privacy, the publisher\u2019s location cannot be tracked as the publisher becomes merely a peer on the decentralized network Security: CXO exists within a self-contained standard ecosystem that is mathematically strict and is implemented from the ground up. The owners sign data using private keys, and users who receive the data can audit the signature through the use of public key feeds to be sure the data comes from the desired owner. Security is ensured because nodes cannot alter data without the use of the owner\u2019s private keys. CXO Applications: Applications on CXO are currently being tested with light use. SkyBBS is a social network similar to Facebook, Steemit, and Twitter, and is built on top of CXO, with many more to come.","title":"CXO"},{"location":"software/cxo/#getting-started","text":"TODO","title":"Getting Started"},{"location":"software/cxo/#tutorials","text":"Medium: How to use skycoins cxo 2.0","title":"Tutorials"},{"location":"software/cxo/#open-source-projects","text":"Here we will link Projects that use CXO 2 in the future.","title":"Open-Source Projects"},{"location":"software/cxo/#apps","text":"","title":"Apps"},{"location":"software/cxo/#social-networks","text":"","title":"Social Networks"},{"location":"software/cxo/#telegram","text":"SkycoinCXO Skycoincxorus","title":"Telegram"},{"location":"software/fiber/","text":"TODO: write about what the fiber platform is Links: https://medium.com/skycoin/skycoin-fiber-platform-bf64debfc60f https://medium.com/skyfleet-captains-log/launch-your-ico-on-skycoin-fiber-bda2a9d45062 include tutorials on how to make a new coin and more Links: https://github.com/skycoinproject/skycoin/blob/ebfab5447157123159aec83e39f279e05f0fe34f/cmd/newcoin/README.md https://medium.com/@bigookie/do-you-want-to-build-a-skycoin-node-f8a0548617f0 https://medium.com/@bigookie/do-you-want-to-build-a-load-balanced-skycoin-node-8630f818ad31 https://www.skycoin.com/docs/dev-docs/guides/","title":"Introduction"},{"location":"software/fiber/fiber-coins/","text":"Here is a list of all projects that use the fiber-platform Can't find your project here? If you are using fiber, you can't find your project here and want to be listed, just do a pull request to this repo with the updated data (please insert your project in aphabetical order ) or open an issue here . Project Coin Description Website ... MDL Talent Hub MDL Gig Economy mdl.life PrivateNess Network NESS Blockchain as a Service (BaaS) privateness.network SolarBankers SBL Microgrid solarbankers.com","title":"Fiber-Projects"},{"location":"software/skycoin/","text":"Skycoin Skycoin (SKY) What is Skycoin? Skycoin is a next-generation cryptocurrency. Skycoin was written from scratch and designed over four years to realize the ideal of Bitcoin and represents the apex of cryptocurrency design. Skycoin is not designed to add features to Bitcoin, but rather improves Bitcoin by increasing simplicity, security and stripping out everything non-essential. Some people have hyped the Skycoin Project as leading into \"Bitcoin 3.0\". The coin itself is not \"Bitcoin 3.0\", but is rather \"Bitcoin 1.0\". Bitcoin is a prototype crypto-coin. Skycoin was designed to be what Bitcoin would look like if it were built from scratch, to remedy the rough edges in the Bitcoin design. no duplicate coin-base outputs enforced checks for hash collisions simple deterministic wallets no transaction malleability no signature malleability removal of the scripting language CoinJoin and normal transactions are indistinguishable elimination of edge-cases that prevent independent node implementations <=10 second transaction times elimination of the need for mining to achieve blockchain consensus Consensus Medium Article: A comprehensive guide to the consensus and skycoin obelisk Medium Article Audio Version: Telegram Message Link CoinHours (SCH) What are coin hours? Coin hours are a parallel currency within the Skycoin blockchain, alongside skycoins. Coin hours are used to pay transaction fees in the network. In the future, coin hours will be used in other applications beyond the Skycoin cryptocurrency, such as Skywire . Coin hours are generated based upon the age of coins in a transaction output. What is a transaction output? A Skycoin transaction consumes one or more outputs and creates one or more outputs. Each output has an owner address, an amount of coins and an amount of hours. When you send coins to someone, you destroy some outputs that are owned by addresses in your wallet and you create some new outputs. How are coin hours generated? For every 1 coin in an output, 1 coin hour is created after 1 hour elapses. Time is measured between the blockchain's current head block timestamp and the timestamp of the block in which the output was created. Internally, the value is calculated as \"coin seconds\", then rounded down to the nearest whole coin hour. This implies that: A 0.1 skycoin output generates 1 coin hour every 10 hours (36000 seconds) A 1 skycoin output generates 1 coin hour every 1 hour (3600 seconds) A 10 skycoin output generates 1 coin hour every 6 minutes (360 seconds) Generated coin hours are calculated at the time that the output is spent, and are added to the output's initial coin hours. The elapsed time is the timestamp of the previous block, not a computer's clock time. How are coin hours used for transaction fees? A transaction must destroy a percent of its total input coin hours in order to be valid. It can optionally destroy more, to prioritize the transaction in a congested network. Currently, the percent that must be destroyed is 10%. The value is always rounded up (i.e., if there are 5 input coin hours, 3 must be destroyed). A transaction must destroy at least 1 coin hour. Transactions are prioritized for inclusion in a block by their coin hour burn fee per byte. Larger transactions (measured in bytes) require a higher amount of coin hours burned to achieve a higher priority. Wallets There are three options to hold Skycoin and generate SCH while holding. Software Desktop: Windows, MacOS, Linux Mobile:Android, iOS Download your wallet from the official Website here Hardware At the moment you can hold SKY only on the Skywallet. Read more here Buy it from the offical store Exchanges See here on what exchanges you can buy SKY or SCH Social Networks Telegram Skycoin Skycoin Trading (Price Discussion) Skycoin News Skyfleet News Reddit r/skycoin","title":"Introduction"},{"location":"software/skycoin/#skycoin","text":"","title":"Skycoin"},{"location":"software/skycoin/#skycoin-sky","text":"","title":"Skycoin (SKY)"},{"location":"software/skycoin/#what-is-skycoin","text":"Skycoin is a next-generation cryptocurrency. Skycoin was written from scratch and designed over four years to realize the ideal of Bitcoin and represents the apex of cryptocurrency design. Skycoin is not designed to add features to Bitcoin, but rather improves Bitcoin by increasing simplicity, security and stripping out everything non-essential. Some people have hyped the Skycoin Project as leading into \"Bitcoin 3.0\". The coin itself is not \"Bitcoin 3.0\", but is rather \"Bitcoin 1.0\". Bitcoin is a prototype crypto-coin. Skycoin was designed to be what Bitcoin would look like if it were built from scratch, to remedy the rough edges in the Bitcoin design. no duplicate coin-base outputs enforced checks for hash collisions simple deterministic wallets no transaction malleability no signature malleability removal of the scripting language CoinJoin and normal transactions are indistinguishable elimination of edge-cases that prevent independent node implementations <=10 second transaction times elimination of the need for mining to achieve blockchain consensus","title":"What is Skycoin?"},{"location":"software/skycoin/#consensus","text":"Medium Article: A comprehensive guide to the consensus and skycoin obelisk Medium Article Audio Version: Telegram Message Link","title":"Consensus"},{"location":"software/skycoin/#coinhours-sch","text":"","title":"CoinHours (SCH)"},{"location":"software/skycoin/#what-are-coin-hours","text":"Coin hours are a parallel currency within the Skycoin blockchain, alongside skycoins. Coin hours are used to pay transaction fees in the network. In the future, coin hours will be used in other applications beyond the Skycoin cryptocurrency, such as Skywire . Coin hours are generated based upon the age of coins in a transaction output.","title":"What are coin hours?"},{"location":"software/skycoin/#what-is-a-transaction-output","text":"A Skycoin transaction consumes one or more outputs and creates one or more outputs. Each output has an owner address, an amount of coins and an amount of hours. When you send coins to someone, you destroy some outputs that are owned by addresses in your wallet and you create some new outputs.","title":"What is a transaction output?"},{"location":"software/skycoin/#how-are-coin-hours-generated","text":"For every 1 coin in an output, 1 coin hour is created after 1 hour elapses. Time is measured between the blockchain's current head block timestamp and the timestamp of the block in which the output was created. Internally, the value is calculated as \"coin seconds\", then rounded down to the nearest whole coin hour. This implies that: A 0.1 skycoin output generates 1 coin hour every 10 hours (36000 seconds) A 1 skycoin output generates 1 coin hour every 1 hour (3600 seconds) A 10 skycoin output generates 1 coin hour every 6 minutes (360 seconds) Generated coin hours are calculated at the time that the output is spent, and are added to the output's initial coin hours. The elapsed time is the timestamp of the previous block, not a computer's clock time.","title":"How are coin hours generated?"},{"location":"software/skycoin/#how-are-coin-hours-used-for-transaction-fees","text":"A transaction must destroy a percent of its total input coin hours in order to be valid. It can optionally destroy more, to prioritize the transaction in a congested network. Currently, the percent that must be destroyed is 10%. The value is always rounded up (i.e., if there are 5 input coin hours, 3 must be destroyed). A transaction must destroy at least 1 coin hour. Transactions are prioritized for inclusion in a block by their coin hour burn fee per byte. Larger transactions (measured in bytes) require a higher amount of coin hours burned to achieve a higher priority.","title":"How are coin hours used for transaction fees?"},{"location":"software/skycoin/#wallets","text":"There are three options to hold Skycoin and generate SCH while holding.","title":"Wallets"},{"location":"software/skycoin/#software","text":"Desktop: Windows, MacOS, Linux Mobile:Android, iOS Download your wallet from the official Website here","title":"Software"},{"location":"software/skycoin/#hardware","text":"At the moment you can hold SKY only on the Skywallet. Read more here Buy it from the offical store","title":"Hardware"},{"location":"software/skycoin/#exchanges","text":"See here on what exchanges you can buy SKY or SCH","title":"Exchanges"},{"location":"software/skycoin/#social-networks","text":"","title":"Social Networks"},{"location":"software/skycoin/#telegram","text":"Skycoin Skycoin Trading (Price Discussion) Skycoin News Skyfleet News","title":"Telegram"},{"location":"software/skycoin/#reddit","text":"r/skycoin","title":"Reddit"},{"location":"software/skywire/","text":"Skywire What is Skywire? Skywire is the next evolutionary step in the Internet's development and use. We want to break the choke-hold that Internet service providers (ISPs) have on the market by giving the power back to the people. We are doing this by providing a decentralized community-driven mesh network where users themselves will own and control the network\u2019s infrastructure. Our goal is to provide everyone with access to fast, secure, private and reliable Internet. It is time to leave ISPs as a relic of the past. Customers routinely have their browsing data tracked, stored and sold by ISPs, and at the same time experience unreliable coverage and poor customer service. Instead of relying on corporate-owned networks, the Skywire mesh network runs on widespread user-owned nodes which come together to provide the infrastructure for the network, allowing communities to power their internet access. Skywire is an incentivized meshnet and darknet which runs on a dedicated hardware backbone of official Skyminers containing proprietary technologies and DIY Skyminers made of consumer-grade hardware which can be bought off the shelf from around the globe at widely affordable rates. Skywire acts as a truly secure VPN and SOCKS5 proxy which can also connect to the legacy Internet. It circumvents the corrupt ISPs, telecoms, and government services which spy upon our internet traffic to sell our data to each other or worse. The meshnet of Skyminers allows users Skywire to financially profit by transmitting one another's encrypted traffic data in exchange for $SCH Coin Hours. Selling your unused bandwidth acts as a new form of passive income. Skywire is also the first bandwidth market in history. It is additionally hardware agnostic so users can profit from running it on any system with the computational capability of doing so. Skywire is the new Internet. It is making online life safer, faster, and more profitable for users than ever before. YouTube: What is the Skywire Decentralized Internet? A Skywire Primer Adoption Plan Social Networks Telegram Skywire Skywire Mainnet PSA Skywire Antenna Group Skywire NYC","title":"Introduction"},{"location":"software/skywire/#skywire","text":"","title":"Skywire"},{"location":"software/skywire/#what-is-skywire","text":"Skywire is the next evolutionary step in the Internet's development and use. We want to break the choke-hold that Internet service providers (ISPs) have on the market by giving the power back to the people. We are doing this by providing a decentralized community-driven mesh network where users themselves will own and control the network\u2019s infrastructure. Our goal is to provide everyone with access to fast, secure, private and reliable Internet. It is time to leave ISPs as a relic of the past. Customers routinely have their browsing data tracked, stored and sold by ISPs, and at the same time experience unreliable coverage and poor customer service. Instead of relying on corporate-owned networks, the Skywire mesh network runs on widespread user-owned nodes which come together to provide the infrastructure for the network, allowing communities to power their internet access. Skywire is an incentivized meshnet and darknet which runs on a dedicated hardware backbone of official Skyminers containing proprietary technologies and DIY Skyminers made of consumer-grade hardware which can be bought off the shelf from around the globe at widely affordable rates. Skywire acts as a truly secure VPN and SOCKS5 proxy which can also connect to the legacy Internet. It circumvents the corrupt ISPs, telecoms, and government services which spy upon our internet traffic to sell our data to each other or worse. The meshnet of Skyminers allows users Skywire to financially profit by transmitting one another's encrypted traffic data in exchange for $SCH Coin Hours. Selling your unused bandwidth acts as a new form of passive income. Skywire is also the first bandwidth market in history. It is additionally hardware agnostic so users can profit from running it on any system with the computational capability of doing so. Skywire is the new Internet. It is making online life safer, faster, and more profitable for users than ever before. YouTube: What is the Skywire Decentralized Internet? A Skywire Primer","title":"What is Skywire?"},{"location":"software/skywire/#adoption-plan","text":"","title":"Adoption Plan"},{"location":"software/skywire/#social-networks","text":"","title":"Social Networks"},{"location":"software/skywire/#telegram","text":"Skywire Skywire Mainnet PSA Skywire Antenna Group Skywire NYC","title":"Telegram"},{"location":"software/skywire/architecture/","text":"","title":"Architecture"},{"location":"software/skywire/authentication/","text":"","title":"Authentication"},{"location":"software/skywire/discovery/","text":"Official Visor Uptime Tracker Whitelisting Skyfleet Warning The following options are not maintained by skycoin. It is not guaranteed that the information on these is right or up to date. Websites Skycoin.si bchain.ovh Tools Wing-Commander (Telegram-Bot)","title":"Discovery & Uptime"},{"location":"software/skywire/discovery/#official","text":"Visor Uptime Tracker Whitelisting","title":"Official"},{"location":"software/skywire/discovery/#skyfleet","text":"Warning The following options are not maintained by skycoin. It is not guaranteed that the information on these is right or up to date.","title":"Skyfleet"},{"location":"software/skywire/discovery/#websites","text":"Skycoin.si bchain.ovh","title":"Websites"},{"location":"software/skywire/discovery/#tools","text":"Wing-Commander (Telegram-Bot)","title":"Tools"},{"location":"software/skywire/installation-linux/","text":"From Source Requirements Skywire requires a version of golang with go modules support. apt apt-get install golang check your version with go version manually TODO: Add commands Build Follow the steps by copy & paste-ing all the commands into your terminal. Installation Directory Move into the folder where you want to install skywire with the command cd For example: cd $HOME /apps Clone Clone the repository. git clone https://github.com/skycoin/skywire.git Move To Directory Move into the directory of the cloned repository. cd skywire Build Build skywire make build This command installs all dependencies, builds binaries and skywire apps Install Install skywire-visor, skywire-cli, hypervisor and app CLI execs. make install All Steps cd $HOME /apps git clone https://github.com/skycoin/skywire.git cd skywire make build make install Package Repository Debian Warning These packages are made from Skyfleet and are not officially maintained by Skycoin Danger When you use this way to install Skywire never use the Update Button inside the hypervisor, as this will cause problems with the packages. Only update as described here. Note Either use the command sudo su to run all the following commands as root, or insert a sudo before each of them. Add Repository Add the Skyfleet repository to your apt sources add-apt-repository 'deb http://skyfleet.github.io/armbian sid main' Note If add-apt-repository is not available, either use the command apt install software-properties-common or manually edit your sources with nano /etc/apt/sources.list and add deb http://skyfleet.github.io/armbian sid main # deb-src http://skyfleet.github.io/armbian sid main Add Signing Key Add the repository signing key with curl -L http://skyfleet.github.io/armbian/KEY.asc | sudo apt-key add - Install Resync the package database with apt update Install skywire with apt install skywire Update To update your skywire installation just use sudo -s apt update apt upgrade Danger Don't use the update button inside the hypervisor Archlinux Todo TODO: source: https://skyfleet.github.io/archlinuxarm Configure and Run Hypervisor Installed From Source Info First make sure you are in the directory of your skywire installation. The command to move into the directory of the example above would be: cd $HOME /apps/skycoin/skywire Configure In order to run the hypervisor, generate a hypervisor config file with ./hypervisor gen-config The output of this command is the generated hypervisor config file. Scroll until you find the entry pubkey and copy this key. We will need this later to configure our visor to accept our hypervisor. Run You can start the hypervisor with ./hypervisor Now move to http://localhost:8000 if you installed it on your local machine. If you have installed the hypervisor on another machine in your network just replace localhost with the ip of the device. Installed via Packet Manager TODO: See github.com/skyfleet/armbian Configure, Run and Control Visor Installed from Source Info If your hypervisor is running in the terminal we need another terminal to configure the visor. Press Ctrl + Alt + T to open another terminal. Then make sure you are in the directory of your skywire installation. Configure To run the visor we also have to generate a config file for it with ./skywire-cli visor gen-config The output of this command is the generated visor config file. Now open this config file with nano skywire-config.json Search for the entry hypervisors and paste the pubkey of the hypervisor. It should then look like this: Example v0.2.3 \"hypervisors\" : [{ \"public_key\" : \"02b72766f0ebade8e06d6969b5aeedaff8bf8efd7867f362bb4a63135ab6009775\" , \"address\" : \"127.0.0.1:7080\" }] , later versions \"hypervisors\" : [ \"035feb3654daa9ceede16da44ada97c1503087d5c41f2651ec15b8294d8a11130d\" ] }] , Run You can start the hypervisor with ./skywire-visor skywire-config.json Control You can control the visor with skywire-cli Refer to the help menu for usage: ./skywire-cli -h Installed via Packet Manager TODO: See github.com/skyfleet/armbian Systemd Service Info You can use systemd services to auto start your visors and hypervisors Installed from Source Hypervisor Copy the text below and make changings to the ExecStart line depending on your installation directory and where you have your config file. Note You can move the config file to a position of your choice but you have to edit the path to it in the systemd service file [ Unit ] Description = Skywire Hypervisor After = network . target [ Service ] Type = simple User = root Group = root ExecStart = / usr / bin / hypervisor - c / etc / hypervisor - config . json Restart = on - failure RestartSec = 20 TimeoutSec = 30 [ Install ] WantedBy = multi - user . target 2. Create a file by typing the follwing command into the terminal sudo nano / etc / systemd / system / skywire - hypervisor . service Paste your edited text from Step 1 into this file, press CTRL + X to save, then Y and ENTER to accept. Enable the systemd service with sudo systemctl daemon - reload sudo systemctl enable skywire - hypervisor . service 5. Start the systemd service with sudo systemctl start skywire - hypervisor . services Visor Copy the text below and make changings to the ExecStart line depending on your installation directory and where you have your config file. Warning Check inside your skywire-config.json file that the entry 'bin_path' is set to your-installation-directory/apps 'local_path' is set to /var/skywire-visor/apps Note You can move the config file to a position of your choice but you have to edit the path to it in the systemd service file [ Unit ] Description = Skywire Hypervisor After = network . target [ Service ] Type = simple User = root Group = root ExecStart = / usr / bin / skywire - visor - c / etc / skywire - config . json Restart = on - failure RestartSec = 20 TimeoutSec = 30 [ Install ] WantedBy = multi - user . target 2. Create a file by typing the follwing command into the terminal sudo nano / etc / systemd / system / skywire - visor . service Paste your edited text from Step 1 into this file, press CTRL + X to save, then Y and ENTER to accept. Enable the systemd service with sudo systemctl daemon - reload sudo systemctl enable skywire - visor . service 5. Start the systemd service with sudo systemctl start skywire - visor . services Helpful systemctl commands Installed via Packet Manager The systemd services are already in place. You just have to type in sudo systemctl daemon - reload sudo systemctl start skywire - visor //for the visor sudo systemctl start skywire - hypervisor //for the hypervisor","title":"Linux"},{"location":"software/skywire/installation-linux/#from-source","text":"","title":"From Source"},{"location":"software/skywire/installation-linux/#requirements","text":"Skywire requires a version of golang with go modules support. apt apt-get install golang check your version with go version manually TODO: Add commands","title":"Requirements"},{"location":"software/skywire/installation-linux/#build","text":"Follow the steps by copy & paste-ing all the commands into your terminal. Installation Directory Move into the folder where you want to install skywire with the command cd For example: cd $HOME /apps Clone Clone the repository. git clone https://github.com/skycoin/skywire.git Move To Directory Move into the directory of the cloned repository. cd skywire Build Build skywire make build This command installs all dependencies, builds binaries and skywire apps Install Install skywire-visor, skywire-cli, hypervisor and app CLI execs. make install All Steps cd $HOME /apps git clone https://github.com/skycoin/skywire.git cd skywire make build make install","title":"Build"},{"location":"software/skywire/installation-linux/#package-repository","text":"","title":"Package Repository"},{"location":"software/skywire/installation-linux/#debian","text":"Warning These packages are made from Skyfleet and are not officially maintained by Skycoin Danger When you use this way to install Skywire never use the Update Button inside the hypervisor, as this will cause problems with the packages. Only update as described here. Note Either use the command sudo su to run all the following commands as root, or insert a sudo before each of them. Add Repository Add the Skyfleet repository to your apt sources add-apt-repository 'deb http://skyfleet.github.io/armbian sid main' Note If add-apt-repository is not available, either use the command apt install software-properties-common or manually edit your sources with nano /etc/apt/sources.list and add deb http://skyfleet.github.io/armbian sid main # deb-src http://skyfleet.github.io/armbian sid main Add Signing Key Add the repository signing key with curl -L http://skyfleet.github.io/armbian/KEY.asc | sudo apt-key add - Install Resync the package database with apt update Install skywire with apt install skywire Update To update your skywire installation just use sudo -s apt update apt upgrade Danger Don't use the update button inside the hypervisor","title":"Debian"},{"location":"software/skywire/installation-linux/#archlinux","text":"Todo TODO: source: https://skyfleet.github.io/archlinuxarm","title":"Archlinux"},{"location":"software/skywire/installation-linux/#configure-and-run-hypervisor","text":"Installed From Source Info First make sure you are in the directory of your skywire installation. The command to move into the directory of the example above would be: cd $HOME /apps/skycoin/skywire Configure In order to run the hypervisor, generate a hypervisor config file with ./hypervisor gen-config The output of this command is the generated hypervisor config file. Scroll until you find the entry pubkey and copy this key. We will need this later to configure our visor to accept our hypervisor. Run You can start the hypervisor with ./hypervisor Now move to http://localhost:8000 if you installed it on your local machine. If you have installed the hypervisor on another machine in your network just replace localhost with the ip of the device. Installed via Packet Manager TODO: See github.com/skyfleet/armbian","title":"Configure and Run Hypervisor"},{"location":"software/skywire/installation-linux/#configure-run-and-control-visor","text":"Installed from Source Info If your hypervisor is running in the terminal we need another terminal to configure the visor. Press Ctrl + Alt + T to open another terminal. Then make sure you are in the directory of your skywire installation. Configure To run the visor we also have to generate a config file for it with ./skywire-cli visor gen-config The output of this command is the generated visor config file. Now open this config file with nano skywire-config.json Search for the entry hypervisors and paste the pubkey of the hypervisor. It should then look like this: Example v0.2.3 \"hypervisors\" : [{ \"public_key\" : \"02b72766f0ebade8e06d6969b5aeedaff8bf8efd7867f362bb4a63135ab6009775\" , \"address\" : \"127.0.0.1:7080\" }] , later versions \"hypervisors\" : [ \"035feb3654daa9ceede16da44ada97c1503087d5c41f2651ec15b8294d8a11130d\" ] }] , Run You can start the hypervisor with ./skywire-visor skywire-config.json Control You can control the visor with skywire-cli Refer to the help menu for usage: ./skywire-cli -h Installed via Packet Manager TODO: See github.com/skyfleet/armbian","title":"Configure, Run and Control Visor"},{"location":"software/skywire/installation-linux/#systemd-service","text":"Info You can use systemd services to auto start your visors and hypervisors Installed from Source Hypervisor Copy the text below and make changings to the ExecStart line depending on your installation directory and where you have your config file. Note You can move the config file to a position of your choice but you have to edit the path to it in the systemd service file [ Unit ] Description = Skywire Hypervisor After = network . target [ Service ] Type = simple User = root Group = root ExecStart = / usr / bin / hypervisor - c / etc / hypervisor - config . json Restart = on - failure RestartSec = 20 TimeoutSec = 30 [ Install ] WantedBy = multi - user . target 2. Create a file by typing the follwing command into the terminal sudo nano / etc / systemd / system / skywire - hypervisor . service Paste your edited text from Step 1 into this file, press CTRL + X to save, then Y and ENTER to accept. Enable the systemd service with sudo systemctl daemon - reload sudo systemctl enable skywire - hypervisor . service 5. Start the systemd service with sudo systemctl start skywire - hypervisor . services Visor Copy the text below and make changings to the ExecStart line depending on your installation directory and where you have your config file. Warning Check inside your skywire-config.json file that the entry 'bin_path' is set to your-installation-directory/apps 'local_path' is set to /var/skywire-visor/apps Note You can move the config file to a position of your choice but you have to edit the path to it in the systemd service file [ Unit ] Description = Skywire Hypervisor After = network . target [ Service ] Type = simple User = root Group = root ExecStart = / usr / bin / skywire - visor - c / etc / skywire - config . json Restart = on - failure RestartSec = 20 TimeoutSec = 30 [ Install ] WantedBy = multi - user . target 2. Create a file by typing the follwing command into the terminal sudo nano / etc / systemd / system / skywire - visor . service Paste your edited text from Step 1 into this file, press CTRL + X to save, then Y and ENTER to accept. Enable the systemd service with sudo systemctl daemon - reload sudo systemctl enable skywire - visor . service 5. Start the systemd service with sudo systemctl start skywire - visor . services Helpful systemctl commands Installed via Packet Manager The systemd services are already in place. You just have to type in sudo systemctl daemon - reload sudo systemctl start skywire - visor //for the visor sudo systemctl start skywire - hypervisor //for the hypervisor","title":"Systemd Service"},{"location":"software/skywire/installation-macos/","text":"","title":"macOS"},{"location":"software/skywire/installation-overview/","text":"Install Skywire To install you have got different options depending on your hardware and your os. Installation problems If you ever run into troubles with you installation post your problem in the Telegram group Skywire Mainnet . Linux If you want to install skywire on linux distributions please follow the tutorial here . macOS For the tutorial on macOS please read through this . Windows 10 Warning At the moment on Windows 10 you only can install a hypervisor to remotely configure your visors. To install a hypervisor on windows have a look at the tutorial here . Raspberry Pi & SBCs Skybian recommended Although you could run a linux distribution on a Raspberry Pi (or a similar SBC) and install skywire via the linux distribution tutorial, it is recommended to use official skybian images. Those images already have all needed packages and requirements installed. So in short skybian is raspberryOS with: skywire installed ssh enabled video enabled tty enabled network-manager installed. To set up a skywire visor from scratch on a raspberry pi follow the tutorial here .","title":"Overview"},{"location":"software/skywire/installation-overview/#install-skywire","text":"To install you have got different options depending on your hardware and your os. Installation problems If you ever run into troubles with you installation post your problem in the Telegram group Skywire Mainnet . Linux If you want to install skywire on linux distributions please follow the tutorial here . macOS For the tutorial on macOS please read through this . Windows 10 Warning At the moment on Windows 10 you only can install a hypervisor to remotely configure your visors. To install a hypervisor on windows have a look at the tutorial here . Raspberry Pi & SBCs Skybian recommended Although you could run a linux distribution on a Raspberry Pi (or a similar SBC) and install skywire via the linux distribution tutorial, it is recommended to use official skybian images. Those images already have all needed packages and requirements installed. So in short skybian is raspberryOS with: skywire installed ssh enabled video enabled tty enabled network-manager installed. To set up a skywire visor from scratch on a raspberry pi follow the tutorial here .","title":"Install Skywire"},{"location":"software/skywire/installation-raspberrypi/","text":"This tutorial explains how to set up a visor on a raspberry pi from scratch. Follow all steps and there shouldn't pop up any problems. Requirements Raspberry Pi 3 or 4 (or any other supported SBC ) SD-Card (at least ?? GB storage) SD-Card reader Balena Etcher Installation Install Skyimager MacOS Go to the Skybian release page . Download the binary that contains the word \"darwin\". Unzip the file by double clicking on it. Open the binary Now a Graphic User Interface should be opened automatically. If you do not see any UI, open http://127.0.0.1:8080/ within your browser. Info The system may display a security warning. If that is the case, open your system settings and go to security. There you should find the option to open the binary. Linux Go to the Skybian release page . Download the latest \"linux\"-binary Unzip the file with: unxz $PATH_TO_BINARY ; tar -xf $PATH_TO_BINARY Open the binary ./fyne-cross/bin/.../skyimager-gui binary Now a Graphic User Interface should be opened automatically. If you do not see any UI, open http://127.0.0.1:8080/ within your browser. Windows Go to the Skybian release page . Download the \"windows\"-binary Unzip the file with an unzipping tool such as 7zip . Open the binary Now a Graphic User Interface should be opened automatically. If you do not see any UI, open http://127.0.0.1:8080/ within your browser. Generating images TODO Flashing images TODO Helpful Links Configure wlan via command line Supported SBCs TODO: add list","title":"Raspberry Pi & SBCs"},{"location":"software/skywire/installation-raspberrypi/#requirements","text":"Raspberry Pi 3 or 4 (or any other supported SBC ) SD-Card (at least ?? GB storage) SD-Card reader Balena Etcher","title":"Requirements"},{"location":"software/skywire/installation-raspberrypi/#installation","text":"Install Skyimager MacOS Go to the Skybian release page . Download the binary that contains the word \"darwin\". Unzip the file by double clicking on it. Open the binary Now a Graphic User Interface should be opened automatically. If you do not see any UI, open http://127.0.0.1:8080/ within your browser. Info The system may display a security warning. If that is the case, open your system settings and go to security. There you should find the option to open the binary. Linux Go to the Skybian release page . Download the latest \"linux\"-binary Unzip the file with: unxz $PATH_TO_BINARY ; tar -xf $PATH_TO_BINARY Open the binary ./fyne-cross/bin/.../skyimager-gui binary Now a Graphic User Interface should be opened automatically. If you do not see any UI, open http://127.0.0.1:8080/ within your browser. Windows Go to the Skybian release page . Download the \"windows\"-binary Unzip the file with an unzipping tool such as 7zip . Open the binary Now a Graphic User Interface should be opened automatically. If you do not see any UI, open http://127.0.0.1:8080/ within your browser. Generating images TODO Flashing images TODO","title":"Installation"},{"location":"software/skywire/installation-raspberrypi/#helpful-links","text":"Configure wlan via command line","title":"Helpful Links"},{"location":"software/skywire/installation-raspberrypi/#supported-sbcs","text":"TODO: add list","title":"Supported SBCs"},{"location":"software/skywire/installation-windows/","text":"Warning On Windows 10 you only can interface your visors via the hypervisor. It is not possible to install a visor on Windows 10 at the moment. Installing the Hypervisor In order to run the hypervisor on Windows 10 we choose to take advantage of the available Linux Subsystem. Just follow the next steps to setup Ubuntu 18 Linux Subsystem and configure the hypervisor. Note The following commands can be pasted directly in Powershell using the right click on the mouse. 1. Enable Linux Subsystem Press WIN + X and then A to open Powershell as administrator Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Save your work on the pc and confirm with Y and press Enter when asked to reboot. 2. Install Ubuntu 18 Linux Subsystem Press WIN + X and then A to open Powershell as administrator Create a folder on partition C: named Ubuntu18 mkdir C: \\U buntu18 cd C: \\U buntu18 Download Ubuntu 18 Linux Subsystem Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu18.appx -UseBasicParsing Install Add-AppxPackage . \\U buntu18.appx 3. Run Ubuntu 18 Linux Subsystem Press WIN and type Ubuntu Open the top result and the terminal to your Linux Subsystem will start. Set a username and the password, which needs to be written twice (the password will not be shown as you write it). 4. Make Installation Directories in Linux Subsystem Note The next commands you can copy and paste into the terminal using the right click in the terminal. sudo mkdir -p /var/skywire-hypervisor sudo mkdir -p /etc/skywire-hypervisor sudo mkdir -p /tmp/ { bin,log,run } 5. Download the latest skywire-mainnet release Go to https://github.com/skycoin/skywire/releases and search for the latest release with the ending amd64.tar.gz Right click on the hyperlink and save the link location. Warning Now you have to update the example with the saved link. Don't copy and paste or you will install an old version Example sudo wget -c https://github.com/skycoin/skywire/releases/download/v0.2.3/skywire-v0.2.3-linux-amd64.tar.gz -O /tmp/skywire.tar.gz 6. Extract and move extracted files sudo tar xvzf /tmp/skywire.tar.gz -C /tmp/bin sudo mv /tmp/bin/hypervisor /tmp/bin/skywire-hypervisor sudo cp -rf /tmp/bin/* /usr/bin/ 7. Generate the hypervisor config and adjust it to enable password authentication. sudo /usr/bin/skywire-hypervisor gen-config -o /etc/skywire-hypervisor.json sudo sed -i 's+\"enable_auth\": false+\"enable_auth\": true+g' /etc/skywire-hypervisor.json sudo sed -i 's+.*\"db_path\".*+\"db_path\": \"/var/skywire-hypervisor/users.db\",+' /etc/skywire-hypervisor.json 8. Download and enable skywire service sudo wget -c https://raw.githubusercontent.com/asxtree/skywire-mainnet/asxtree-patch-1/static/skywire-manager-src/skywire.service -O /etc/init.d/skywire.service Enable the service to run when we start the Linux Subsystem sudo chmod a+x /etc/init.d/skywire.service sudo update-rc.d skywire.service defaults 97 03 9. First start and restart of the service sudo service skywire.service start && sudo service skywire.service restart 10. Get the public key of the hypervisor Note Copy the public key that will be printed. Then you can add this public key to all the visor configs named skywire-config.json you want to interface with via the hypervisor. See Configure, Run and Control Visor cat /etc/skywire-hypervisor.json | grep \"public_key\" | awk '{print substr($2,2,66)}'","title":"Windows"},{"location":"software/skywire/installation-windows/#installing-the-hypervisor","text":"In order to run the hypervisor on Windows 10 we choose to take advantage of the available Linux Subsystem. Just follow the next steps to setup Ubuntu 18 Linux Subsystem and configure the hypervisor. Note The following commands can be pasted directly in Powershell using the right click on the mouse.","title":"Installing the Hypervisor"},{"location":"software/skywire/installation-windows/#1-enable-linux-subsystem","text":"Press WIN + X and then A to open Powershell as administrator Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Save your work on the pc and confirm with Y and press Enter when asked to reboot.","title":"1. Enable Linux Subsystem"},{"location":"software/skywire/installation-windows/#2-install-ubuntu-18-linux-subsystem","text":"Press WIN + X and then A to open Powershell as administrator Create a folder on partition C: named Ubuntu18 mkdir C: \\U buntu18 cd C: \\U buntu18 Download Ubuntu 18 Linux Subsystem Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu18.appx -UseBasicParsing Install Add-AppxPackage . \\U buntu18.appx","title":"2. Install Ubuntu 18 Linux Subsystem"},{"location":"software/skywire/installation-windows/#3-run-ubuntu-18-linux-subsystem","text":"Press WIN and type Ubuntu Open the top result and the terminal to your Linux Subsystem will start. Set a username and the password, which needs to be written twice (the password will not be shown as you write it).","title":"3. Run Ubuntu 18 Linux Subsystem"},{"location":"software/skywire/installation-windows/#4-make-installation-directories-in-linux-subsystem","text":"Note The next commands you can copy and paste into the terminal using the right click in the terminal. sudo mkdir -p /var/skywire-hypervisor sudo mkdir -p /etc/skywire-hypervisor sudo mkdir -p /tmp/ { bin,log,run }","title":"4. Make Installation Directories in Linux Subsystem"},{"location":"software/skywire/installation-windows/#5-download-the-latest-skywire-mainnet-release","text":"Go to https://github.com/skycoin/skywire/releases and search for the latest release with the ending amd64.tar.gz Right click on the hyperlink and save the link location. Warning Now you have to update the example with the saved link. Don't copy and paste or you will install an old version Example sudo wget -c https://github.com/skycoin/skywire/releases/download/v0.2.3/skywire-v0.2.3-linux-amd64.tar.gz -O /tmp/skywire.tar.gz","title":"5. Download the latest skywire-mainnet release"},{"location":"software/skywire/installation-windows/#6-extract-and-move-extracted-files","text":"sudo tar xvzf /tmp/skywire.tar.gz -C /tmp/bin sudo mv /tmp/bin/hypervisor /tmp/bin/skywire-hypervisor sudo cp -rf /tmp/bin/* /usr/bin/","title":"6. Extract and move extracted files"},{"location":"software/skywire/installation-windows/#7-generate-the-hypervisor-config-and-adjust-it-to-enable-password-authentication","text":"sudo /usr/bin/skywire-hypervisor gen-config -o /etc/skywire-hypervisor.json sudo sed -i 's+\"enable_auth\": false+\"enable_auth\": true+g' /etc/skywire-hypervisor.json sudo sed -i 's+.*\"db_path\".*+\"db_path\": \"/var/skywire-hypervisor/users.db\",+' /etc/skywire-hypervisor.json","title":"7. Generate the hypervisor config and adjust it to enable password authentication."},{"location":"software/skywire/installation-windows/#8-download-and-enable-skywire-service","text":"sudo wget -c https://raw.githubusercontent.com/asxtree/skywire-mainnet/asxtree-patch-1/static/skywire-manager-src/skywire.service -O /etc/init.d/skywire.service Enable the service to run when we start the Linux Subsystem sudo chmod a+x /etc/init.d/skywire.service sudo update-rc.d skywire.service defaults 97 03","title":"8. Download and enable skywire service"},{"location":"software/skywire/installation-windows/#9-first-start-and-restart-of-the-service","text":"sudo service skywire.service start && sudo service skywire.service restart","title":"9. First start and restart of the service"},{"location":"software/skywire/installation-windows/#10-get-the-public-key-of-the-hypervisor","text":"Note Copy the public key that will be printed. Then you can add this public key to all the visor configs named skywire-config.json you want to interface with via the hypervisor. See Configure, Run and Control Visor cat /etc/skywire-hypervisor.json | grep \"public_key\" | awk '{print substr($2,2,66)}'","title":"10. Get the public key of the hypervisor"},{"location":"software/skywire/whitelisting/","text":"","title":"Whitelisting"},{"location":"software/skywire/apps/overview/","text":"Source: github.com/skycoin/skywire/cmd/apps App Description ... Proxy SOCKS5 Proxy Skychat Encrypted p2p chat VPN Virtual Private Network","title":"Overview"},{"location":"software/skywire/apps/proxy/","text":"Introduction This guide will teach you how to use the Skywire SOCKS5 proxy utilizing a proxy app of your choice, the example is made with FoxyProxy . You can use the Skywire SOCKS5 proxy to circumvent geo-blocking as an example use case. Requirements Running Skywire hypervisor & visors(s) Prepared port forwarding rules dependent on your network topology Network connection Firefox , Chrome or other browsers capable of using a proxy service Prepare Visor Open your local hypervisor by visiting http://localhost:8000 in a webbrowser. In order to setup a proxy connection, start by clicking on one of the visors that appear in your hypervisorUI . This will open up an overview page for the specific visor you chose. Click onto the + button next to the transport field. Input the PublicKey of the remote visor and select dmsg as the transport type. This should setup a transport to a remote visor . Switch to the Apps tab of the UI and click on the gear icon next to the skysocks-client application and input the PublicKey of the remote visor again. Afterwards, start the skysocks-client by clicking on the triangle next to skysocks-client . The proxy connection should now be succesfully setup. You can use the proxy by configuring your browser to use the connection exposed on localhost:1080 . Setup FoxyProxy Settings By now you have: obtained the IP address of your visor, the following examples based on the IP 10.0.0.31 , yours might be different and you have to adjust it . installed FoxyProxy plugin Click on Options : Add a new rule: You have to change the following depending on your visor: remote visor Proxy Type to SOCKS5 Title or description as you prefer, we suggest using SkywireSOCKS5 IP address to the IP address of your visor, in this example 10.0.0.31 Port to the displayed port of the connection, use 1080 Enter the password of the remote skysocks-server is password protected. If the remote is password protected, you will also need to \"Skywire\" into the Username field. local visor Proxy Type to SOCKS5 Title or description as you prefer, we suggest using SkywireSOCKS5_locally IP address to the IP address of your visor, in this example 127.0.0.1 Port to the displayed port of the connection, use 1080 Enter the password of the remote skysocks-server is password protected. If the remote is password protected, you will also need to \"Skywire\" into the Username field. Note The Skywire SOCKS5 proxy uses always port 1080 for establishing the connection. Should look like this: That's it for now with FoxyProxy. Troubleshooting Websites are loading very slowly, slow connection Some nodes may not have the fastest network connection, or they may be using a free VPN service to tunnel their traffic. Both cases would result in a slow connection for you. As you can't change anything about the two causes you can only disconnect and try out another node. Establishing connections works but websites aren't loading This could have several reasons: The wrong rule in FoxyProxy, double check the settings you set up in the FoxyProxy plugin and ask in the community if you can't find the mistake. Highly restricted website access on the connected node because it is using OpenDNS or similar services which results in a blocked connection to certain services on your end. Nothing you can do about that.","title":"Proxy"},{"location":"software/skywire/apps/proxy/#introduction","text":"This guide will teach you how to use the Skywire SOCKS5 proxy utilizing a proxy app of your choice, the example is made with FoxyProxy . You can use the Skywire SOCKS5 proxy to circumvent geo-blocking as an example use case.","title":"Introduction"},{"location":"software/skywire/apps/proxy/#requirements","text":"Running Skywire hypervisor & visors(s) Prepared port forwarding rules dependent on your network topology Network connection Firefox , Chrome or other browsers capable of using a proxy service","title":"Requirements"},{"location":"software/skywire/apps/proxy/#prepare-visor","text":"Open your local hypervisor by visiting http://localhost:8000 in a webbrowser. In order to setup a proxy connection, start by clicking on one of the visors that appear in your hypervisorUI . This will open up an overview page for the specific visor you chose. Click onto the + button next to the transport field. Input the PublicKey of the remote visor and select dmsg as the transport type. This should setup a transport to a remote visor . Switch to the Apps tab of the UI and click on the gear icon next to the skysocks-client application and input the PublicKey of the remote visor again. Afterwards, start the skysocks-client by clicking on the triangle next to skysocks-client . The proxy connection should now be succesfully setup. You can use the proxy by configuring your browser to use the connection exposed on localhost:1080 .","title":"Prepare Visor"},{"location":"software/skywire/apps/proxy/#setup-foxyproxy-settings","text":"By now you have: obtained the IP address of your visor, the following examples based on the IP 10.0.0.31 , yours might be different and you have to adjust it . installed FoxyProxy plugin Click on Options : Add a new rule: You have to change the following depending on your visor: remote visor Proxy Type to SOCKS5 Title or description as you prefer, we suggest using SkywireSOCKS5 IP address to the IP address of your visor, in this example 10.0.0.31 Port to the displayed port of the connection, use 1080 Enter the password of the remote skysocks-server is password protected. If the remote is password protected, you will also need to \"Skywire\" into the Username field. local visor Proxy Type to SOCKS5 Title or description as you prefer, we suggest using SkywireSOCKS5_locally IP address to the IP address of your visor, in this example 127.0.0.1 Port to the displayed port of the connection, use 1080 Enter the password of the remote skysocks-server is password protected. If the remote is password protected, you will also need to \"Skywire\" into the Username field. Note The Skywire SOCKS5 proxy uses always port 1080 for establishing the connection. Should look like this: That's it for now with FoxyProxy.","title":"Setup FoxyProxy Settings"},{"location":"software/skywire/apps/proxy/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"software/skywire/apps/proxy/#websites-are-loading-very-slowly-slow-connection","text":"Some nodes may not have the fastest network connection, or they may be using a free VPN service to tunnel their traffic. Both cases would result in a slow connection for you. As you can't change anything about the two causes you can only disconnect and try out another node.","title":"Websites are loading very slowly, slow connection"},{"location":"software/skywire/apps/proxy/#establishing-connections-works-but-websites-arent-loading","text":"This could have several reasons: The wrong rule in FoxyProxy, double check the settings you set up in the FoxyProxy plugin and ask in the community if you can't find the mistake. Highly restricted website access on the connected node because it is using OpenDNS or similar services which results in a blocked connection to certain services on your end. Nothing you can do about that.","title":"Establishing connections works but websites aren't loading"},{"location":"software/skywire/apps/skychat/","text":"TODO","title":"Skychat"},{"location":"software/skywire/apps/vpn/","text":"Setup VPN VPN Client This guide explains the setup procedure and includes operating instructions of the Skywire VPN Client. Please refer to the VPN Server guide in case you want to run a Skywire VPN Server for Skywire VPN . Warning Setting up a Skywire VPN Client is currently only documented for Linux und MacOS. A guide for setting up Skywire VPN on Windows will follow. Installers and a more streamlined UI for setting up VPN connections will be available with the next release. Note In order to use Skywire VPN, you need to install Skywire on your computer. Follow this guide to install Skywire. The rest of this guide assumes that you have installed both the Skywire Visor and Skywire Hypervisor and generated configuration files. Once you have Skywire installed, you can either continue setting up the Skywire VPN Client through the Hypervisor UI or via CLI (terminal). Hypervisor UI Open your hypervisor on http://localhost:8000 Inside the hypervisor, click on the visor you just connected and access the Apps tab. In order to browse for available VPN servers, click on the gear icon next to the VPN client and select Search . To select a remote VPN server, click on the public key and select Yes in the popup. Afterwards copy the public key you selected. Return to the Routing tab and establish a transport to the remote visor you selected as VPN server. Note The stcpr and sudph transport types will have the best performance. Try to establish these transport types first. If these are not available (red circle appears next to the transport) establish a dmsg transport. After establishing a transport to the remote, return to the App tab and click the Start button next to the VPN client. If the connection was established successfully, the circle next to the vpn-client will turn green. If the connection is setup and live, the up- and download windows in the bottom right corner will show constant increases in data sent and received. Note After starting the VPN client successfully, all the network traffic will be routed through the VPN connection until the connection is shutdown. You can close the Skywire VPN by clicking the stop button. CLI (terminal) This section outlines the installation steps by using a regular command-line interface/terminal. After installing Skywire, open up skywire-config.json with your prefered editor. Insert the public key of the VPN server into the vpn-server field in the following way: { \"name\" : \"vpn-client\" , \"args\" : [ \"-srv\" , \"02f9c5ebd8e480d33b0de67555089bcd85cc1d70c70a17fa5827159c0fcf0a755c\" ], \"auto_start\" : false , \"port\" : 43 } In order to obtain a list of available VPN servers, you can use the following link: https://service.discovery.skycoin.com/api/services?type=vpn Continue by starting the Skywire visor with sudo skywire-visor Enter your password if prompted. Afterwards, replace the values below with the remote public key you selected: skywire-cli visor add-tp 02f9c5ebd8e480d33b0de67555089bcd85cc1d70c70a17fa5827159c0fcf0a755c --type stcpr Note The stcpr and sudph transports are the most performant. It is recommended to try to setup these transports first. If these are not available, setup a dmsg transport. After you setup the transport, start the VPN by running: skywire-cli visor start-app vpn-client In order to stop the VPN, run: skywire-cli visor stop-app vpn-client VPN Server This guide explains the setup procedure and includes operating instructions of the Skywire VPN Server. Info For ease of setting up a connection to your VPN server, it is recommended to deploy the VPN server on a machine with a public IP. This will allow clients to establish stcpr transports which use a simple TCP connection instead of relayed connections over dmsg . Hypervisor UI TODO CLI (terminal) Configure VPN Server The Skywire VPN server can be configured to require a passcode for authentication of clients or be freely accessible but in order to be publicly advertised in Skycoin's service discovery, it is required for the VPN server to be freely accessible without passcode! If you wish to set a passcode, you can pass the following argument to the skywire-config.json { \"name\" : \"vpn-server\" , \"auto_start\" : false , \"port\" : 44 , \"args\" :[ \"-passcode\" , \"123456\" ] } In order to automatically start the VPN server upon startup of the Skywire Visor, set auto_start to true . Otherwise, the VPN server needs to be started manually after the Visor was started. Operating Skywire VPN Server The following assumes that you either use multiple terminals or take care of detaching processes from the terminal yourself. In order to run the Skywire VPN server, first run the Visor sudo skywire-visor Note: The VPN server requires root privileges to setup a TUN interface and configure the systems routing rules. Afterwards, start the VPN server with skywire-cli visor start-app vpn-server In order to stop the VPN server you can either stop the Visor or run skywire-cli visor stop-app vpn-server","title":"VPN"},{"location":"software/skywire/apps/vpn/#setup-vpn","text":"VPN Client This guide explains the setup procedure and includes operating instructions of the Skywire VPN Client. Please refer to the VPN Server guide in case you want to run a Skywire VPN Server for Skywire VPN . Warning Setting up a Skywire VPN Client is currently only documented for Linux und MacOS. A guide for setting up Skywire VPN on Windows will follow. Installers and a more streamlined UI for setting up VPN connections will be available with the next release. Note In order to use Skywire VPN, you need to install Skywire on your computer. Follow this guide to install Skywire. The rest of this guide assumes that you have installed both the Skywire Visor and Skywire Hypervisor and generated configuration files. Once you have Skywire installed, you can either continue setting up the Skywire VPN Client through the Hypervisor UI or via CLI (terminal). Hypervisor UI Open your hypervisor on http://localhost:8000 Inside the hypervisor, click on the visor you just connected and access the Apps tab. In order to browse for available VPN servers, click on the gear icon next to the VPN client and select Search . To select a remote VPN server, click on the public key and select Yes in the popup. Afterwards copy the public key you selected. Return to the Routing tab and establish a transport to the remote visor you selected as VPN server. Note The stcpr and sudph transport types will have the best performance. Try to establish these transport types first. If these are not available (red circle appears next to the transport) establish a dmsg transport. After establishing a transport to the remote, return to the App tab and click the Start button next to the VPN client. If the connection was established successfully, the circle next to the vpn-client will turn green. If the connection is setup and live, the up- and download windows in the bottom right corner will show constant increases in data sent and received. Note After starting the VPN client successfully, all the network traffic will be routed through the VPN connection until the connection is shutdown. You can close the Skywire VPN by clicking the stop button. CLI (terminal) This section outlines the installation steps by using a regular command-line interface/terminal. After installing Skywire, open up skywire-config.json with your prefered editor. Insert the public key of the VPN server into the vpn-server field in the following way: { \"name\" : \"vpn-client\" , \"args\" : [ \"-srv\" , \"02f9c5ebd8e480d33b0de67555089bcd85cc1d70c70a17fa5827159c0fcf0a755c\" ], \"auto_start\" : false , \"port\" : 43 } In order to obtain a list of available VPN servers, you can use the following link: https://service.discovery.skycoin.com/api/services?type=vpn Continue by starting the Skywire visor with sudo skywire-visor Enter your password if prompted. Afterwards, replace the values below with the remote public key you selected: skywire-cli visor add-tp 02f9c5ebd8e480d33b0de67555089bcd85cc1d70c70a17fa5827159c0fcf0a755c --type stcpr Note The stcpr and sudph transports are the most performant. It is recommended to try to setup these transports first. If these are not available, setup a dmsg transport. After you setup the transport, start the VPN by running: skywire-cli visor start-app vpn-client In order to stop the VPN, run: skywire-cli visor stop-app vpn-client VPN Server This guide explains the setup procedure and includes operating instructions of the Skywire VPN Server. Info For ease of setting up a connection to your VPN server, it is recommended to deploy the VPN server on a machine with a public IP. This will allow clients to establish stcpr transports which use a simple TCP connection instead of relayed connections over dmsg . Hypervisor UI TODO CLI (terminal) Configure VPN Server The Skywire VPN server can be configured to require a passcode for authentication of clients or be freely accessible but in order to be publicly advertised in Skycoin's service discovery, it is required for the VPN server to be freely accessible without passcode! If you wish to set a passcode, you can pass the following argument to the skywire-config.json { \"name\" : \"vpn-server\" , \"auto_start\" : false , \"port\" : 44 , \"args\" :[ \"-passcode\" , \"123456\" ] } In order to automatically start the VPN server upon startup of the Skywire Visor, set auto_start to true . Otherwise, the VPN server needs to be started manually after the Visor was started. Operating Skywire VPN Server The following assumes that you either use multiple terminals or take care of detaching processes from the terminal yourself. In order to run the Skywire VPN server, first run the Visor sudo skywire-visor Note: The VPN server requires root privileges to setup a TUN interface and configure the systems routing rules. Afterwards, start the VPN server with skywire-cli visor start-app vpn-server In order to stop the VPN server you can either stop the Visor or run skywire-cli visor stop-app vpn-server","title":"Setup VPN"}]}